{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fnil\fcharset77 Monaco;\f2\fswiss\fcharset77 Helvetica;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red96\green96\blue96;\red191\green0\blue0;
\red0\green0\blue191;\red0\green0\blue0;\red96\green96\blue96;\red191\green0\blue0;\red0\green115\blue0;
}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 \
InFeedback
\fs28 				read signal from a bus without erasing it\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs18 \cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 	superclass: MultiOutUGen\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf2 \
	\
	
\f0\b\fs24 \cf0 InFeedback.ar(busNumber,numChannels);\
	\
	
\f1\b0\fs18 \cf2 \
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 The output (Out) ugens overwrite data on the bus, giving this bus\
a new timestamp so that any input (In) ugen can check if the data was written\
within the current cycle. The next cycle this data is still there, but\
in case of audio one normally doesn't want an in ugen to read it again,\
as it might cause feedback.\
\
This is the reason why In.ar checks the timestamp and ignores everything\
that was not written within this cycle. This means that nodes can only\
read data from a bus that was written by a preceeding node when using\
the In.ar ugen which overwrites the old data. This is good for audio,\
but for control data it is more convenient to be able to read a bus\
from any place in the node order.\
\
This is why In.kr behaves differently and reads also data with a timestamp\
that is one cycle old. Now in some cases we want to be able to read audio\
from a bus independant of the current node order, which is the use of InFeedback.\
The delay introduced by this is at a maximum one block size, which equals\
about 0.0014 sec at the default block size and sample rate.
\f1\fs18 \cf2 \
\
\
\
\

\

\f2\fs24 \cf0 \
audio feedback modulation:\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf2 \
	SynthDef\cf0 (\cf3 "help-InFeedback"\cf0 , \{ \cf2 arg\cf0  busNumber=0, busInNumber=0;\
		\cf2 var\cf0  in, sound;\
			in = \cf2 InFeedback.ar(\cf0 busInNumber, 1);\
			sound = SinOsc.ar(in * 1300 + 300, 0, 0.4);\cf4 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 			\cf2 Out\cf0 .ar(busNumber, sound);\
\
	\}).play;\
	\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 this shows how a node can read audio from a following bus:
\f1\fs18 \cf2 \
\
	\cf5 SynthDef\cf6 (\cf7 "help-InFeedback"\cf6 , \{ \cf5 arg\cf6  out=0, in=0;\
		\cf5 Out\cf6 .ar(out,\
			\cf5 InFeedback\cf6 .ar(in, 1)\
		);\
	\}).load(s);\
	\cf5 SynthDef\cf6 (\cf7 "help-SinOsc"\cf6 , \{ \cf5 arg\cf6  out=0, freq=440;\
		\cf5 Out\cf6 .ar(out, \cf5 SinOsc\cf6 .ar(freq, 0, 0.1))\
	\}).load(s);\
\
	\cf8 //read from bus 10 play to bus 0\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf6 	a = \cf5 Synth\cf6 (\cf7 "help-InFeedback"\cf6 ,[\cf9 \\in\cf6 , 10, \cf9 \\out\cf6 , 0]);\
\
	\cf8 //now play a synth after this one, playing to bus 10\
\cf6 	\cf5 Synth\cf6 .after(a, \cf7 "help-SinOsc"\cf6 , [\cf9 \\out\cf6 , 10]);\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf6 	\
	\
	}