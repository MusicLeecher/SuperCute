{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica;\f1\fswiss\fcharset77 Helvetica-Bold;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red191\green0\blue0;\red96\green96\blue96;
\red0\green115\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs36 \cf0 Bundled Server Messages\
\

\fs22 Using Synth/Node/Group sclang objects to build classes often\
there is the need to construct bundles to send messages together.\
One example is you want to start a synth that should be mapped\
instantly to certain buses.\
\
This extension uses a list that is passed to all message methods\
which add their message to it and do all needed preparation on \
language side. \
\

\f1\b Note
\f0\b0 : you have to use this with care. Normally the other ways\
of creating Synths and Groups are more safe.\
\
aNode.
\f1\b msgToBundle
\f0\b0 (bundle, cmdName, argList) \
	adds a message to the bundle (a list)\
aNode.
\f1\b getMsg
\f0\b0 (cmdName or number, argList) \
	returns a message\
\

\f1\b instance creation and adding to a bundle ( usually a List )
\f0\b0 \
\
Synth.
\f1\b newToBundle
\f0\b0 (bundle, defName, argList, target, addAction)\
	returns a new synth and adds commands to the bundle\
	all initialisations and registring the node are done\
\
Group.
\f1\b newToBundle
\f0\b0 (bundle, target, addAction)\
	returns a new synth and adds commands to the bundle\
	all initialisations and registring the node are done\
\
\

\f1\b creating messages that can be added to a bundle\

\f0\b0 \
aSynth.
\f1\b newMsg
\f0\b0 (target, addAction, argList) \
	use this with a synth that was created by prNew(defName).\
	all initialisations and registring the node are done\
	\
aGroup.
\f1\b newMsg
\f0\b0 (target, addAction) \
	use this with a group that was created by prNew\
	all initialisations and registring the node are done\
\
aNode.
\f1\b moveBeforeMsg
\f0\b0 (aNode)\
	returns a message that causes the server to move this node before another one\
\
analogous messages: \

\f1\b moveAfterMsg / moveToHeadMsg / moveToTailMsg / \
moveNodeToHeadMsg / moveNodeToTailMsg
\f2\b0\fs18 \
\
\
//prepare some def\
s = \cf2 Server\cf0 .local;\
s.boot;
\f0\fs22 \

\f2\fs18 (\
SynthDef("void", \{ arg freq=800, out=0;\
	Out.ar(out, SinOsc.ar(SinOsc.ar(SinOsc.kr([2,1.1],0,8,12),freq*0.3,freq), 0, 0.2));\
\}).load(s);\
)
\f0\fs22 \
\

\f2\fs18 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 //create a list to add all messages\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 b = \cf2 List\cf0 .new; \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 //return an in instance of synth (registered) and adds the message to the list \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 y = Synth.newMsg(b, "void");\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 //add a couple of messages\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 b.add(y.getMsg(\cf4 "/n_set"\cf0 , [\cf5 \\freq\cf0 , 500]));\
b.add(y.getMsg(\cf4 "/n_set"\cf0 , [\cf5 \\out\cf0 , 0]));\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 //create a second list to add message\cf0 \
\
c = [y.getMsg("/n_free")];\
\
\cf3 //send the messages (do this only once.)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 (\
s.listSendBundle(1, b); \cf3 //start after one sec.\
\cf0 s.listSendBundle(1.1, c);\cf3 //runs for exactly 0.1 sec.\
\cf0 )\
\
\
}