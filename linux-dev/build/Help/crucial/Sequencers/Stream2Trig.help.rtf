{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red0\green112\blue0;\red191\green0\blue0;
}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 Stream2Trig			
\fs28 generate a trigger signal from a stream
\fs36 \

\f1\b0\fs24 \

\f0\b superclass: StreamKrDur\

\f1\b0 \

\f0\b Stream2Trig(levels,durations)\

\f1\b0 \
Take a pattern and use it as a stream of values for a trigger.  This plays the pattern in real time on the client, and sends messages to the server.
\f0\b  It is not very efficient. 
\f1\b0  Under SC2 this was very efficient, because it used ImpulseSequencer.  \
\

\f0\b levels
\f1\b0  - A stream of values for the level of each trigger \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 	1.0\
	\cf2 Prand\cf0 ([1,0],\cf2 inf\cf0 )\
	\{ 1.0.rand \}
\f1\fs24 \

\f2\fs18 	`[ 1,0,1,0,] // Ref converted into Pseq([1,0,1,0],inf)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 	\
	\
\

\f0\b duration
\f1\b0  - A stream of values for the duration in beats between each trigger. \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 	0.25\
	\cf2 Prand\cf0 ([0.25,0.5],\cf2 inf\cf0 )\
	\cf2 FuncStream\cf0 (\{ rrand(0.125,16.0) \})
\f1\fs24 \

\f2\fs18 	`[1.0,0.25,0.5] // Ref\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \
\
(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 Instr\cf0 (\\Stream2Trig, \{\cf2 arg\cf0  gate=0.0,freq=440,env;\
	p = \cf2 Pulse\cf0 .ar(freq,LFNoise1.kr(0.1).abs,0.5);\
	\cf2 Enveloper2\cf0 .ar(p,gate,env,2,2);\
\},[\
	\cf2 nil\cf0 ,\
	\cf2 nil\cf0 ,\
	[\cf3 \\envperc]\cf0 \
]);\
\
\cf2 Patch\cf0 .new(\\Stream2Trig,\
[\
	\cf2 Stream2Trig\cf0 (\
		\cf2 Pseq\cf0 ([\
			\cf2 Prand\cf0 ([1,1,1,1,1,0,0,0,0],2)],\cf2 inf\cf0 ),\
		\cf2 Pseq\cf0 ([0.25,0.25,0.25,0.125,0.125],\cf2 inf\cf0 )\
	),\
	400.0\
	//StreamKr(Pseq( Array.rand(16,30,50).midicps,inf ), 0.25 )\
]).gui\
\
)\
\
\
\
(\
\
\cf2 Patch\cf0 .new(\\Stream2Trig,\
[\
	\cf2 Stream2Trig\cf0 (\
		Pseq([\
			Pn(\cf2 Pshuf\cf0 ([1,0,1,0],4),3),\
			\cf2 Pshuf\cf0 ([0.2,0,0.2,0],4)],inf),\
		\cf2 Pseq\cf0 ([0.25,0.25,0.25,0.125,0.125],\cf2 inf\cf0 )\
	),\
	84\
]).topGui\
)\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
A nice sequel would be to make a class that also takes a gate duration stream\
(in beats), so that the gate will stay open for that long.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 //See [AsStream] for another way to skin the cat, using Spawn.\
}