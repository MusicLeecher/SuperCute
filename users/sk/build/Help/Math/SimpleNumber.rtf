{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue191;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 SimpleNumber
\f1\b0\fs24 \
\

\f0\b superclass: Number\

\f1\b0 \
Represents numbers which can be represented by a single one dimensional value.\
Most of the Unary and Binary operations are also implemented by UnaryOpUGen\
and BinaryOpUGen, so you can get more examples by looking at the help for those.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 \ul \ulc0 Unary Operations\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 \ulnone \

\f0\b neg
\f1\b0 \
\
negation\
\

\f0\b bitNot
\f1\b0 \
\
ones complement\
\

\f0\b abs
\f1\b0 \
\
absolute value.\
\

\f0\b ceil
\f1\b0 \
\
next larger integer.\
\

\f0\b floor
\f1\b0 \
\
next smaller integer\
\

\f0\b frac
\f1\b0 \
\
fractional part.\
\

\f0\b sign
\f1\b0 \
\
Answer -1 if negative, +1 if positive or 0 if zero.\
\

\f0\b squared
\f1\b0 \
\
The square of the number.\
\

\f0\b cubed
\f1\b0 \
\
The cube of the number.\
\

\f0\b sqrt
\f1\b0 \
\
The square root of the number.\
\

\f0\b exp
\f1\b0 \
\
e to the power of the receiver.\
\

\f0\b reciprocal
\f1\b0 \
\
1 / this\
\

\f0\b midicps
\f1\b0 \
\
Convert MIDI note to cycles per second\
\

\f0\b cpsmidi
\f1\b0 \
\
Convert cycles per second to MIDI note.\
\

\f0\b midiratio\

\f1\b0 \
Convert an interval in semitones to a ratio.\
\

\f0\b ratiomidi
\f1\b0 \
\
Convert a ratio to an interval in semitones.\
\

\f0\b ampdb
\f1\b0 \
\
Convert a linear amplitude to decibels.\
\

\f0\b dbamp
\f1\b0 \
\
Convert a decibels to a linear amplitude.\
\

\f0\b octcps
\f1\b0 \
\
Convert decimal octaves to cycles per second.\
\

\f0\b cpsoct
\f1\b0 \
\
Convert cycles per second to decimal octaves.\
\

\f0\b log
\f1\b0 \
\
Base e logarithm.\
\

\f0\b log2
\f1\b0 \
\
Base 2 logarithm.\
\

\f0\b log10
\f1\b0 \
\
Base 10 logarithm.\
\

\f0\b sin
\f1\b0 \
\
Sine.\
\

\f0\b cos
\f1\b0 \
\
Cosine.\
\

\f0\b tan
\f1\b0 \
\
Tangent.\
\

\f0\b asin
\f1\b0 \
\
Arcsine.\
\

\f0\b acos
\f1\b0 \
\
Arccosine.\
\

\f0\b atan
\f1\b0 \
\
Arctangent.\
\

\f0\b sinh
\f1\b0 \
\
Hyperbolic sine.\
\

\f0\b cosh
\f1\b0 \
\
Hyperbolic cosine.\
\

\f0\b tanh
\f1\b0 \
\
Hyperbolic tangent.\
\

\f0\b rand
\f1\b0 \
\
Random number from zero up to the receiver, exclusive.\
\

\f0\b rand2
\f1\b0 \
\
Random number from -this to +this.\
\

\f0\b linrand
\f1\b0 \
\
Linearly distributed random number from zero to this.\
\

\f0\b bilinrand
\f1\b0 \
\
Bilateral linearly distributed random number from -this to +this.\
\

\f0\b sum3rand
\f1\b0 \
\
A random number  from -this to +this that is the result of summing three uniform random generators\
to yield a bell-like distribution. This was suggested by Larry Polansky as a poor man's gaussian.\
\

\f0\b distort
\f1\b0 \
\
a nonlinear distortion function.\
\

\f0\b softclip
\f1\b0 \
\
Distortion with a perfectly linear region from -0.5 to +0.5\
\

\f0\b coin
\f1\b0 \
\
Answers a Boolean which is the result of a random test whose probability of success in a range from \
zero to one is \ul this\ulnone .\
\

\f0\b even
\f1\b0 \
\
Answer if the number is even.\
\

\f0\b odd
\f1\b0 \
\
Answer if the number is odd.\
\

\f0\b isPositive
\f1\b0 \
\
Answer if the number is >= 0.\
\

\f0\b isNegative
\f1\b0 \
\
Answer if the number is < 0.\
\

\f0\b isStrictlyPositive\

\f1\b0 \
Answer if the number is > 0.\

\f0\b \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs28 \cf0 \ul Binary Operations\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 \ulnone \

\f0\b + aNumber\

\f1\b0 \
Addition\
\

\f0\b - aNumber\
\

\f1\b0 Subtraction\
\

\f0\b * aNumber\
\

\f1\b0 Multiplication
\f0\b \

\f1\b0 \

\f0\b / aNumber\

\f1\b0 \
Division\
\

\f0\b % aNumber\

\f1\b0 \
Modulo\
\

\f0\b div(aNumber)\

\f1\b0 \
Integer Division\
\

\f0\b ** aNumber\

\f1\b0 \
Exponentiation\
\

\f0\b min(aNumber)\

\f1\b0 \
Minimum\
\

\f0\b max(aNumber)\

\f1\b0 \
Maximum\
\

\f0\b & aNumber\

\f1\b0 \
Bitwise And\
\

\f0\b | aNumber\

\f1\b0 \
Bitwise Or\
\

\f0\b bitXor(aNumber)\

\f1\b0 \
Bitwise Exclusive Or\
\

\f0\b lcm(aNumber)\

\f1\b0 \
Least common multiple\
\

\f0\b gcd(aNumber)\

\f1\b0 \
Greatest common divisor\
\

\f0\b round(aNumber)\

\f1\b0 \
Round to multiple of aNumber\
\

\f0\b trunc(aNumber)\

\f1\b0 \
Truncate to multiple of aNumber\
\

\f0\b atan2(aNumber)\

\f1\b0 \
Arctangent of (this/aNumber)\
\

\f0\b hypot(aNumber)\

\f1\b0 \
Square root of the sum of the squares.\
\

\f0\b << aNumber\

\f1\b0 \
Binary shift left.\
\

\f0\b >> aNumber\

\f1\b0 \
Binary shift right.\
\

\f0\b +>> aNumber\

\f1\b0 \
Unsigned binary shift right.\
\

\f0\b fill(aNumber)\

\f1\b0 \

\f0\b ring1(aNumber)\

\f1\b0 \
(a * b) + a\
\

\f0\b ring2(aNumber)\

\f1\b0 \
((a*b) + a + b)\
\

\f0\b ring3(aNumber)\

\f1\b0 \
(a*a *b)\
\

\f0\b ring4(aNumber)\

\f1\b0 \
((a*a *b) - (a*b*b))\
\

\f0\b difsqr(aNumber)\

\f1\b0 \
(a*a) - (b*b)\
\

\f0\b sumsqr(aNumber)\

\f1\b0 \
(a*a) + (b*b)\
\

\f0\b sqrdif(aNumber)\

\f1\b0 \
(a - b)**2\
\

\f0\b sqrsum(aNumber)\

\f1\b0 \
(a + b)**2\
\

\f0\b absdif(aNumber)\

\f1\b0 \
(a - b).abs\
\

\f0\b amclip(aNumber)\

\f1\b0 \
0  when  b <= 0,  a*b  when  b > 0\
\

\f0\b scaleneg(aNumber)\

\f1\b0 \
a*b when a < 0, otherwise a.\
\

\f0\b clip2(aNumber)\

\f1\b0 \
clips receiver to +/- aNumber\
\

\f0\b excess(aNumber)\
\

\f1\b0 Returns the difference of the receiver and its clipped form: (a - clip2(a,b)).\
\

\f0\b <! aNumber\

\f1\b0 \
Return the receiver. aNumber is ignored.\
\

\f0\b asFraction(denominator, fasterBetter)
\f1\b0 \
\
Return an array of denominator and divisor of the nearest and smallest fraction\
\

\f0\b rrand(aNumber)
\f1\b0 \
\
	Returns a random number in the interval [a, b). If both a and b are Integer then the result will be an Integer.\
\

\f0\b exprand(aNumber)
\f1\b0 \
\
	Returns an exponentially distributed random number in the interval [a, b). Always returns a Float.\
\
\

\f0\b degreeToKey(scale, stepsPerOctave)
\f1\b0 \
\
	the value is truncated to an integer and used as an index into an octave repeating table of note values.\
	Indices wrap around the table and shift octaves as they do\
	stepsPerOctave is 12 by default\
	\
	
\f2\fs18 (\
		l = [0, 1, 5, 9, 11]; \cf2 // pentatonic scale\cf0 \
		(1, 2..15).collect \{ \cf3 |i|\cf0  i.degreeToKey(l, 12) \}\
	)\

\f1\fs24 \
\

\f0\b keyToDegree(scale, stepsPerOctave)
\f1\b0 \
\
	inverse of degreeToKey.\
	stepsPerOctave is 12 by default\
	\
	
\f2\fs18 (\
		l = [0, 1, 5, 9, 11]; \cf2 // pentatonic scale\cf0 \
		(60, 61..75).collect \{ \cf3 |i|\cf0  i.keyToDegree(l, 12) \}\
	)\
	(\
		l = [0, 1, 5, 9, 11]; \cf2 // pentatonic scale\cf0 \
		(60, 61..75).postln.collect \{ \cf3 |i|\cf0  i.keyToDegree(l, 12).degreeToKey(l) \}\
	)\
	\

\f0\b\fs24 nearestInList(list)
\f1\b0 \
\
	returns the value in the collection closest to this\
	\
	
\f2\fs18 (\
		l = [0, 0.5, 0.9, 1];\
		(0, 0.05..1).collect \{ |i| i.nearestInList(l) \}\
	)\

\f1\fs24 \
\

\f0\b nearestInScale(scale, stepsPerOctave)
\f1\b0 \
\
	returns the value in the collection closest to this, assuming an octave repeating table of note values.\
	stepsPerOctave is 12 by default\
	\
	
\f2\fs18 (\
		l = [0, 1, 5, 9, 11]; \cf2 // pentatonic scale\cf0 \
		(60, 61..76).collect \{ |i| i.nearestInScale(l, 12) \}\
	)
\f1\fs24 \
	\

\f0\b asTimeString(precision)
\f1\b0 \
\
	returns a string corresponding to the hours:minutes:seconds based on the receiver as number of seconds\
	precision is 0.1 by default\
	\
	
\f2\fs18 (\
		var start;\
		start = Main.elapsedTime;\
		\{ loop(\{(Main.elapsedTime - start).asTimeString.postln; 0.05.wait\}) \}.fork;\
	)
\f1\fs24 \
}