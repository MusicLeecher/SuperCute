{\rtf1\mac\ansicpg10000\cocoartf824\cocoasubrtf330
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red96\green96\blue96;\red191\green0\blue0;
\red0\green115\blue0;\red191\green0\blue0;\red0\green0\blue0;\red0\green0\blue191;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 PV_Copy			copy an FFT buffer\

\f1\b0\fs24 \

\f0\b PV_Copy.ar(bufferA,  bufferB)\

\f1\b0 \
Copies the spectral frame in bufferA to bufferB at that point in the chain of PV UGens. This allows for parallel processing of spectral data without the need for multiple FFT UGens, and to copy out data at that point in the chain for other purposes. bufferA and bufferB must be the same size.\

\f0\b bufferA
\f1\b0  - source buffer.\

\f0\b bufferB
\f1\b0  - destination buffer.\
\
See also 
\f0\b [\ul FFT Overview\ulnone ]
\f1\b0 .\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 s.boot;\
(\
b = \cf2 Buffer\cf0 .alloc(s,2048,1);\
c = \cf2 Buffer\cf0 .alloc(s,2048,1);\
d = \cf2 Buffer\cf0 .read(s,\cf3 "sounds/a11wlk01.wav"\cf0 );\
e = \cf2 Buffer\cf0 .alloc(s,2048,1);\
f = \cf2 Buffer\cf0 .alloc(s,2048,1);\
)\
\
\cf4 //// proof of concept\cf0 \
(\
x = \{ \cf2 var\cf0  inA, chainA, inB, chainB, chain;\
	inA = \cf2 LFClipNoise\cf0 .ar(100);\
	chainA = \cf2 FFT\cf0 (b.bufnum, inA);\
	chainB = \cf2 PV_Copy\cf0 (chainA, c.bufnum);  \
	\cf2 IFFT\cf0 (chainA) - \cf2 IFFT\cf0 (chainB); \cf4 // cancels to zero so silent!\cf0 \
\}.play(s);\
)\
x.free;\
\cf4 // IFFTed frames contain the same windowed output data\cf0 \
b.plot(\cf5 \\b\cf0 , \cf2 Rect\cf0 (200, 430, 700, 300)); c.plot(\cf5 \\c\cf0 , \cf2 Rect\cf0 (200, 100, 700, 300));\
\
\
\cf6 //// crossfade between original and magmul-ed whitenoise\cf0 \
(\
x = \{ \cf2 var\cf0  in, in2, chain, chainB, chainC;\
	in = \cf2 PlayBuf\cf0 .ar(1, d.bufnum, \cf2 BufRateScale\cf0 .kr(d.bufnum), loop: 1);\
	in2 = \cf2 WhiteNoise\cf0 .ar;\
	chain = \cf2 FFT\cf0 (b.bufnum, in);\
	chainB = \cf2 FFT\cf0 (c.bufnum, in2);\
	chainC = \cf2 PV_Copy\cf0 (chain, e.bufnum);\
	chainB = \cf2 PV_MagMul\cf0 (chainB, chainC);\
	\cf2 XFade2\cf0 .ar(\cf2 IFFT\cf0 (chain), \cf2 IFFT\cf0 (chainB) * 0.1, \cf2 SinOsc\cf0 .kr(0.1, 1.5pi), 0.25);\
\}.play(s);\
)\
x.free;\
\
\cf7 \
\cf6 //// as previous but with Blip for 'vocoder' cross synthesis effect\cf0 \
(\
x = \{ \cf2 var\cf0  in, in2, chain, chainB, chainC;\
	in = \cf2 PlayBuf\cf0 .ar(1, d.bufnum, \cf2 BufRateScale\cf0 .kr(d.bufnum), loop: 1);\
	in2 = \cf2 Blip\cf0 .ar(100, 50);\
	chain = \cf2 FFT\cf0 (b.bufnum, in);\
	chainB = \cf2 FFT\cf0 (c.bufnum, in2);\
	chainC = \cf2 PV_Copy\cf0 (chain, e.bufnum);\
	chainB = \cf2 PV_MagMul\cf0 (chainB, chainC);\
	\cf2 XFade2\cf0 .ar(\cf2 IFFT\cf0 (chain), \cf2 IFFT\cf0 (chainB) * 0.1, \cf2 SinOsc\cf0 .ar(0.1), 0.25);\
\}.play(s);\
)\
x.free;\
\
\
\cf4 //// Spectral 'pan'\cf0 \
(\
x = \{ \cf2 var\cf0  in, chain, chainB, pan;\
	in = \cf2 PlayBuf\cf0 .ar(1, d.bufnum, \cf2 BufRateScale\cf0 .kr(d.bufnum), loop: 1);\
	chain = \cf2 FFT\cf0 (b.bufnum, in);\
	chainB = \cf2 PV_Copy\cf0 (chain, c.bufnum);\
	pan = \cf2 MouseX\cf0 .kr(0.001, 1.001, \cf5 'exponential'\cf0 ) - 0.001;\
	chain = \cf2 PV_BrickWall\cf0 (chain, pan); \
	chainB = \cf2 PV_BrickWall\cf0 (chainB, -1 + pan);  \
	0.5 * \cf2 IFFT\cf0 ([chain, chainB]);\
\}.play(s);\
)\
x.free;\
\
\
\cf4 //// Multiple Magnitude plots\cf0 \
(\
x = \{ \cf2 var\cf0  in, chain, chainB, chainC;\
	in = \cf2 WhiteNoise\cf0 .ar;\
	chain = \cf2 FFT\cf0 (b.bufnum, in);\
	\cf2 PV_Copy\cf0 (chain, c.bufnum); \cf4 // initial spectrum\cf0 \
	chain = \cf2 PV_RectComb\cf0 (chain, 20, 0, 0.2);\
	\cf2 PV_Copy\cf0 (chain, e.bufnum); \cf4 // after comb\cf0 \
	2.do(\{chain = \cf2 PV_MagSquared\cf0 (chain)\}); \
	\cf2 PV_Copy\cf0 (chain, f.bufnum); \cf4 // after magsquared\cf0 \
	0.00001 * Pan2.ar(\cf2 IFFT\cf0 (chain));\
\}.play(s);\
)\
x.free;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab160\ql\qnatural
\cf0 (\
c.getToFloatArray(action: \{ \cf2 arg\cf0  array;\
	\cf2 var\cf0  z, x;\
	z = array.clump(2).flop;\
	\cf4 // Initially data is in complex form\cf0 \
	z = [\cf2 Signal\cf0 .newFrom(z[0]), \cf2 Signal\cf0 .newFrom(z[1])];\
	x = \cf2 Complex\cf0 (z[0], z[1]);\
	\{x.magnitude.plot(\cf5 'Initial'\cf0 , \cf2 Rect\cf0 (200, 560, 700, 200))\}.defer\
\});\
e.getToFloatArray(action: \{ \cf2 arg\cf0  array;\
	\cf2 var\cf0  z, x;\
	z = array.clump(2).flop;\
	\cf4 // RectComb doesn't convert, so it's still complex\cf0 \
	z = [\cf2 Signal\cf0 .newFrom(z[0]), \cf2 Signal\cf0 .newFrom(z[1])];\
	x = \cf2 Complex\cf0 (z[0], z[1]);\
	\{x.magnitude.plot(\cf5 'After RectComb'\cf0 , \cf2 Rect\cf0 (200, 330, 700, 200))\}.defer\
\});\
f.getToFloatArray(action: \{ \cf2 arg\cf0  array;\
	\cf2 var\cf0  z, x;\
	z = array.clump(2).flop;\
	\cf4 // MagSquared converts to Polar\cf0 \
	x = \cf2 Signal\cf0 .newFrom(z[0]); \cf4 // magnitude first\cf0 \
	\{x.plot(\cf5 'After MagSquared'\cf0 , \cf2 Rect\cf0 (200, 100, 700, 200))\}.defer\
\})\
)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
\cf7 [b, c, d, e, f].do(\cf8 _\cf7 .free); \cf6 // free the buffers}