{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red96\green96\blue96;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 AppClock
\f1\b0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 superclass: Clock
\f1\b0\fs36 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs24 \cf0 \
SystemClock is more accurate, but cannot call Cocoa primitives.\
AppClock is less accurate (uses NSTimers) but can call Cocoa primitives.\
\
You will need to use the SystemClock to get accurate/musical scheduling.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \
\
\

\f0\b\fs24 *sched(delta,task)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 	the float you return specifies the delta to resched the function for\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 		AppClock\cf0 .sched(0.0,\{ arg time; \
				\cf3 ["AppClock has been playing for ",time]\cf0 .postln; \
				rrand(0.1,0.9) \
		\});\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 	returning \cf2 nil\cf0  will stop the task from being rescheduled\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 		AppClock\cf0 .sched(2.0,\{ \
			\cf3 "2.0 seconds later"\cf0 .postln; \
			\cf2 nil\cf0  \
		\});\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 *clear\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 	clear the AppClock's scheduler to stop it\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf2 \
		AppClock\cf0 .clear\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 *play(task)\
	
\f1\b0 The task/Routine yields a float value indicating the delta (secs) for the AppClock to wait\
	until resuming the Routine.
\f2\fs18 \
\
		(\
		\cf2 var\cf0  w, r;\
		w = \cf2 SCWindow\cf0 (\cf3 "trem"\cf0 , \cf2 Rect\cf0 (512, 256, 360, 130));\
		w.front;\
		r = \cf2 Routine\cf0 (\{ arg appClockTime;\
				["AppClock has been playing for secs:",appClockTime].postln;\
				60.do(\{ \cf2 arg\cf0  i;\
					0.05.yield;\
					w.bounds = w.bounds.moveBy(10.rand2, 10.rand2);\
					w.alpha = cos(i*0.1pi)*0.5+0.5;\
				\});\
				1.yield;\
				w.close;\
		\});\
		\cf2 AppClock\cf0 .play(r);\
		)\
	\

\f0\b\fs24 *tick\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 	AppClock.tick is called periodically by the SuperCollider application itself.\
	This updates the Scheduler and causes any scheduled tasks to be executed.  You\
	should never call this method yourself.\
\
\
}