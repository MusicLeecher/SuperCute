{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue191;\red0\green115\blue0;
}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 TempoClock					
\fs28 tempo based scheduler
\fs24 \
\
\

\f1\b0 TempoClock is a scheduler like SystemClock, but it schedules relative to a tempo in beats per second.\
\

\f0\b *new(tempo, beats, seconds)\

\f1\b0 	Create a new TempoClock scheduler with the given tempo and starting times.\
	\
If not given, 
\f0\b tempo
\f1\b0  defaults to one, 
\f0\b beats
\f1\b0  defaults to zero and 
\f0\b seconds
\f1\b0  defaults to the current elapsed time.\
\

\f0\b stop
\f1\b0 \
	destroy the scheduler. releases the OS thread running the scheduler.\
\
	\

\f0\b tempo
\f1\b0 \
	get the current tempo in beats per second.\
	\

\f0\b tempo_(beatsPerSecond)\

\f1\b0 	set the current tempo.\
	t.tempo = 2.0;\
	or\
	t.tempo_(2.0);\

\f0\b \
beatDur
\f1\b0 \
	get the current beat duration in seconds.\
	\

\f0\b \
elapsedBeats\

\f1\b0 	get the current elapsed time in beats.\
	This is equivalent to:   tempoClock.secs2beats(Main.elapsedTime).\
	It is often preferrable to use 
\f0\b beats
\f1\b0  instead of 
\f0\b elapsedBeats 
\f1\b0 because 
\f0\b beats
\f1\b0  uses a thread's logical time.\
\

\f0\b beats
\f1\b0 \
	Returns the appropriate beat time of the clock from any thread. If the receiver is the clock of the current thread, this returns the current logical time: thisThread.beats. If the receiver is not the current thread's clock then this translates the current thread's logical time in seconds to this clock's logical time in beats. \
	\

\f0\b schedAbs(beat,function)\

\f1\b0 	Schedule a function to be evaluated at a particular beat.\
\

\f0\b sched(delta,function)\

\f1\b0 	Schedule a function to be evaluated delta beats from the current logical time in this clock. If the receiver is the clock of the current thread, the delta is applied to the current logical time. If the receiver is not the current thread's clock then the delta is applied to the clock's elapsed time.\
\

\f0\b clear
\f1\b0 \
	remove all tasks from the scheduling queue.\
\

\f0\b permanent_(bool)
\f1\b0 \
	if false (default) the clock is stopped (and thus removed) on cmd-period. \
	If set to true it persists, just like TempoClock.default does.\
\
\

\f0\b beats2secs(beats)\

\f1\b0 	convert absolute beats to absolute seconds. Only works for times in the current tempo. If the tempo changes any computed time in future will be wrong.\

\f0\b 	\
secs2beats(seconds)\

\f1\b0 	convert absolute seconds to absolute beats. Only works for times in the current tempo. If the tempo changes any computed time in future will be wrong.\

\f0\b \
\
Example:\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs18 \cf2 ////////////////////////\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
t = \cf3 TempoClock\cf0 (1); \cf2 // create a TempoClock\cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // schedule an event at next whole beat\cf0 \
t.schedAbs(t.beats.ceil, \{ \cf3 arg\cf0  beat, sec; [beat, sec].postln; 1 \});\
\
t.tempo = 2;\
t.tempo = 4;\
t.tempo = 0.5;\
t.tempo = 1;\
\
t.clear;\
\
t.schedAbs(t.beats.ceil, \{ \cf3 arg\cf0  beat, sec; [beat, sec].postln; 1 \});\
\
t.stop;\
\
\cf2 ////////////////////////\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 (\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // get elapsed time, round up to next second\cf0 \
v = \cf3 Main\cf0 .elapsedTime.ceil;\
\
\cf2 // create two clocks in a 5:2 relation, starting at time v. \cf0 \
t = \cf3 TempoClock\cf0 (1, 0, v);\
u = \cf3 TempoClock\cf0 (0.4, 0, v);\
\
\cf2 // start two functions at beat zero in each clock.\cf0 \
t.schedAbs(0, \{ \cf3 arg\cf0  beat, sec; [\cf4 \\t\cf0 , beat, sec].postln; 1 \});\
u.schedAbs(0, \{ \cf3 arg\cf0  beat, sec; [\cf4 \\u\cf0 , beat, sec].postln; 1 \});\
)\
\
\
(\
u.tempo = u.tempo * 3;\
t.tempo = t.tempo * 3;\
)\
\
(\
u.tempo = u.tempo * 1/4;\
t.tempo = t.tempo * 1/4;\
)\
\
\
(\
t.stop;\
u.stop;\
)\
\
\cf2 ////////////////////////\cf0 \
\
(\
\cf2 // get elapsed time, round up to next second\cf0 \
v = \cf3 Main\cf0 .elapsedTime.ceil;\
\
\cf2 // create two clocks, starting at time v. \cf0 \
t = \cf3 TempoClock\cf0 (1, 0, v);\
u = \cf3 TempoClock\cf0 (1, 0, v);\
\
\cf2 // start two functions at beat zero in each clock.\cf0 \
\cf2 // t controls u's tempo. They should stay in sync.\cf0 \
t.schedAbs(0, \{ \cf3 arg\cf0  beat, sec; u.tempo = t.tempo * [1,2,3,4,5].choose; [\cf4 \\t\cf0 , beat, sec].postln; 1 \});\
u.schedAbs(0, \{ \cf3 arg\cf0  beat, sec; [\cf4 \\u\cf0 , beat, sec].postln; 1 \});\
)\
\
\
(\
u.tempo = u.tempo * 3;\
t.tempo = t.tempo * 3;\
)\
\
(\
u.tempo = u.tempo * 1/4;\
t.tempo = t.tempo * 1/4;\
)\
\
\
(\
t.stop;\
u.stop;\
)\
}