{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue191;\red96\green96\blue96;
\red0\green115\blue0;\red0\green0\blue0;\red0\green0\blue191;\red96\green96\blue96;\red191\green0\blue0;
\red0\green115\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs38 \cf0 Bundled Server Messages
\f1\b0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs24 \cf0 When using the 
\f0\b Synth
\f1\b0 /
\f0\b Node
\f1\b0 /
\f0\b Group
\f1\b0  sclang objects there is often a need to construct bundles to send messages together. For example when you want to start a synth that should be mapped instantly to certain buses, or need to ensure that two synths start with precise synchronisation.\
\
The simplest way to deal with this is through Server's automated bundling support. This allows you to open a bundle into which all osc messages will be collected until it is sent. See 
\f0\b Server
\f1\b0  for details of makeBundle's arguments.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 	s.boot;\
	(\
	\cf2 // send a synth def to server\cf0 \
	\cf3 SynthDef\cf0 (\cf4 "tpulse"\cf0 , \{ \cf3 arg\cf0  out=0,freq=700,sawFreq=440.0;\
		\cf3 Out\cf0 .ar(out, \cf3 SyncSaw\cf0 .ar(freq,  sawFreq,0.1) )\
	\}).send(s);\
	)\
	\
	\cf2 // all OSC commands generated in the function contained below will be added to a bundle\cf0 \
	\cf2 // and executed simultaneously after 2 seconds.\cf0 \
	(\
	s.makeBundle(2.0, \{\
		x = \cf3 Synth\cf0 .new(\cf4 "tpulse"\cf0 );\
		a = \cf3 Bus\cf0 .control.set(440);\
		x.busMap(\cf5 \\freq\cf0 , a);\
	\});\
	)\
	x.free;\
	\
	\cf2 // don't send\cf0 \
	(\
	 b = s.makeBundle(\cf3 false\cf0 , \{ 	\
		x = \{ \cf3 PinkNoise\cf0 .ar(0.1) * \cf3 In\cf0 .kr(0, 1); \}.play;\
	\});\
	)\
	\cf2 // now pass b as a pre-existing bundle, and start both synths synchronously\cf0 \
	(\
	s.makeBundle(\cf3 nil\cf0 , \{ \cf2 // nil executes ASAP\cf0 \
		y = \{ \cf3 SinOsc\cf0 .kr(0.2).abs \}.play(x, 0, 0, \cf5 \\addBefore\cf0 ); \cf2 // sine envelope\cf0 \
	\}, b);\
	)\
	x.free; y.free;\
\
	
\f1\fs24 \
In addition to this there are a number of methods which return OSC messages which can be added to a bundle. These are detailed in the helpfiles for 
\f0\b Node
\f1\b0 , 
\f0\b Synth
\f1\b0 , and 
\f0\b Group
\f1\b0 .\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural
\cf6 	
\f2\fs18 s.boot;\
	b = \cf7 List\cf6 .new;\
	c = \cf7 Bus\cf6 .control(s, 1).set(660);\
	x = \cf7 Synth\cf6 .basicNew(\cf8 "default"\cf6 , s); \cf9 // Create without sending\cf6 \
	b.add(x.newMsg);\
	b.add(x.busMapMsg(\cf10 \\freq\cf6 , c));\
	b.postln; \cf9 // here's what it looks like\cf6 \
	s.listSendBundle(1.0, b); \cf9 // Execute after 1 second\cf6 \
	c.set(440);\
	s.queryAllNodes;\
	x.free;
\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs20 \cf0 \
\
\
}