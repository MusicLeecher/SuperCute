{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fswiss\fcharset77 Helvetica-Oblique;
\f3\fnil\fcharset77 Monaco;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red96\green96\blue96;\red191\green0\blue0;
\red0\green115\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 Node					
\fs24 abstract superclass of Synth and Group\

\f1\b0 \

\f0\b superclass: Object
\f1\b0 \
\
See 
\f0\b Server-Architecture 
\f1\b0 for the definition of a node.\
\
This class is the abstract super class of 
\f0\b Synth
\f1\b0  and 
\f0\b Group
\f1\b0 , which represent synth and group nodes on the server.  Node objects are not made explicitly, but Synth and Group are subclasses, and inherit the methods  documented below.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ri-620\ql\qnatural

\f0\b\fs28 \cf0 \ul \ulc0 Freed Nodes and Node Status
\f1\b0\fs24 \ulnone \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
Nodes which you explicitly free using the methods free or release will have their group instance variable set to nil. However Nodes which are automatically freed after a certain time (for instance by an 
\f0\b EnvGen
\f1\b0  with a doneAction of 2) will not. This keeps the implementation of the classes simple and lightweight. To have the current state of a Node tracked you can register it with an instance of 
\f0\b NodeWatcher
\f1\b0 . This will enable two variables, isPlaying and isRunning, which you can use for checking purposes.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ri-620\ql\qnatural

\f0\b\fs28 \cf0 \ul Bundling
\f1\b0\fs24 \ulnone \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
Many of the methods below have two versions: a regular one which sends its corresponding message to the server immediately, and one which returns the message in an Array so that it can be added to a bundle. It is also possible to capture the messages generated by the regular methods using Server's automated bundling capabilities. See 
\f0\b Server
\f1\b0  and 
\f0\b bundledCommands
\f1\b0  for more details.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ri-620\ql\qnatural

\f0\b\fs28 \cf0 \ul \
Accessing Instance Variables\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural

\fs24 \cf0 \ulnone \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 The following getter methods also have corresponding setters, but they should be used with extreme care and only if you are 
\f2\i sure
\f1\i0  you know what you're doing.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural

\f0\b \cf0 \
	nodeID 
\f1\b0 - Returns the Node's node ID number.\
	\
	
\f0\b group 
\f1\b0  - Returns an instance of 
\f0\b Group
\f1\b0  or 
\f0\b RootNode
\f1\b0  corresponding to this Node's group on the server.\
	\
	
\f0\b server
\f1\b0  - Returns an instance of 
\f0\b Server
\f1\b0  corresponding to this Node's server app.\
	\
	
\f0\b isPlaying 
\f1\b0 - Returns a boolean indicating if this node is currently on the server, providing this Node has been registered with a 
\f0\b NodeWatcher
\f1\b0 . 
\f0\b N.B. 
\f1\b0 If this Node has not been registered this will likely be false in any case.
\f0\b \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural

\fs28 \cf0 \ul \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural

\fs24 \cf0 \ulnone 	isRunning 
\f1\b0 - Returns a boolean indicating if this node is currently on the server, providing this Node has been registered with a 
\f0\b NodeWatcher
\f1\b0 . 
\f0\b N.B. 
\f1\b0 If this Node has not been registered this will likely be false in any case.
\f0\b \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs28 \cf0 \ul \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ri-620\ql\qnatural
\cf0 \ul Node Commands\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural

\f1\b0\fs24 \cf0 \ulnone \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 See the Node Commands section in 
\f0\b Server-Command-Reference 
\f1\b0 for the OSC equivalents of the methods outlined below
\f0\b .\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural
\cf0 	free(sendFlag) \
	freeMsg
\f1\b0  \
		\
		Stop this Node and free it from it's parent group on the server.
\f0\b  
\f1\b0 Once a Node has been freed, you cannot restart it. 
\f0\b sendFlag
\f1\b0  is a boolean indicating whether the free message should be sent. If false an 
\f0\b n_free
\f1\b0  message will not be sent to this Node's server, but its isPlaying and isRunning variables will be set to false. The default for 
\f0\b sendFlag
\f1\b0  is true. If this Node is a 
\f0\b Group
\f1\b0  this will free all Nodes within the Group.\
		\
		
\f3\fs18 s.boot;\
		x = \cf2 Synth\cf0 (\cf3 "default"\cf0 );\
		x.free;
\f1\fs24 \
		\
	
\f0\b run(boolean)\
	runMsg(boolean)\
	
\f1\b0 	\
		Set the running state of this Node according to a boolean. False will pause the node without freeing it. The default is true. If this Node is a 
\f0\b Group
\f1\b0  this will set the running state of all Nodes within the Group.\
		\
		
\f3\fs18 s.boot;
\f1\fs24 \
		
\f3\fs18 (\
		x = \cf2 SynthDef\cf0 (\cf3 "help-node-set"\cf0 , \{\cf2 arg\cf0  freq = 440, out = 0; \
			\cf2 Out\cf0 .ar(out, \cf2 SinOsc\cf0 .ar(freq, 0, 0.1));\}).play(s);\
		)\
		x.run(\cf2 false\cf0 );\
		x.run; \cf4 // default is true\cf0 \
		x.free;
\f1\fs24 \
	\
	
\f0\b set(controlName, value ... moreArgs)\
	setMsg(controlName, value ... moreArgs)\
	
\f1\b0 	\
		Set controls in this Node to values. Controls are defined in a 
\f0\b SynthDef 
\f1\b0 as args or instances of 
\f0\b Control
\f1\b0 . They are specified here using symbols, strings, or indices, and are listed in pairs with values. If this Node is a 
\f0\b Group
\f1\b0  this will set all Nodes within the Group.\
			\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural

\f3\fs18 \cf0 		s.boot;\
		(\
		x = \cf2 SynthDef\cf0 (\cf3 "help-node-set"\cf0 , \{\cf2 arg\cf0  freq = 440, out = 0; \
			\cf2 Out\cf0 .ar(out, \cf2 SinOsc\cf0 .ar(freq, 0, 0.1));\}).play(s);\
		)\
		x.set(\cf5 \\freq\cf0 , 880, \cf5 \\out\cf0 , 1); \cf4 // two pairs\cf0 \
		x.set(0, 660, 1, 0); \cf4 // freq is the first argument, so it's index is 0. out is index 1.\cf0 \
		x.free;
\f1\fs24 \
		\
	
\f0\b setn(controlName, values ... moreArgs)\
	setnMsg(controlName, values ... moreArgs)\
	\
	
\f1\b0 	Set sequential ranges of controls in this Node to values. Controls are defined in a 
\f0\b SynthDef 
\f1\b0 as args or instances of 
\f0\b Control
\f1\b0 . They are specified here using symbols, strings, or indices, and are listed in pairs with arrays of values. If this Node is a 
\f0\b Group
\f1\b0  this will setn all Nodes within the Group.\
		\
		
\f3\fs18 s.boot;\
		(\
		x = \cf2 SynthDef\cf0 (\cf3 "help-node-setn"\cf0 , \{\
			\cf2 arg\cf0  freq1 = 440, freq2 = 440, freq3 = 440, amp1 = 0.05, amp2 = 0.05, amp3 = 0.05; \
			\cf2 Out\cf0 .ar(0, \cf2 Mix\cf0 (\cf2 SinOsc\cf0 .ar([freq1, freq2, freq3], 0, [amp1, amp2, amp3])));\}).play(s);\
		)\
		\cf4 // set 3 controls starting from \\freq1, and 3 controls starting from \\amp1\cf0 \
		x.setn(\cf5 \\freq1\cf0 , [440, 880, 441], \cf5 \\amp1\cf0 , [0.3, 0.1, 0.3]);\
		x.free;
\f1\fs24 \
	
\f0\b \
	fill(controlName, numControls, value ... moreArgs)\
	fillMsg(controlName, numControls, value ... moreArgs)
\f1\b0 \
		\
		Set sequential ranges of controls in this Node to a single value. Controls are defined in a 
\f0\b SynthDef 
\f1\b0 as args or instances of 
\f0\b Control
\f1\b0 . They are specified here using symbols, strings, or indices, and are listed in groups of three along with an integer indicating the number of controls to set, and the value to set them to. If this Node is a 
\f0\b Group
\f1\b0  this will fill all Nodes within the Group.\
		\
	
\f0\b busMap(firstControl, aBus ... moreArgs)\
	busMapMsg(firstControl, aBus ... moreArgs)\
		\
		
\f1\b0 Map sequential ranges of controls in this Node to read from control rate Buses. Controls are defined in a 
\f0\b SynthDef 
\f1\b0 as args or instances of 
\f0\b Control
\f1\b0 . They are specified here using symbols, strings, or indices, and are listed in pairs with Bus objects. The number of sequential controls mapped corresponds to the Bus' number of channels. If this Node is a 
\f0\b Group
\f1\b0  this will busMap all Nodes within the Group.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural
\cf0 		\
		
\f3\fs18 s.boot;\
		(\
		b = \cf2 Bus\cf0 .control(s, 2); b.set(440, 660);	\cf4 // a two channel bus\cf0 \
		c = \cf2 Bus\cf0 .control(s, 1);	c.set(441);		\cf4 // a one channel bus\cf0 \
		x = SynthDef("help-Node-busMap", \{ \cf2 arg\cf0  freq1 = 440, freq2 = 440, freq3 = 440; \
			Out.ar(0, \cf2 Mix\cf0 (\cf2 SinOsc\cf0 .ar([freq1, freq2, freq3], 0, 0.1)));\
		\}).play(s);)\
		\
		\cf4 // b has two channels, so both freq2 and freq3 are mapped to its first and second channels \cf0 \
		\cf4 // respectively; c has one channel, so it maps only freq1\cf0 \
		x.busMap(\cf5 \\freq1\cf0 , c, \cf5 \\freq2\cf0 , b); \
		b.set(440, 880);\
		c.set(1200);\
		x.free; b.free; c.free;
\f0\b\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural
\cf0 	
\f1\b0 \
	
\f0\b map(controlName, index ... moreArgs)\
	mapMsg(controlName, index ... moreArgs)
\f1\b0 \
		\
		Map controls in this Node to read from control rate Buses. Controls are defined in a 
\f0\b SynthDef 
\f1\b0 as args or instances of 
\f0\b Control
\f1\b0 . They are specified here using symbols, strings, or indices, and are listed in pairs with bus indices. If this Node is a 
\f0\b Group
\f1\b0  this will map all Nodes within the Group.\
		\
		
\f3\fs18 s.boot;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural
\cf0 		(\
		b = \cf2 Bus\cf0 .control(s, 1); b.set(880);\
		c = \cf2 Bus\cf0 .control(s, 1);	c.set(884);\
		x = \cf2 SynthDef\cf0 (\cf3 "help-Node-busMap"\cf0 , \{ \cf2 arg\cf0  freq1 = 440, freq2 = 440; \
			\cf2 Out\cf0 .ar(0, \cf2 SinOsc\cf0 .ar([freq1, freq2], 0, 0.1));\
		\}).play(s);)\
		x.map(\cf5 \\freq1\cf0 , b.index, \cf5 \\freq2\cf0 , c.index);\
		x.free; b.free; c.free;
\f1\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural
\cf0 		\
	
\f0\b mapn(controlName, index, numControls ... moreArgs)\
	mapnMsg(controlName, index, numControls ... moreArgs)
\f1\b0 \
		\
		Map sequential ranges of controls in this Node to read from control rate Buses. This is similar to busMap above, but instead of passing in 
\f0\b Bus
\f1\b0  objects you specify the index, and the number of sequential Controls to map. If this Node is a 
\f0\b Group
\f1\b0  this will mapn all Nodes within the Group.\
			\
	
\f0\b release(releaseTime)\
	releaseMsg(releaseTime)\
	
\f1\b0 \
	
\f0\b\fs28 \ul 	
\f1\b0\fs24 \ulnone This is a convenience method which assumes that the synth contains an envelope generator (an 
\f0\b EnvGen
\f1\b0 , 
\f0\b Linen
\f1\b0 , or similar 
\f0\b UGen
\f1\b0 ) running a sustaining envelope (see 
\f0\b Env
\f1\b0 ) and that it's gate argument is set to a control called 
\f3\fs18 \cf5 \\gate
\f1\fs24 \cf0 . This method will cause the envelope to release. If 
\f0\b releaseTime 
\f1\b0 is not nil, it will override the envelope's decay or release time. If this Node is a 
\f0\b Group
\f1\b0  this will release all Nodes within the Group.\
		\
		
\f3\fs18 x = \{ \cf2 arg\cf0  gate=1; \cf2 BrownNoise\cf0 .ar(0.5) * \cf2 EnvGen\cf0 .kr(\cf2 Env\cf0 .cutoff(1), gate, doneAction:2) \}.play;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 		x.release(5); \cf4 // overide the Env's specified 1 second release time
\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural
\cf0 	\
	
\f0\b query\
	\
		
\f1\b0 Sends an 
\f0\b n_query
\f1\b0  message to the server, which will reply with a message containing information about this node and its place in the server's node tree. This information will be printed to the post window. (See also the queryAllNodes method of 
\f0\b Server
\f1\b0 .) "parent" indicates the Node's enclosing group. If "prev" or "next" are equal to -1 that indicates that there are no other nodes in the enclosing group before or after this one, respectively.\
		\
		
\f3\fs18 g = \cf2 Group\cf0 .new;\
		x = \cf2 Synth\cf0 .head(g, \cf3 "default"\cf0 );\
		x.query;\
		g.query;\
		s.queryAllNodes; \cf4 // Note the RootNode (ID 0) and the default Group (ID 1)\cf0 \
		x.free; g.free;\
		\
	
\f0\b\fs24 trace\
	\
		
\f1\b0 Causes a synth to print out the values of the inputs and outputs of its unit generators for one control period to the post window. Causes a group to print the node IDs and names of each node in the group for one control period.\
		\
		
\f3\fs18 g = \cf2 Group\cf0 .new;\
		x = \cf2 Synth\cf0 .head(g, \cf3 "default"\cf0 );\
		x.trace;\
		g.trace;\
		x.free; g.free;
\f1\fs24 \
	
\f0\b\fs28 \ul \
Changing the order of execution\

\fs24 \ulnone \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 The following methods can be used to change the Node's place in the order of execution. See the 
\f0\b Order-of-execution
\f1\b0  help file for more information on this important topic. See 
\f0\b Server-Command-Reference
\f1\b0  for the OSC equivalents of these methods.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural

\f0\b \cf0 \
	moveAfter(aNode)\
	moveAfterMsg(aNode)\
	\
		
\f1\b0 Move this Node to be directly after aNode. 
\f0\b N.B. n_after
\f1\b0 , the OSC message which this method encapsulates, allows already freed nodes as targets. This is so that one may attempt a series of moves, with the last successful one taking effect. For this reason this method will fail silently if either the target or this node have already been freed. If you will need to check, you may register the relevant nodes with a 
\f0\b NodeWatcher
\f1\b0 .
\f0\b \
	\
	moveBefore(aNode)\
	moveBeforeMsg(aNode)\
	\
		
\f1\b0 Move this Node to be directly before aNode. 
\f0\b N.B. n_before
\f1\b0 , the OSC message which this method encapsulates, allows already freed nodes as targets. This is so that one may attempt a series of moves, with the last successful one taking effect. For this reason this method will fail silently if either the target or this node have already been freed. If you will need to check, you may register the relevant nodes with a 
\f0\b NodeWatcher
\f1\b0 .
\f0\b \
	\
	moveToHead(aGroup)\
	moveToHeadMsg(aGroup)\

\f1\b0 		\
		If 
\f0\b aGroup
\f1\b0  is a 
\f0\b Group
\f1\b0  then this method will move this Node to the head of that Group. If it is nil this will move this Node to the head of the 
\f0\b default_group
\f1\b0  of this Node's 
\f0\b Server
\f1\b0 .\
\

\f0\b 	moveToTail(aGroup)\
	moveToTailMsg(aGroup)\
	\

\f1\b0 		If 
\f0\b aGroup
\f1\b0  is a 
\f0\b Group
\f1\b0  then this method will move this Node to the tail of that Group. If it is nil this will move this Node to the tail of the 
\f0\b default_group
\f1\b0  of this Node's 
\f0\b Server
\f1\b0 .\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural

\f0\b\fs28 \cf0 \ul Other Methods
\f3\b0\fs18 \ulnone \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural

\f1\fs24 \cf0 \
	
\f0\b asTarget
\f1\b0  - Returns this Node. See the 
\f0\b asTarget
\f1\b0  help file for more details.\
	\
	
\f0\b printOn(stream)
\f1\b0  - Prints this Node's Class (Synth or Group) and nodeID on 
\f0\b stream
\f1\b0 .\
	\
	
\f0\b hash
\f1\b0  - Returns server.hash bitXor: nodeID.hash\
	\
	
\f0\b == aNode 
\f1\b0 - Returns true if this Node and aNode have the same nodeID and the same Server object, otherwise returns false. Under certain circumstances this Node and aNode might not be the same object, even though this returns true.\
	\
		
\f3\fs18 g = \cf2 Group\cf0 .basicNew(s, 1); \cf4 // the default group of s\cf0 \
		h = \cf2 Group\cf0 .basicNew(s, 1); \cf4 // and again\cf0 \
		g == h; 	\cf4 // true\cf0 \
		g === h;	\cf4 // false
\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural

\f3\fs18 \cf0 \
}