{\rtf1\mac\ansicpg10000\cocoartf824\cocoasubrtf330
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
\f3\fmodern\fcharset77 Courier;\f4\fmodern\fcharset77 Courier-Oblique;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red191\green0\blue0;\red0\green115\blue0;
}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 List Comprehensions
\f1\b0 \cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 List comprehensions are a syntactic feature of functional programming languages like Miranda, Haskell, and Erlang which were later copied into Python.\
You can search the web for "list comprehensions" or "generator expressions" to learn more. \
Basically list comprehensions are for getting a series of solutions to a problem.\
\
in SC these are just a syntax macro for a longer expression.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs20 \cf0 \
\cf3 // read this as "all [x,y] for x in 1..5, y in 1..x, such that x+y is prime.\cf0 \
all \{:[x,y], x <- (1..5), y <- (1..x), (x+y).isPrime \}\
\
[ [ 1, 1 ], [ 2, 1 ], [ 3, 2 ], [ 4, 1 ], [ 4, 3 ], [ 5, 2 ] ]\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 the list comprehension above is equivalent to the following code:\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs20 \cf0 \
all(\cf2 Routine\cf0 .new(\{ (1..5).do \{\cf2 |x|\cf0  (1..x).do \{\cf2 |y|\cf0  if ((x+y).isPrime) \{[x,y].yield\} \}\}\}));\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 ..but much more concise and much easier to keep in your head than writing it out.\
\
In the list comprehension compiler, simple series like (1..5) and (1..x) are treated as special cases and implemented as loops rather than making a collection.\
\
A list comprehension in SC is really a Routine. You can use the 'all' message to collect all of the Routine's results into a list.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 A few examples\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs20 \cf0 \
all \{: x/(x+1), x <- (1..5) \}\
\
[ 0.5, 0.66666666666667, 0.75, 0.8, 0.83333333333333 ]\
\
all \{:[x,y], x <- (1..3), y <- [\cf4 \\a\cf0 ,\cf4 \\b\cf0 ,\cf4 \\c\cf0 ] \}\
\
[ [ 1, a ], [ 1, b ], [ 1, c ], [ 2, a ], [ 2, b ], [ 2, c ], [ 3, a ], [ 3, b ], [ 3, c ] ]\
\
all \{:[x,y], x <- (0..3), y <- (x..0) \}\
\
[ [ 0, 0 ], [ 1, 1 ], [ 1, 0 ], [ 2, 2 ], [ 2, 1 ], [ 2, 0 ], [ 3, 3 ], [ 3, 2 ], [ 3, 1 ], [ 3, 0 ] ]\
\
all \{:y, x <- (1..4), y <- (x..1) \}\
\
[ 1, 2, 1, 3, 2, 1, 4, 3, 2, 1 ]\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural
\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 var\cf0  intervals;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 // a function to generate intervals between all pairs of notes in a chord voicing\cf0 \
intervals = \{\cf2 |chord|\cf0 \
	all \{: chord[i+gap] - chord[i], \
		gap <- (1 .. chord.lastIndex), \
		i <- (0 .. chord.lastIndex - gap) \
	\}\
\};\
\
intervals.([0,4,7,10]).postln;\
intervals.([0,1,3,7]).postln;\
)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs20 \cf0 [ 4, 3, 3, 7, 6, 10 ]\
[ 1, 2, 4, 3, 6, 7 ]\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural
\cf0 all \{:[y, z], x<-(0..30), \cf2 var\cf0  y = x.nthPrime, \cf2 var\cf0  z = 2 ** y - 1, z.asInteger.isPrime.not  \}\
[ [ 11, 2047 ], [ 23, 8388607 ], [ 29, 536870911 ] ] \cf3 // mersenne numbers which are no primes\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 Qualifier Clauses\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 \
A list comprehension begins with 
\f2\fs20 \{: 
\f1\fs24 and contains a body followed by several qualifier clauses separated by commas.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs26 \cf0 \{: 
\f4\i body
\f3\i0  , 
\f4\i qualifiers
\f3\i0  \}\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
There are several types of qualifier clauses that can appear after the body.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 generator clause\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 \
The basic clause is the generator clause. Its syntax is \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f4\i\fs26 \cf0 name
\f3\i0  <- 
\f4\i expr
\f3\i0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
The expression should be something that can respond meaningfully to 'do' such as a collection or a stream.\
The name takes on each value of the expression.\
The name is a local variable whose scope extends to all clauses to the right. The name is also in scope in the body.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs20 \cf0 all \{: x, x <- (1..3) \}\
\
[ 1, 2, 3 ]\
\
all \{: x, x <- [\\a, \\b, \\c] \}\
\
[ a, b, c ]\
\
all \{: x, x <- (1!3)++(2!2)++3 \}\
\
[ 1, 1, 1, 2, 2, 3 ]\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 multiple generators act like nested loops.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs20 \cf0 \
all \{: [x,y], x <- (1..2), y <- (10,20..30) \}\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs18 \cf0 [ [ 1, 10 ], [ 1, 20 ], [ 1, 30 ], [ 2, 10 ], [ 2, 20 ], [ 2, 30 ] ]\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs20 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 generators can depend on previous values.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs20 \cf0 \
all \{: x, x <- (1..3), y <- (1..x) \}\
\
[ 1, 2, 2, 3, 3, 3 ]\
\
all \{: x, x <- (1..3), y <- (1..4-x) \}\
\
[ 1, 1, 1, 2, 2, 3 ]\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 guard clause\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 \
A guard clause is simply an expression. It should return a boolean value. \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f4\i\fs26 \cf0 expr
\f3\i0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs20 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 The guard acts as a filter on the results and constrains the search.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs20 \cf0 \
all \{: x, x <- (0..10), x.odd \}\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs20 \cf0 [ 1, 3, 5, 7, 9 ]\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
x.odd is the guard and causes all even numbers to be skipped.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs20 \cf0 all \{: x, x <- (0..30), (x % 5 == 0) || x.isPowerOfTwo \}\
\
[ 0, 1, 2, 4, 5, 8, 10, 15, 16, 20, 25, 30 ]\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
you can have multiple guards.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs20 \cf0 all \{: [x,y], x <- (0..10), (x % 5 == 0) || x.isPowerOfTwo, y <- (1..2), (x+y).even \}\
\
[ [ 0, 2 ], [ 1, 1 ], [ 2, 2 ], [ 4, 2 ], [ 5, 1 ], [ 8, 2 ], [ 10, 2 ] ]\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 var clause\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 \
A var clause lets you create a new variable binding that you can use in your expressions.\
The scope of the name extends to all clauses to the right and in the body.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs26 \cf0 var 
\f4\i name
\f3\i0  = 
\f4\i expr
\f3\i0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
Unlike the generator clause, the name is bound to a single value, it doesn't iterate.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs20 \cf0 all \{: z, x <- (1..20), \cf2 var\cf0  z = (x*x-x) div: 2, z.odd \}\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs20 \cf0 [ 1, 3, 15, 21, 45, 55, 91, 105, 153, 171 ]\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 \
side effect clause\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 \
This clause lets you insert code to do some side effect like printing.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs26 \cf0 :: 
\f4\i expr
\f3\i0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs20 \cf0 all \{: z, x <- (1..20), \cf2 var\cf0  z = (x*x-x) div: 2, :: [x,z].postln, z.even \}\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 \
termination clause\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 \
The termination clause is for stopping further searching for results. Once the expression becomes false,\
the routine halts.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs26 \cf0 :while 
\f4\i expr
\f3\i0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs20 \cf3 // using a guard\cf0 \
all \{: z, x <- (1..20), \cf2 var\cf0  z = (x*x-x) div: 2,  :: [x,z].postln, z < 50 \}\
\
\cf3 // using a termination clause\cf0 \
\cf3 // this one stops searching, so does less work than the above.\cf0 \
all \{: z, x <- (1..20), \cf2 var\cf0  z = (x*x-x) div: 2,  :: [x,z].postln, :while z < 50 \}\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 Constrained Search\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 \
list comprehensions can solve constrained combinatorial problems like this one:\
\
Baker, Cooper, Fletcher, Miller, and Smith live on different floors of an apartment house that contains only five floors.\
Baker does not live on the top floor. Cooper does not live on the bottom floor.\
Fletcher does not live on either the top or the bottom floor. Miller lives on a higher floor than does Cooper.\
Smith does not live on a floor adjacent to Fletcher's. Fletcher does not live on a floor adjacent to Cooper's.\
Where does everyone live?\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs20 \cf0 (\
z = \{: [baker, cooper, fletcher, miller, smith] ,\
	\cf2 var\cf0  floors = (1..5),\
	baker <- floors,  baker != 5,  \cf3 // Baker does not live on the top floor.\cf0 \
	\cf3 // remove baker's floor from the list. var creates a new scope, so the 'floors' on the left is a new binding.\cf0 \
	\cf2 var\cf0  floors = floors.removing(baker), \
	cooper <- floors, cooper != 1, \cf3 // Cooper does not live on the bottom floor.\cf0 \
	\cf2 var\cf0  floors = floors.removing(cooper), \cf3 // remove cooper's floor from the list.\cf0 \
	fletcher <- floors, (fletcher != 5) && (fletcher != 1) \cf3 // Fletcher does not live on either the top or the bottom floor.\cf0 \
					&& (absdif(fletcher, cooper) > 1), \cf3 // Fletcher does not live on a floor adjacent to Cooper's.\cf0 \
	\cf2 var\cf0  floors = floors.removing(fletcher), \cf3 // remove fletcher's floor\cf0 \
	miller <- floors, miller > cooper, \cf3 // Miller lives on a higher floor than does Cooper.\cf0 \
	\cf2 var\cf0  floors = floors.removing(miller), \cf3 // remove miller's floor\cf0 \
	smith <- floors, absdif(fletcher, smith) > 1  \cf3 // Smith does not live on a floor adjacent to Fletcher's.\cf0 \
\};\
)\
\
z.next; \cf3 // [3, 2, 4, 5, 1 ]\cf0 \
z.next; \cf3 // nil.  only one solution\cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 combinatorial problems can take a lot of time to run.\
you can reorder the above tests to make it run faster. generally you want to search the most constrained variables first.\
the most constrained person above is fletcher, so he should be searched first, then cooper, etc.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs20 \cf0 \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 Grammar:\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 Here is the BNF grammar for list comprehensions in SC.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs20 \cf0 \
[ ] - optional\
\{ \} - zero or more\
\
<list_compre> ::= "\{:" <body> ',' <qualifiers> "\}"\
\
<body> ::= <exprseq>\
\
<exprseq> ::= <expr> \{ ";" <expr> \}\
\
<qualifiers> ::= <qualifier> \{ ',' <qualifiers> \}\
\
<qualifier> ::= <generator> | <guard> | <binding> | <side_effect> | <termination>\
\
<generator> ::= <name> "<-" <exprseq>\
\
<guard> ::= <exprseq>\
\
<binding> ::= "var" <name> "=" <exprseq>\
\
<side_effect> ::= "::" <exprseq>\
\
<termination> ::= ":while" <exprseq>\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 Code Generation:\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs20 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 For each of the above clauses, here is how the code is generated. The body acts as the innermost qualifier.\
By understanding these translations, you can better understand how scoping and control flow work in list comprehensions.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs20 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 generator:\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs20 \cf0 \
expr.do \{|name| ..next qualifier.. \}\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 guard:\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs20 \cf0 \
if (expr) \{ ..next qualifier.. \}\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 binding:\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs20 \cf0 \
\{|name| ..next qualifier.. \}.value(expr)\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 side effect:\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs20 \cf0 \
expr ; ..next qualifier..\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 termination:\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs20 \cf0 \
if (expr) \{ ..next qualifier.. \}\{ nil.alwaysYield \}\
\
}