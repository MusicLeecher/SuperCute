{\rtf1\mac\ansicpg10000\cocoartf824\cocoasubrtf410
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red0\green115\blue0;\red0\green0\blue191;\red191\green0\blue0;
\red96\green96\blue96;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 Catalog of symbolic notations in SuperCollider \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 Arithmetic operators\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 \
Math operators apply to many classes, including arrays and other collections.\
\
Using a basic math operator on a Symbol swallows the operation (returns the symbol) \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf2 \\symbol\cf0  * 5\
symbol \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 number + number
\f1\fs24 				addition\

\f2\fs18 number - number
\f1\fs24 				subtraction\

\f2\fs18 number * number
\f1\fs24 				multiplication\

\f2\fs18 number / number
\f1\fs24 				division\

\f2\fs18 number % number
\f1\fs24 				modulo\

\f2\fs18 number ** number
\f1\fs24 				exponentiation\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 Bitwise arithmetic\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 number & number
\f1\fs24 				bitwise and\

\f2\fs18 number | number
\f1\fs24 				bitwise or\

\f2\fs18 number << number
\f1\fs24 				bitwise left shift\

\f2\fs18 number >> number
\f1\fs24 				bitwise right shift\

\f2\fs18 number +>> number
\f1\fs24 				unsigned bitwise right shift\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 Logical operators\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 object == object
\f1\fs24 				equivalence\

\f2\fs18 object === object
\f1\fs24 				identity\

\f2\fs18 object != object
\f1\fs24 				not equal to\

\f2\fs18 object !== object
\f1\fs24 				not identical to\
\
Objects may be equivalent but not identical.\
\

\f2\fs18 [1, 2, 3] == [1, 2, 3]\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 true\cf0 \
[1, 2, 3] === [1, 2, 3]\
\cf3 false\cf0 	\cf4 // a and b are two different array instances with the same contents\cf0 \
\
a = b = [1, 2, 3];\
a === b;\
\cf3 true\cf0 		\cf4 // a and b are the same array instance\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 number < number
\f1\fs24 				comparison (less than)\

\f2\fs18 number <= number
\f1\fs24 				comparison (less than or equal to)\

\f2\fs18 number > number
\f1\fs24 				comparison (greater than)\

\f2\fs18 number >= number
\f1\fs24 				comparison (greater than or equal to)\
\

\f2\fs18 Boolean && Boolean
\f1\fs24 				logical And\

\f2\fs18 Boolean || Boolean
\f1\fs24 				logical Or\
\
When a function is the second operand, these operators perform short-circuiting (i.e., the function is executed only when its result would influence the result of the operation). This is recommended for speed.\
\
With and: and or: second-argument functions will be inlined. If you use && or ||, no inlining will be done and performance will be slower.\
\

\f2\fs18 a = 1;\
\
a == 1 and: \{ \cf5 "second condition"\cf0 .postln; [\cf3 true\cf0 , \cf3 false\cf0 ].choose \}\
second condition\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 true\cf0 \
\
a == 1 or: \{ \cf5 "second condition"\cf0 .postln; [\cf3 true\cf0 , \cf3 false\cf0 ].choose \}\
\cf3 true\cf0 \
\
a != 1 and: \{ \cf5 "second condition"\cf0 .postln; [\cf3 true\cf0 , \cf3 false\cf0 ].choose \}\
\cf3 false\cf0 \
\
a != 1 or: \{ \cf5 "second condition"\cf0 .postln; [\cf3 true\cf0 , \cf3 false\cf0 ].choose \}\
second condition\
\cf3 true\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
In this case, the second condition will cause an error if a is nil, because nil does not understand addition. a.notNil is a safeguard to ensure the second condition makes sense.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 a = \cf3 nil\cf0 ;\
a.notNil and: \{ \cf5 "second condition"\cf0 .postln; (a = a+1) < 5 \}\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 false\cf0 \
\
a = 10;\
a.notNil and: \{ \cf5 "second condition"\cf0 .postln; (a = a+1) < 5 \}\
second condition\
\cf3 false\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 Array and Collection operators\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 object ++ object
\f1\fs24 				concatenation\

\f2\fs18 collection +++ collection
\f1\fs24 		lamination (see 
\f0\b [\ul J_concepts_in_SC\ulnone ]
\f1\b0 )\
\

\f2\fs18 collection @ index
\f1\fs24 				collection/array indexing: .at(index) or [index]\

\f2\fs18 collection @@ integer
\f1\fs24 			collection/array indexing: .wrapAt(int)\

\f2\fs18 collection @|@ integer
\f1\fs24 			collection/array indexing: .foldAt(int)\

\f2\fs18 collection |@| integer
\f1\fs24 			collection/array indexing: .clipAt(int)\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 Set operators\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 set & set
\f1\fs24 						intersection of two sets\

\f2\fs18 set | set
\f1\fs24 						union of two sets\

\f2\fs18 setA - setB
\f1\fs24 					difference of sets (elements of setA not found in setB)\
\

\f2\fs18 set -- set
\f1\fs24 					symmetric difference\
\
(setA -- setB) == ((setA - setB) | (setB - setA))\
\

\f2\fs18 a = \cf3 Set\cf0 [2, 3, 4, 5, 6, 7];\
b = \cf3 Set\cf0 [5, 6, 7, 8, 9];\
\
a - b\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 Set\cf0 [ 2, 4, 3 ]\
\
b - a\
\cf3 Set\cf0 [ 8, 9 ]\
\
((a-b) | (b-a))\
\cf3 Set\cf0 [ 2, 9, 3, 4, 8 ]\
\
a -- b\
\cf3 Set\cf0 [ 2, 9, 3, 4, 8 ]\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 Geometry operators\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 number @ number
\f1\fs24 				x @ y returns Point(x, y)\

\f2\fs18 point @ point
\f1\fs24 					Point(left, top) @ Point(right, bottom)\
								returns Rect(left, top, right-left, bottom-top)\

\f2\fs18 ugen @ ugen
\f1\fs24 					create a Point with 2 UGens\
\

\f2\fs18 rect & rect
\f1\fs24 					intersection of two rectangles\

\f2\fs18 rect | rect
\f1\fs24 					union of two rectangles (returns a Rect\
								whose boundaries exactly encompass both Rects)\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 IOStream operators\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 stream << object
\f1\fs24 				represent the object as a string and add to the stream \
\
A common usage is with the Post class, to write output to the post window.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf3 Post\cf0  << \cf5 "Here is a random number: "\cf0  << 20.rand << \cf5 ".\\n"\cf0 ;\
Here is a random number: 13.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 stream <<* collection
\f1\fs24 			add each item of the collection to the stream\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf3 Post\cf0  << [0, 1, 2, 3]\
[ 0, 1, 2, 3 ]\
\
\cf3 Post\cf0  <<* [0, 1, 2, 3]\
0, 1, 2, 3\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 stream <<< object
\f1\fs24 				add the object's compile string to the stream\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf3 Post\cf0  <<< \cf5 "a string"\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf5 "a string"\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 stream <<<* collection
\f1\fs24 			add each item's compile string to the stream\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 Conditional execution operators\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 object ? object
\f1\fs24 					nil check (no .value)\

\f2\fs18 object ?? function
\f1\fs24 				nil check (.value, function is inlined)\
\
If the object is nil, the second expression's value will be used; otherwise, it will be the first object.\
\

\f2\fs18 a = [\cf3 nil\cf0 , 5];\
\
10.do(\{ (a.choose ? 20.rand).postln \});\
10.do(\{ (a.choose ?? \{ 20.rand \}).postln \});\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
?? \{ \} is generally recommended. ? always evaluates the second expression, even if its value will not be used. ?? evaluates the function conditionally (only when needed). If the function defines no variables, the function will be inlined for speed. \
\
Especially useful when the absence of an object requires a new object to be created. In this example, it's critical that a new SCSlider not be created if the object was already passed in.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 f = \{ \cf3 |slider, parent|\cf0 \
	slider = slider ?? \{ \cf3 SCSlider\cf0 .new(parent, \cf3 Rect\cf0 (0, 0, 100, 20)) \};\
	slider.value_(0);\
\};\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
If the first line inside the function instead read 
\f2\fs18 slider = slider ? \cf3 SCSlider\cf0 .new(parent, \cf3 Rect\cf0 (0, 0, 100, 20));
\f1\fs24 , a new slider would be created even if it is not needed, or used.\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 object !? function
\f1\fs24 				execute function if object is not nil\
\

\f2\fs18 a = [10, \cf3 nil\cf0 ].choose;\
a !? \{ \cf5 "ran func"\cf0 .postln \};\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 // equivalent of:\cf0 \
if (a.notNil) \{ \cf5 "ran func"\cf0 .postln \};\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
Used when an operation requires a variable not to be empty.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 f = \{ \cf3 |a|\cf0  a + 5 \};\
f.value\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 // error: nil does not understand +\cf0 \
\
f = \{ \cf3 |a|\cf0  a !? \{ a+5 \} \};\
f.value\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 nil\cf0 	\cf4 // no error\cf0 \
f.value(2)\
7\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 Miscellaneous operators\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 object ! number
\f1\fs24 				object.dup(number)\
\

\f2\fs18 15 ! 5\
[ 15, 15, 15, 15, 15 ]\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
If the object is a function, it behaves like Array.fill(number, function).\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \{ 10.rand \} ! 5\
[ 8, 9, 3, 8, 0 ]\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 object -> object
\f1\fs24 				creates an Association, used in dictionaries\
\

\f2\fs18 expression <! expression
\f1\fs24 		bypass value of second expression \
\
This operator evaluates both expressions, and returns the value of the first.\
\

\f2\fs18 a = 0;\
0\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 // a is incremented twice, but the return value (1)\cf0 \
\cf4 // comes from the first increment (0 + 1)\cf0 \
(a = a + 1) <! (a = a + 1)\
1\
\
a	\cf4 // a's value reflects both increments\cf0 \
2\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 function <> function
\f1\fs24 			function composition operator \
\
This operator returns a new function, which evaluates the second function and passes the result to the first function.\
\

\f2\fs18 f = \{ \cf3 |a|\cf0  a * 5 \} <> \{\cf3 |a|\cf0  a + 2 \};\
f.(10);\
60	\cf4 // == (10+2) * 5\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
An array as argument is passed through the chain:\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \
f.([10, 75, 512]);\
[ 60, 385, 2570 ]	\cf4 // == ([10, 75, 512]+2) * 5\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 Symbolic notations to define literals/other objects\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 $
\f1\fs24 							character prefix: "ABC".at(0) == $A\

\f2\fs18 ''
\f1\fs24  or 
\f2\fs18 \\
\f1\fs24 						define a literal Symbol: 'abc' === \\abc\

\f2\fs18 ""
\f1\fs24 							define a literal String\

\f2\fs18 [item, item...]
\f1\fs24 				define an Array containing given items\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf3 Set\cf0 [item, item...]
\f1\fs24 				define a Set -- any Collection class name can be used other than Set\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 #[item, item...]
\f1\fs24 				define a literal Array\

\f2\fs18 (a:1, b:2)
\f1\fs24 					define an Event (same as Event[\\a -> 1, \\b -> 2])\

\f2\fs18 `
\f1\fs24  (backtick or backquote)			define a Ref: `1 == Ref(1), `(a+1) == Ref(a+1)\
\

\f2\fs18 \\
\f1\fs24 							inside a string or symbol, escapes the next character\
\

\f2\fs18 "abc\\"def\\"ghi"\
abc"def"ghi\
\
'abc\\'def\\'ghi'\
abc'def'ghi\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\\t							tab character\
\\n							newline character\
\\l							linefeed character\
\\r							carriage return character\
\\\\							\\ character\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \{ \}
\f1\fs24 							define an open function\

\f2\fs18 #\{ \}
\f1\fs24 							define a closed function\

\f2\fs18 (_ * 2)
\f1\fs24 						define a function \{ |a| a * 2 \} (see 
\f0\b [\ul Partial-Application\ulnone ]
\f1\b0 )\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 Argument definition
\f1\b0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 |a, b, c|
\f1\fs24 						define function/method arguments\

\f2\fs18 |a, b ... c|
\f1\fs24 					define function/method arguments;\
								arguments after a and b will be placed into c as an array\
\

\f2\fs18 #a, b, c = myArray
\f1\fs24 				assign consecutive elements of myArray to multiple variables\

\f2\fs18 #a, b ... c = myArray
\f1\fs24 			assign first two elements to a and b; the rest as an array into c\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 Where f is a function
\f1\b0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 f.( )
\f1\fs24 						evaluate the function with the arguments in parentheses\

\f2\fs18 f.(*argList)
\f1\fs24 					evaluate the function with the arguments in an array\

\f2\fs18 f.(anArgName: value)
\f1\fs24 			keyword addressing of function or method arguments\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf3 SomeClass\cf0 .[index]
\f1\fs24 				Equivalent to SomeClass.at(index) -- Instr.at is a good example\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 myObject.method(*array)
\f1\fs24 			call the method with the arguments in an array\

\f2\fs18 obj1 method: obj2
\f1\fs24 				same as obj.method(obj2) or method(obj1, obj2)\
								This works only with single-argument methods.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 Class and instance variable access
\f1\b0 \
\
Inside a class definition (see 
\f0\b [\ul Writing-Classes\ulnone ]
\f1\b0 ):\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf3 classvar\cf0  <a,
\f1\fs24 					Define a class variable with a getter method (for outside access)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 	>b,
\f1\fs24 						Define a class variable with a setter method\

\f2\fs18 	<>c;
\f1\fs24 						Define a class variable with both a getter and setter method\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf3 var\cf0 	<a,
\f1\fs24 						Define an instance variable with a getter method (for outside access)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 	>b,
\f1\fs24 						Define an instance variable with a setter method\

\f2\fs18 	<>c;
\f1\fs24 						Define an instance variable with both a getter and setter method\
\
These notations do not apply to variables defined within methods.\
\

\f2\fs18 ^someExpression
\f1\fs24 				Inside a method definition: return the expression's value to the caller\
\

\f2\fs18 instVar_ \{ \}
\f1\fs24 					define a setter for an instance variable\

\f2\fs18 myObject.instVar = x;
\f1\fs24 			invoke the setter: (myObject.instVar_(x); x)\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 Array series and indexing
\f1\b0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 (a..b)
\f1\fs24 						produces an array consisting of consecutive integers from a to b\

\f2\fs18 (a, b..c)
\f1\fs24 						e.g.: (1, 3..9) produces [1, 3, 5, 7, 9]\

\f2\fs18 (..b)
\f1\fs24 						produces an array 0 through b\

\f2\fs18 (a..)
\f1\fs24 						not legal (no endpoint given)\
\

\f2\fs18 a[i..j]
\f1\fs24 						a.copyRange(i, j)\

\f2\fs18 a[i, j..k]
\f1\fs24 					e.g.: a[1, 3..9] retrieves array elements 1, 3, 5, 7, 9\

\f2\fs18 a[..j]
\f1\fs24 						a.copyRange(0, j)\

\f2\fs18 a[j..]
\f1\fs24 						a.copyRange(i, a.size-1)  (this is OK--Array is finite)\
\

\f2\fs18 ~
\f1\fs24 							access an environment variable\

\f2\fs18 ~abc
\f1\fs24 							compiles to \\abc.envirGet\

\f2\fs18 ~abc = value
\f1\fs24 					compiles to \\abc.envirPut(value)\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 Adverbs to math operators
\f1\b0  (see 
\f0\b [\ul Adverbs\ulnone ]
\f1\b0 )\
\
e.g.:\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 [1, 2, 3] * [2, 3, 4]\
[ 2, 6, 12 ]\
\
[1, 2, 3] *.t [2, 3, 4]\
[ [ 2, 3, 4 ], [ 4, 6, 8 ], [ 6, 9, 12 ] ]\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 .s
\f1\fs24 							output length is the shorter of the two arrays\

\f2\fs18 .f
\f1\fs24 							use folded indexing instead of wrapped indexing\

\f2\fs18 .t
\f1\fs24 							table-style\

\f2\fs18 .x
\f1\fs24 							cross (like table, except that the results of each operation\
								are concatenated, not added as another dimension)\
\

\f2\fs18 .0		
\f1\fs24 					operator depth (see 
\f0\b [\ul J_concepts_in_SC\ulnone ]
\f1\b0 )\

\f2\fs18 .1
\f1\fs24  etc.\
}