{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red191\green0\blue0;\red0\green112\blue0;
\red96\green96\blue96;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 Polymorphism
\f1\b0\fs24 \
\
Polymorphism is the ability of different classes to respond to a message in different ways. A message generally has some underlying meaning and it is the responsibility of each class to respond in a way appropriate to that meaning.\
\
For example, the '
\f0\b value
\f1\b0 ' message means "give me the effective value of this object".\
\
The value method is implemented by these classes (among others):\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs22 \cf0 \
Function :   this.value(args)\
Object :   this.value()\
Ref :   this.value\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 Let's look at how these classes implement the value message.\
\
Here's the value method in class 
\f0\b Object
\f1\b0 :\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 	value \{ ^\cf2 this\cf0  \}\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs14 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 It simply returns itself. Since all classes inherit from class Object this means that unless a class overrides 'value', the object will respond to 'value' by returning itself.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 5.postln;			\cf3 // posts itself\
\cf0 5.value.postln;		\cf3 // value returns itself\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 'a symbol'\cf0 .postln;\
\cf4 'a symbol'\cf0 .value.postln;\
[1,2,3].value.postln;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 //etc...\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 \
In class 
\f0\b Function
\f1\b0  the value method is a primitive.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 	value \{ \cf2 arg\cf0  ... args; \
		\cf2 _FunctionValue\cf0  \
		\cf3 // evaluate a function with args\
\cf0 		^\cf2 this\cf0 .primitiveFailed \
	\}\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 \
\
_FunctionValue is a C code primitive, so it is not possible to know just by looking at it what it does. However what it does is to evaluate the function and return the result.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 \{ 5.squared \}.postln;			\cf3 // posts Instance of Function\
\cf0 \{ 5.squared \}.value.postln;		\cf3 // posts 25\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 \
The 
\f0\b Ref
\f1\b0  class provides a way to create an indirect reference to an object. It can be used to pass a value by reference. Ref objects have a single instance variable called '
\f0\b value
\f1\b0 '. The '
\f0\b value
\f1\b0 ' method returns the value of the instance variable '
\f0\b value
\f1\b0 '. Here is the class definition for 
\f0\b Ref
\f1\b0 .\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf2 Ref\cf0  : \cf2 AbstractFunction\cf0  \
\{\
	\cf2 var\cf0  <>value;\
	*new \{ \cf2 arg\cf0  thing; ^\cf2 super\cf0 .new.value_(thing) \}\
	set \{ \cf2 arg\cf0  thing; value = thing \}\
	get \{ ^value \}\
	dereference \{ ^value \}\
	asRef \{ ^\cf2 this\cf0  \}\
\
	\cf3 //behave like a stream\cf0 \
	next \{ ^value \}\
	embedInStream \{ \cf2 arg\cf0  inval;\
		^\cf2 this\cf0 .value.embedInStream(inval)\
	\}\
\
	printOn \{ \cf2 arg\cf0  stream;\
		stream << \cf5 "`("\cf0  << value << \cf5 ")"\cf0 ;\
	\}\
	storeOn \{ \cf2 arg\cf0  stream;\
		stream << \cf5 "`("\cf0  <<< value << \cf5 ")"\cf0 ;\
	\}\
\}\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 Here is how it responds :\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 \
\cf2 Ref\cf0 .new(123).postln;\
\cf2 Ref\cf0 .new(123).value.postln;
\f1 \
\
Ref also implements a message called '
\f0\b dereference
\f1\b0 ' which is another good example of polymorphism. As implemented in Ref, dereference just returns the value instance variable which is no different than what the value method does. So what is the need for it? That is explained by how other classes respond to dereference. The dereference message means "remove any Ref that contains you". In class Object dereference returns the object itself, again just like the value message. The difference is that no other classes override this method. So that dereference of a Function is still the Function.\
\

\f2 Object :   this.dereference()\
Ref :   this.dereference()\
\
5.value.postln;		\
\{ 5.squared \}.value.postln;		\
\cf2 Ref\cf0 .new(123).value.postln;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 5.dereference.postln;		\
\{ 5.squared \}.dereference.postln;		\
\cf2 Ref\cf0 .new(123).dereference.postln;\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 Yet another example of polymorphism is 
\f0\b play
\f1\b0 . Many different kinds of objects know how to play themselves.
\f2 \
\
\{ \cf2 PinkNoise\cf0 .ar(0.1) \}.play;						\cf3 // Function\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
(												\cf3 // AppClock\cf0 \
\cf2 var\cf0  w, r;\
w = \cf2 SCWindow\cf0 (\cf5 "trem"\cf0 , \cf2 Rect\cf0 (512, 256, 360, 130));\
w.front;\
r = \cf2 Routine\cf0 (\{ arg appClockTime;\
		["AppClock has been playing for secs:",appClockTime].postln;\
		60.do(\{ \cf2 arg\cf0  i;\
			0.05.yield;\
			w.bounds = w.bounds.moveBy(10.rand2, 10.rand2);\
			w.alpha = cos(i*0.1pi)*0.5+0.5;\
		\});\
		1.yield;\
		w.close;\
\});\
\cf2 AppClock\cf0 .play(r);\
)\cf3 \
\cf0 \
(												\cf3 // SynthDef
\f1\fs30 \cf0 \

\f2\fs24 x = \cf2 SynthDef\cf0 (\cf5 "Help-SynthDef"\cf0 , \
	\{ \cf2 arg\cf0  out=0;\
		 \cf2 Out\cf0 .ar(out, \cf2 PinkNoise\cf0 .ar(0.1))\
	\}).play;\
)\cf3 \
\cf0 \
\cf2 Pbind\cf0 (\\\cf4 degree\cf0 , \cf2 Pseq\cf0 ([0, 1, 2, 3],\cf2 inf\cf0 )).play;	\cf3 // Pattern\
\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 \
Polymorphism allows you to write code that does not assume anything about the implementation of an object, but rather asks the object to "do what I mean" and have the object respond appropriately.\
\
}