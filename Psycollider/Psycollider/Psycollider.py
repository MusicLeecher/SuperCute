# Project : Psycollider
# Generated by Visual Python from a template in C:\Program Files\ActiveState Visual Python\Wizards\PythonSimpleWiz\Templates\1033

#############
# changelog :
#############

# SC3-WIN32-2005-02-19 : deees' :
# -------------------------------------------
# added "CTRL+W" shortcut for closing the current window
# improvement of codes' highlighting. Now, SC3-Keywords are read from "keywords.list" file.
# fixed some bugs.

# SC3-WIN32-2004-10-20-21h30 :
# -------------------------------------------
# CTRL+RETURN is a shortcut for eval selection
# now allows to open and save text files and open rtf files
# now displays a * sign when a text file is modified. also asks user whether to save when closing modified windows
# ALT+PERIOD now works (stops clocks and frees synths)
# added a log window where SC output is sent , instead of the DOS window
# pressing F1 now opens the help file with the same name as the selection, or the main help file is that fails
# now calls s.serverRunning = True to fix the someSynthDef.play code snippets. this is a temp hack
# choosing File -> Open Code File now opens the source code for the selected class or method
# better color scheme when highlighting braces/parentheses/brackets that are matching 
# MIDI input is now working (not tested a lot, but seems to work ok for more than just me :) )
# F2 now arrange the windows in a basic way : log windows at the bottom third, and code windows above, superimposed
# menu entry : Main.run
# menu entry : open class def (alt+j, similar to cmd+j in the cocoa app)
# menu entry : compile library (alt+k, similar to cmd+k in the cocoa app)
# help files are converted to look good with Windows standard fonts (Helvetica -> Arial and Monaco -> Courier New)

# SC3-WIN32-2004-10-07-00h59 : first version :
# -------------------------------------------
# very basic MDI environment where SC code can be evaluated

#################################################################################
# TODO : BUGS :
# TODO : clarify the audio driver issues
# TODO : VTune the code to understand high cpu usage on routines
#        (strange... it seems to happen in WaitForMultipleObjects, which should block.
#         on the other hand, it feels like fake cpu usage (launching 100 times more routines
#         leads to the same result, with everything sounding ok)
# TODO : pressing F2 should quit maximized mode first, otherwise weird bugs happen

# TODO : FEATURES :
# TODO : alt + y should open a window with all occurrences of the method in several object, listed like "Sample-play"
# TODO : selection "Object-Method" and choosing alt + j will open the class def file for THAT method
# TODO : selecting any text and pressing alt+shift+y will open a window with all references to the text in all methods of the class lib
# TODO : graphical class browser
# TODO : allow to assign stuff to F-keys (exec script, ...)
# TODO : change Kernel.sc so that openWinCodeFile opens a window READ-ONLY (must change the callable) and 
#        with the correct title
# TODO : implement methodReferencesWin32 based on methodReferences that opens the collection
#        in a window.
# TODO : CTRL+F1 should open a little dlg with some text to type and opens the corresponding help file
# TODO : SHIFT+F1 should open a help file and close the current one first (warning if old and new are the same)
# TODO : opening a file should merely re-activate the existing window, if the file is already loaded.
#################################################################################

import wx
import wx.stc as stc
import PySCLang, os, string, keyword, sys

if wx.Platform == '__WXMSW__':
  faces = { 'times': 'Times New Roman', 'mono' : 'Courier New', 'helv' : 'Arial', 'other': 'Comic Sans MS', 'size' : 10, 'size2': 8, }
  gAppHelpFolder = 'help_windows'
else:
  faces = { 'times': 'Times', 'mono' : 'Courier', 'helv' : 'Helvetica', 'other': 'new century schoolbook', 'size' : 10, 'size2': 8, }
  gAppHelpFolder = 'Help-windows'
  
gHelpFolder = 'Help'
gUserExtensionFolder = '~\\SuperCollider\\Extensions'

#----------------------------------------------------------------------
ID_NewCodeWin  = wx.NewId()
ID_StartServer = wx.NewId()
ID_StopServer = wx.NewId()
ID_OpenFile = wx.NewId()
ID_SaveFile = wx.NewId()
ID_SaveFileAs = wx.NewId()
ID_CloseCodeWin = wx.NewId() # yssr

ID_Exit = wx.NewId()
ID_AccelF2 = wx.NewId()
ID_AccelF2 = wx.NewId()
ID_AccelF3 = wx.NewId()
ID_AccelF4 = wx.NewId()
ID_AccelF5 = wx.NewId()
ID_AccelF6 = wx.NewId()
ID_AccelF7 = wx.NewId()
ID_AccelF8 = wx.NewId()
ID_AccelF9 = wx.NewId()
ID_AccelF10 = wx.NewId()
ID_AccelF11 = wx.NewId()
ID_AccelF12 = wx.NewId()

ID_EvalSelection = wx.NewId()

ID_Lang_Stop_Server = wx.NewId()
ID_Lang_Run = wx.NewId()
ID_Lang_Stop = wx.NewId()
ID_Lang_CompileLibrary = wx.NewId()
ID_Lang_OpenClassDef = wx.NewId()
ID_Lang_ImplementationsOf = wx.NewId()
ID_Lang_ReferencesTo = wx.NewId()

ID_Go_To_Help_File = wx.NewId()

#----------------------------------------------------------------------
# yssr --------- set SC3_KEYWORDS as global vary.

try:
  file = open("keywords.list","r")
  SC3_KEYWORDS = string.split( file.read() )
  file.close()
except IOError:
  SC3_KEYWORDS = [ "var", "arg", "Server" ]
  print "warning:"
  print "SC3-keywords definition file \"keywords.list\" was not found."
  print "so now, these following words are the KEYWORDS for the meantime."
  print SC3_KEYWORDS

SC3_KEYWORDS.sort()
#print SC3_KEYWORDS

#----------------------------------------------------------------------

class PsycolliderRTFSubWin(wx.TextCtrl):
  def __init__ (self,parent):
    wx.TextCtrl.__init__(self,parent,style = wx.TE_MULTILINE | wx.TE_RICH2 | wx.TE_READONLY)
    self.Bind(wx.EVT_CHAR, self.OnChar)
  def OnChar(self,event):
    self.GetParent().GetParent().OnChildCharHook(event)

class PsycolliderCodeSubWin(wx.stc.StyledTextCtrl):
  fold_symbols = 3
  def __init__ (self,parent):
    wx.stc.StyledTextCtrl.__init__(self,parent)
    font = wx.Font(10, wx.MODERN, wx.NORMAL, wx.NORMAL, False, "Courier New")
    self.StyleSetFont(wx.stc.STC_STYLE_DEFAULT, font)
    self.Bind(wx.EVT_CHAR, self.OnChar)
    self.SetModEventMask(wx.stc.STC_MOD_INSERTTEXT | wx.stc.STC_MOD_DELETETEXT | wx.stc.STC_PERFORMED_USER)
    self.Bind(wx.stc.EVT_STC_CHANGE, self.OnStcChange)
    
    self.CmdKeyAssign(ord('B'), stc.STC_SCMOD_CTRL, stc.STC_CMD_ZOOMIN)
    self.CmdKeyAssign(ord('N'), stc.STC_SCMOD_CTRL, stc.STC_CMD_ZOOMOUT)

    self.SetLexer(wx.stc.STC_LEX_CPP)             # yssr
    self.SetKeyWords(0, " ".join(SC3_KEYWORDS))   # yssr

    self.SetProperty("fold", "1")
    self.SetProperty("tab.timmy.whinge.level", "1")
    self.SetMargins(1,0) # yssr

    self.SetViewWhiteSpace(False)
    #self.SetBufferedDraw(False)
    #self.SetViewEOL(True)
    #self.SetEOLMode(stc.STC_EOL_CRLF)
    #self.SetUseAntiAliasing(True)

    self.SetEdgeMode(stc.STC_EDGE_BACKGROUND)
    self.SetEdgeColumn(78)

    # Setup a margin to hold fold markers
    #self.SetFoldFlags(16)  ###  WHAT IS THIS VALUE?  WHAT ARE THE OTHER FLAGS?  DOES IT MATTER?
    self.SetMarginType(2, stc.STC_MARGIN_SYMBOL)
    self.SetMarginMask(2, stc.STC_MASK_FOLDERS)
    self.SetMarginSensitive(2, True)
    self.SetMarginWidth(2, 12)

    # Like a flattened tree control using square headers
    self.MarkerDefine(stc.STC_MARKNUM_FOLDEROPEN,    stc.STC_MARK_BOXMINUS,          "white", "#808080")
    self.MarkerDefine(stc.STC_MARKNUM_FOLDER,        stc.STC_MARK_BOXPLUS,           "white", "#808080")
    self.MarkerDefine(stc.STC_MARKNUM_FOLDERSUB,     stc.STC_MARK_VLINE,             "white", "#808080")
    self.MarkerDefine(stc.STC_MARKNUM_FOLDERTAIL,    stc.STC_MARK_LCORNER,           "white", "#808080")
    self.MarkerDefine(stc.STC_MARKNUM_FOLDEREND,     stc.STC_MARK_BOXPLUSCONNECTED,  "white", "#808080")
    self.MarkerDefine(stc.STC_MARKNUM_FOLDEROPENMID, stc.STC_MARK_BOXMINUSCONNECTED, "white", "#808080")
    self.MarkerDefine(stc.STC_MARKNUM_FOLDERMIDTAIL, stc.STC_MARK_TCORNER,           "white", "#808080")

    self.Bind(stc.EVT_STC_UPDATEUI, self.OnUpdateUI)
    self.Bind(stc.EVT_STC_MARGINCLICK, self.OnMarginClick)
    self.Bind(wx.EVT_KEY_DOWN, self.OnKeyPressed)

    # Make some styles,  The lexer defines what each style is used for, we
    # just have to define what each style looks like.  This set is adapted from
    # Scintilla sample property files.

    # Global default styles for all languages
    self.StyleSetSpec(stc.STC_STYLE_DEFAULT,     "face:%(mono)s,size:%(size)d" % faces)
    self.StyleClearAll()  # Reset all to be like the default

    # Global default styles for all languages
    self.StyleSetSpec(stc.STC_STYLE_DEFAULT,     "face:%(mono)s,size:%(size)d" % faces)
    #self.StyleSetSpec(stc.STC_STYLE_LINENUMBER,  "back:#C0C0C0,face:%(helv)s,size:%(size2)d" % faces)
    self.StyleSetSpec(stc.STC_STYLE_CONTROLCHAR, "face:%(other)s" % faces)
    self.StyleSetSpec(stc.STC_STYLE_BRACELIGHT,  "fore:#FFFFFF,back:#00FFFF,bold")
    self.StyleSetSpec(stc.STC_STYLE_BRACEBAD,    "fore:#000000,back:#FF3333,bold")

    # C++ styles
    # Default 
    self.StyleSetSpec(stc.STC_C_DEFAULT, "fore:#000000,face:%(mono)s,size:%(size)d" % faces)
    # Comments
    self.StyleSetSpec(stc.STC_C_COMMENTLINE, "fore:#007F00,face:%(mono)s,size:%(size)d" % faces)
    # Number
    self.StyleSetSpec(stc.STC_C_NUMBER, "bold,fore:#333333,size:%(size)d" % faces)
    # String
    self.StyleSetSpec(stc.STC_C_STRING, "italic,fore:#CC0000,face:%(mono)s,size:%(size)d" % faces)
    # Single quoted string
    self.StyleSetSpec(stc.STC_C_CHARACTER, "fore:#CC0000,face:%(mono)s,size:%(size)d" % faces)
    # Keyword
    self.StyleSetSpec(stc.STC_C_WORD, "fore:#00007F,bold,size:%(size)d" % faces)
    # Operators
    # self.StyleSetSpec(stc.STC_C_OPERATOR, "bold,size:%(size)d" % faces)
    # Identifiers
    self.StyleSetSpec(stc.STC_C_IDENTIFIER, "fore:#000000,face:%(mono)s,size:%(size)d" % faces)
    # End of line where string is not closed
    self.StyleSetSpec(stc.STC_C_STRINGEOL, "fore:#000000,face:%(mono)s,back:#E0C0E0,eol,size:%(size)d" % faces)
    #self.StyleSetSpec(stc.STC_C_COMMENTDOC, "fore:#7F7F7F,size:%(size)d" % faces)
    #self.StyleSetSpec(stc.STC_C_COMMENTLINEDOC,  "fore:#7F7F7F,size:%(size)d" % faces)
    #self.StyleSetSpec(stc.STC_C_GLOBALCLASS, "fore:#7F7F7F,size:%(size)d" % faces)
    self.SetCaretForeground("BLACK")
    #wx.MessageBox("OnStcChange")
    #GetParent().setModified

  def OnKeyPressed(self, event):
    if self.CallTipActive():
      self.CallTipCancel()
    key = event.KeyCode()

    if key == 32 and event.ControlDown():
      pos = self.GetCurrentPos()

      # Tips
      if event.ShiftDown():
        self.CallTipSetBackground("yellow")
        self.CallTipShow(pos, 'lots of of text: blah, blah, blah\n\n'
                 'show some suff, maybe parameters..\n\n'
                 'fubar(param1, param2)')
      # Code completion
      else:
        #lst = []
        #for x in range(50000):
        #  lst.append('%05d' % x)
        #st = " ".join(lst)
        #print len(st)
        #self.AutoCompShow(0, st)

        kw = keyword.kwlist[:]
        kw.append("zzzzzz?2")
        kw.append("aaaaa?2")
        kw.append("__init__?3")
        kw.append("zzaaaaa?2")
        kw.append("zzbaaaa?2")
        kw.append("this_is_a_longer_value")
        #kw.append("this_is_a_much_much_much_much_much_much_much_longer_value")

        kw.sort()  # Python sorts are case sensitive
        self.AutoCompSetIgnoreCase(False)  # so this needs to match

        # Images are specified with a appended "?type"
        for i in range(len(kw)):
          if kw[i] in keyword.kwlist:
            kw[i] = kw[i] + "?1"
        self.AutoCompShow(0, " ".join(kw))
    else:
      event.Skip()


  def OnUpdateUI(self, evt):
    # check for matching braces
    braceAtCaret = -1
    braceOpposite = -1
    charBefore = None
    caretPos = self.GetCurrentPos()

    if caretPos > 0:
      charBefore = self.GetCharAt(caretPos - 1)
      styleBefore = self.GetStyleAt(caretPos - 1)

    # check before
    if charBefore and chr(charBefore) in "[]{}()" and styleBefore == stc.STC_C_OPERATOR:
      braceAtCaret = caretPos - 1

    # check after
    if braceAtCaret < 0:
      charAfter = self.GetCharAt(caretPos)
      styleAfter = self.GetStyleAt(caretPos)

      if charAfter and chr(charAfter) in "[]{}()" and styleAfter == stc.STC_C_OPERATOR:
        braceAtCaret = caretPos

    if braceAtCaret >= 0:
      braceOpposite = self.BraceMatch(braceAtCaret)

    if braceAtCaret != -1  and braceOpposite == -1:
      self.BraceBadLight(braceAtCaret)
    else:
      self.BraceHighlight(braceAtCaret, braceOpposite)
      #pt = self.PointFromPosition(braceOpposite)
      #self.Refresh(True, wxRect(pt.x, pt.y, 5,5))
      #print pt
      #self.Refresh(False)


  def OnMarginClick(self, evt):
    # fold and unfold as needed
    if evt.GetMargin() == 2:
      if evt.GetShift() and evt.GetControl():
        self.FoldAll()
      else:
        lineClicked = self.LineFromPosition(evt.GetPosition())

        if self.GetFoldLevel(lineClicked) & stc.STC_FOLDLEVELHEADERFLAG:
          if evt.GetShift():
            self.SetFoldExpanded(lineClicked, True)
            self.Expand(lineClicked, True, True, 1)
          elif evt.GetControl():
            if self.GetFoldExpanded(lineClicked):
              self.SetFoldExpanded(lineClicked, False)
              self.Expand(lineClicked, False, True, 0)
            else:
              self.SetFoldExpanded(lineClicked, True)
              self.Expand(lineClicked, True, True, 100)
          else:
            self.ToggleFold(lineClicked)


  def FoldAll(self):
    lineCount = self.GetLineCount()
    expanding = True

    # find out if we are folding or unfolding
    for lineNum in range(lineCount):
      if self.GetFoldLevel(lineNum) & stc.STC_FOLDLEVELHEADERFLAG:
        expanding = not self.GetFoldExpanded(lineNum)
        break;

    lineNum = 0

    while lineNum < lineCount:
      level = self.GetFoldLevel(lineNum)
      if level & stc.STC_FOLDLEVELHEADERFLAG and \
         (level & stc.STC_FOLDLEVELNUMBERMASK) == stc.STC_FOLDLEVELBASE:

        if expanding:
          self.SetFoldExpanded(lineNum, True)
          lineNum = self.Expand(lineNum, True)
          lineNum = lineNum - 1
        else:
          lastChild = self.GetLastChild(lineNum, -1)
          self.SetFoldExpanded(lineNum, False)

          if lastChild > lineNum:
            self.HideLines(lineNum+1, lastChild)

      lineNum = lineNum + 1



  def Expand(self, line, doExpand, force=False, visLevels=0, level=-1):
    lastChild = self.GetLastChild(line, level)
    line = line + 1

    while line <= lastChild:
      if force:
        if visLevels > 0:
          self.ShowLines(line, line)
        else:
          self.HideLines(line, line)
      else:
        if doExpand:
          self.ShowLines(line, line)

      if level == -1:
        level = self.GetFoldLevel(line)

      if level & stc.STC_FOLDLEVELHEADERFLAG:
        if force:
          if visLevels > 1:
            self.SetFoldExpanded(line, True)
          else:
            self.SetFoldExpanded(line, False)

          line = self.Expand(line, doExpand, force, visLevels-1)

        else:
          if doExpand and self.GetFoldExpanded(line):
            line = self.Expand(line, True, force, visLevels-1)
          else:
            line = self.Expand(line, False, force, visLevels-1)
      else:
        line = line + 1;

    return line
      
    # this is where unicode -> string conversion occurs...
    PySCLang.setCmdLine(str(sel))
    PySCLang.sendMain(methodName)

  def OnChar(self,event):
    self.GetParent().GetParent().OnChildCharHook(event)

  def OnStcChange(self, event):
    self.GetParent().OnStcChange(event)
class PsycolliderCodeWin(wx.MDIChildFrame):
  def __init__ (self,parent,ID,title,pos=wx.DefaultPosition,size=wx.DefaultSize):
    wx.MDIChildFrame.__init__(self,parent,ID,title,pos,size)
    self.codeSubWin = PsycolliderCodeSubWin(self)
    self.isModified = 0
    self.originalFilePath = ""
    self.Bind(wx.EVT_CLOSE, self.OnCloseWindow)  
    # TODO : have users able to directly type in the window when it's created
  def GetSelectedText(self):
    return self.codeSubWin.GetSelectedText()
  def GetCurLineAsString(self):
    return self.codeSubWin.GetCurLine()
  def OnStcChange(self, event):
    if not self.isModified:
      self.originalTitle = self.GetTitle()
      self.SetTitle(self.originalTitle + "*")
      self.isModified = 1
  def OnCloseWindow(self,event):
    if not self.GetParent().IsAllowedToCloseWindow(self):
      event.Veto()
    else:
      self.Destroy()
  def SetSubWinFocus(self):
    self.codeSubWin.SetFocus()
  def SelectRange(self,rangeStart,rangeSize):
    self.codeSubWin.SetSelection(rangeStart,rangeStart+rangeSize)
    
class PsycolliderLogWindow(wx.MDIChildFrame):
  def __init__ (self,parent,ID,title,pos=wx.DefaultPosition,size=wx.DefaultSize):
    wx.MDIChildFrame.__init__(self,parent,ID,title,pos,size)
    self.logSubWin = wx.TextCtrl(self,style = wx.TE_MULTILINE | wx.TE_READONLY )
  
class PsycolliderRTFWin(wx.MDIChildFrame):
  """ this class is not really able to display the SC help files properly """
  def __init__ (self,parent,ID,title,pos=wx.DefaultPosition,size=wx.DefaultSize):
    wx.MDIChildFrame.__init__(self,parent,ID,title,pos,size)
    self.rtfSubWin = PsycolliderRTFSubWin(self)
  def GetSelectedText(self):
    return self.rtfSubWin.GetStringSelection()
  def GetCurLineAsString(self):
    posInText = self.rtfSubWin.GetInsertionPoint()
    (x,y) = self.rtfSubWin.PositionToXY(posInText)
    return self.rtfSubWin.GetLineText(y)
  def SetSubWinFocus(self):
    self.rtfSubWin.SetFocus()
   
class PsycolliderMainFrame(wx.MDIParentFrame):
  def __init__ (self,parent,ID,title,pos=wx.DefaultPosition,size=wx.DefaultSize, style = wx.DEFAULT_FRAME_STYLE | wx.VSCROLL | wx.HSCROLL, name = "frame"):
    wx.MDIParentFrame.__init__(self,parent,ID,title,pos,size,style)
    self.winCount = 0

    # menu creation 
    menu = wx.Menu()
    menu.Append(ID_NewCodeWin, "&New Code Window...\tCtrl+N")
#    spacing seems unequal here, but comes out okay when compiled, any ideas??
#    menu.Append(ID_StartServer, "&Start Server")
#    menu.Append(ID_StopServer, "&Stop Server")
    menu.Append(ID_OpenFile, "&Open File...\tCtrl+O")
    menu.Append(ID_SaveFile, "&Save File...\tCtrl+S")
    menu.Append(ID_SaveFileAs, "Save File &As...\tCtrl+Shift+S")
    
    menu.AppendSeparator()
    
    menu.Append(ID_CloseCodeWin, "Close &Window...\tCtrl+W") # yssr

    menu.AppendSeparator()
    menu.Append(ID_Exit, "E&xit\tAlt+F4")

    menuLang = wx.Menu()
    menuLang.Append(ID_Lang_Stop_Server,"Stop Server")
    menuLang.Append(ID_Lang_Run,"Run\tAlt+R")
    menuLang.Append(ID_Lang_Stop,"Stop\tAlt+.")
    menuLang.Append(ID_Lang_CompileLibrary,"Compile Library\tAlt+K")
    menuLang.Append(ID_Lang_OpenClassDef,"Open Class Def\tAlt+J")
    menuLang.Append(ID_Lang_ImplementationsOf,"Implementations of\tAlt+Y")
    menuLang.Append(ID_Lang_ReferencesTo,"References to\tShift+Alt+Y")
    menuLang.Append(ID_EvalSelection , "&Evaluate Selection\tCtrl+Enter")
    menuLang.Append(ID_Go_To_Help_File , "&Go To Help File\tF1")

    menu2 = wx.Menu()
    menu2.Append(ID_AccelF2, "Simulate\tF&2")
    menu2.Append(ID_AccelF3, "Simulate\tF&3")
    menu2.Append(ID_AccelF4, "Simulate\tF&4")
    menu2.Append(ID_AccelF5, "Simulate\tF&5")
    menu2.Append(ID_AccelF6, "Simulate\tF&6")
    menu2.Append(ID_AccelF7, "Simulate\tF&7")
    menu2.Append(ID_AccelF8, "Simulate\tF&8")
    menu2.Append(ID_AccelF9, "Simulate\tF&9")
    menu2.Append(ID_AccelF10, "Simulate\tF10")
    menu2.Append(ID_AccelF11, "Simulate\tF11")
    menu2.Append(ID_AccelF12, "Simulate\tF12")

    menubar = wx.MenuBar()
    menubar.Append(menu, "&File")
    menubar.Append(menuLang, "&Lang")
    menubar.Append(menu2, "&Debug")
    self.SetMenuBar(menubar)

    self.CreateStatusBar()

    self.Bind(wx.EVT_MENU, self.OnNewCodeWindow, id=ID_NewCodeWin)
    self.Bind(wx.EVT_MENU, self.OnExit, id=ID_Exit)
#    self.Bind(wx.EVT_MENU, self.OnStartServer, id=ID_StartServer)
#    self.Bind(wx.EVT_MENU, self.OnStopServer, id=ID_StopServer)
    self.Bind(wx.EVT_MENU, self.OnOpenFile, id=ID_OpenFile)
    self.Bind(wx.EVT_MENU, self.OnSaveFile, id=ID_SaveFile)
    self.Bind(wx.EVT_MENU, self.OnSaveFileAs, id=ID_SaveFileAs)
    self.Bind(wx.EVT_MENU, self.OnCloseCodeWin, id=ID_CloseCodeWin) # yssr
    self.Bind(wx.EVT_MENU, self.OnAccelF2, id=ID_AccelF2)
    self.Bind(wx.EVT_MENU, self.OnAccelF3, id=ID_AccelF3)
    self.Bind(wx.EVT_MENU, self.OnAccelF4, id=ID_AccelF4)
    self.Bind(wx.EVT_MENU, self.OnAccelF5, id=ID_AccelF5)
    self.Bind(wx.EVT_MENU, self.OnAccelF6, id=ID_AccelF6)
    self.Bind(wx.EVT_MENU, self.OnAccelF7, id=ID_AccelF7)
    self.Bind(wx.EVT_MENU, self.OnAccelF8, id=ID_AccelF8)
    self.Bind(wx.EVT_MENU, self.OnAccelF9, id=ID_AccelF9)
    self.Bind(wx.EVT_MENU, self.OnAccelF10, id=ID_AccelF10)
    self.Bind(wx.EVT_MENU, self.OnAccelF11, id=ID_AccelF11)
    self.Bind(wx.EVT_MENU, self.OnAccelF12, id=ID_AccelF12)


    self.Bind(wx.EVT_MENU, self.OnEvalSelection, id=ID_EvalSelection)
    self.Bind(wx.EVT_MENU, self.OnGotoHelpFile, id=ID_Go_To_Help_File)

    self.Bind(wx.EVT_MENU, self.OnStopServer, id=ID_Lang_Stop_Server)
    self.Bind(wx.EVT_MENU, self.On_Lang_Run, id=ID_Lang_Run)
    self.Bind(wx.EVT_MENU, self.On_Lang_Stop, id=ID_Lang_Stop)
    self.Bind(wx.EVT_MENU, self.On_Lang_CompileLibrary, id=ID_Lang_CompileLibrary)
    self.Bind(wx.EVT_MENU, self.On_Lang_OpenClassDef, id=ID_Lang_OpenClassDef)
    self.Bind(wx.EVT_MENU, self.On_Lang_ImplementationsOf, id=ID_Lang_ImplementationsOf)
    self.Bind(wx.EVT_MENU, self.On_Lang_ReferencesTo, id=ID_Lang_ReferencesTo)

    self.Bind(wx.EVT_CLOSE, self.OnCloseWindow)  
    
    accelTableEntries = []
    # F KEYS
    accelTableEntries.append(wx.AcceleratorEntry(wx.ACCEL_NORMAL,wx.WXK_F2,ID_AccelF2))
    accelTableEntries.append(wx.AcceleratorEntry(wx.ACCEL_NORMAL,wx.WXK_F3,ID_AccelF3))
    accelTableEntries.append(wx.AcceleratorEntry(wx.ACCEL_NORMAL,wx.WXK_F4,ID_AccelF4))
    accelTableEntries.append(wx.AcceleratorEntry(wx.ACCEL_NORMAL,wx.WXK_F5,ID_AccelF5))
    accelTableEntries.append(wx.AcceleratorEntry(wx.ACCEL_NORMAL,wx.WXK_F6,ID_AccelF6))
    accelTableEntries.append(wx.AcceleratorEntry(wx.ACCEL_NORMAL,wx.WXK_F7,ID_AccelF7))
    accelTableEntries.append(wx.AcceleratorEntry(wx.ACCEL_NORMAL,wx.WXK_F8,ID_AccelF8))
    accelTableEntries.append(wx.AcceleratorEntry(wx.ACCEL_NORMAL,wx.WXK_F9,ID_AccelF9))
    accelTableEntries.append(wx.AcceleratorEntry(wx.ACCEL_NORMAL,wx.WXK_F10,ID_AccelF10))
    accelTableEntries.append(wx.AcceleratorEntry(wx.ACCEL_NORMAL,wx.WXK_F11,ID_AccelF11))
    accelTableEntries.append(wx.AcceleratorEntry(wx.ACCEL_NORMAL,wx.WXK_F12,ID_AccelF12))
    # FILE
    accelTableEntries.append(wx.AcceleratorEntry(wx.ACCEL_CTRL,ord('N'),ID_NewCodeWin))
    accelTableEntries.append(wx.AcceleratorEntry(wx.ACCEL_CTRL,ord('O'),ID_OpenFile))
    accelTableEntries.append(wx.AcceleratorEntry(wx.ACCEL_CTRL,ord('S'),ID_SaveFile))
    accelTableEntries.append(wx.AcceleratorEntry(wx.ACCEL_CTRL,ord('W'),ID_CloseCodeWin)) # yssr
    accelTableEntries.append(wx.AcceleratorEntry(wx.ACCEL_CTRL | wx.ACCEL_SHIFT ,ord('S'),ID_SaveFileAs))
    # EVAL & HELP
    accelTableEntries.append(wx.AcceleratorEntry(wx.ACCEL_CTRL ,wx.WXK_RETURN,ID_EvalSelection))
    accelTableEntries.append(wx.AcceleratorEntry(wx.ACCEL_CTRL ,wx.WXK_NUMPAD_ENTER,ID_EvalSelection))
    accelTableEntries.append(wx.AcceleratorEntry(wx.ACCEL_NORMAL,wx.WXK_DECIMAL,ID_Lang_Stop))
    accelTableEntries.append(wx.AcceleratorEntry(wx.ACCEL_NORMAL,wx.WXK_F1,ID_Go_To_Help_File))
    
    accelTable = wx.AcceleratorTable(accelTableEntries)
    self.SetAcceleratorTable(accelTable)
    
    try:
      # CUSTOMIZE : add a list of files to open here. just modify the next line
      # with another file name (and duplicate the line for more file names)
      self.OpenFile("C:\\Documents and Settings\\golinvauxb\\Bureau\\____FOR SCWIN USERS____\\STUFF TO TRY\\test808.sc")
      self.OpenFile("C:\\Documents and Settings\\golinvauxb\\Bureau\\____FOR SCWIN USERS____\\STUFF TO TRY\\test1.sc")  
      self.OpenFile("C:\\Documents and Settings\\golinvauxb\\Bureau\\____FOR SCWIN USERS____\\STUFF TO TRY\\midi in test.sc")  
    except:
      pass

  def OnChildCharHook(self,event):
    #if event.GetKeyCode() == 0x0a and event.ControlDown( ):  # CTRL+RETURN == 0x0a
    #  self.Eval( ) # evt is useless here
    #elif event.GetKeyCode() == 0x2e and event.AltDown( ):
    if event.GetKeyCode() == "r" and event.AltDown( ): # '.'
      self.On_Lang_Run(None) 
    if event.GetKeyCode() == 0x2e and event.AltDown( ):
      self.On_Lang_Stop(None) 
    if event.GetKeyCode() == "k" and event.AltDown( ):
      self.On_Lang_CompileLibrary(None) 
    if event.GetKeyCode() == "j" and event.AltDown( ):
      self.On_Lang_OpenClassDef(None) 
    if event.GetKeyCode() == "y" and event.AltDown( ):
      self.On_Lang_ImplementationsOf(None) 
    if event.GetKeyCode() == "y" and event.AltDown( ) and event.ShiftDown( ):
      self.On_Lang_ReferencesTo(None) 
    else:
      event.Skip( )
    

  def OnChar(self,event):
  #  if event.GetKeyCode() == 0x0a and event.ControlDown( ):  # CTRL+RETURN == 0x0a
  #    self.Eval( ) # evt is useless here
  #  elif event.GetKeyCode() == 0x2e and event.AltDown( ):
  #    self.LangStop( )
  #  else:
    event.Skip( )
    pass
    
  def Eval(self):
    self.SendSelection("interpretPrintCmdLine")
  
  def On_Lang_Run(self,evt):
    PySCLang.sendMain("run");

  def On_Lang_Stop(self,evt):
    PySCLang.sendMain("stop");

  def On_Lang_CompileLibrary(self,evt):
    PySCLang.compileLibrary()

  def On_Lang_OpenClassDef(self,evt):
    self.SendSelection("openWinCodeFile")

  def On_Lang_ImplementationsOf(self,evt):
    self.SendSelection("methodTemplates")

  def On_Lang_ReferencesTo(self,evt):
    self.SendSelection("methodReferences")
    
  def SendSelection(self,methodName):
    if not PySCLang.compiledOK():
      return None
    activeChild = self.GetActiveChild()
    if activeChild == self.logWin:
      return None
    sel = activeChild.GetSelectedText();
    if sel == "" :
      # this means nothing was selected... retrieve current line instead
      selTuple = activeChild.GetCurLineAsString( )
      sel = selTuple[0]  
    # this is where unicode -> string conversion occurs...
    PySCLang.setCmdLine(str(sel))
    PySCLang.sendMain(methodName)
      
  def OnOpenFile(self,evt):
    fileDlg = wx.FileDialog(self,style=wx.OPEN)
    if fileDlg.ShowModal( ) == wx.ID_OK:
      path = fileDlg.GetPath()
      self.OpenFile(path)

  def OnCloseCodeWin(self,evt): # yssr -added new def
    activeWin = self.GetActiveChild( )
    if activeWin == None:
      # TODO : disable menu items dynamically instead 
      wx.MessageBox("ERROR : No document is active")
    elif not activeWin == self.logWin:
      if self.IsAllowedToCloseWindow(activeWin):
        activeWin.Destroy();

  def IsAllowedToCloseWindow(self,win):
    if win.isModified:
      if win.originalFilePath == "":
        dlg = wx.MessageDialog(self,"Do you want to save %s ? " % win.originalTitle,"Psycollider",wx.CANCEL | wx.YES_NO)
        reply = dlg.ShowModal( );
        if reply == wx.ID_YES:
          return self.OnSaveFileAsInWin(None,win)
        elif reply == wx.ID_NO:
          return 1
        elif reply == wx.ID_CANCEL:
          return 0
      else:
        dlg = wx.MessageDialog(self,"Do you want to save %s ?" % win.originalFilePath,"Psycollider",wx.CANCEL | wx.YES_NO)
        reply = dlg.ShowModal( );
        if reply == wx.ID_YES:
          #try:
          self.OnSaveFileInWin(None,win)
          #except:
          #  wx.MessageBox("Cannot save file","Error",wx.OK | wx.ICON_ERROR)
          #  return 0
          return 1
        elif reply == wx.ID_NO:
          return 1
        elif reply == wx.ID_CANCEL:
          return 0
    else:
      return 1
    
  def OpenFile(self,path):
      child = self.GetActiveChild()
      if child == None:
        maximizeNewWindow = False
      else:
        maximizeNewWindow = child.IsMaximized()
      file = open(path ,"r")
      textContent = file.read()
      file.close()
      if textContent[0:5] == '{\\rtf':
        win = self.OnNewRTFWindow(None)
        win.rtfSubWin.LoadFile(path)
        courierFont = wx.Font(10,wx.MODERN,wx.NORMAL,wx.NORMAL,False,"Courier New")
        textAttr = wx.TextAttr(wx.NullColour, wx.NullColour, courierFont)
        textAttr.SetFlags(wx.TEXT_ATTR_FONT_SIZE)
        #win.rtfSubWin.SetStyle(0,win.rtfSubWin.GetLastPosition(), textAttr)
        # we first need to convert rtf to something better... 
        #win = self.OnNewCodeWindow(None)
        #newTextContent = PySCLang.Rtf2Ascii(textContent) <--- this looks very bad
        #win.codeSubWin.AddText(newTextContent)
      else :
        win = self.OnNewCodeWindow(None)
        win.codeSubWin.AddText(textContent)
      win.originalFilePath = path 
      win.SetTitle(path)
      if maximizeNewWindow :
        win.Maximize(True)
      win.isModified = 0
      win.SetSubWinFocus()
      return win
  
  def OnSaveFile(self,evt):
    activeWin = self.GetActiveChild( );
    self.OnSaveFileInWin(evt,activeWin) # yssr

  def OnSaveFileInWin(self,evt,activeWin):
    if activeWin == self.logWin: return None # yssr
    if activeWin == None:
      # TODO : disable menu items dynamically instead 
      wx.MessageBox("ERROR : No document is active")
    else:
      # fileDlg = wx.FileDialog(self,style=wx.SAVE)
      path = activeWin.originalFilePath
      # path = fileDlg.GetPath()
      if path == "":
        self.OnSaveFileAsInWin(evt,activeWin)
      else:
        file = open(path ,"w" )
        content = activeWin.codeSubWin.GetText()
        file.write(content)
        file.close()
        activeWin.SetTitle(path) # yssr
        activeWin.isModified = 0 # yssr

  def OnSaveFileAs(self,evt):
    activeWin = self.GetActiveChild( );
    self.OnSaveFileAsInWin(evt,activeWin)

  def CreateLogWindow(self):
    self.logWin = PsycolliderLogWindow(self, -1, "SC Log")
    self.logWin.Show(True)
    PySCLang.setSCLogSink(WriteInLogWindow)

  def OnSaveFileAsInWin(self,evt,activeWin):
    if activeWin == None:
      # TODO : disable menu items dynamically instead 
      wx.MessageBox("ERROR : No document is active")
    else:
      fileDlg = wx.FileDialog(self,style=wx.SAVE)
      if fileDlg.ShowModal( ) == wx.ID_OK:
        path = fileDlg.GetPath()
        file = open(path ,"w" )
        content = activeWin.codeSubWin.GetText()
        file.write(content)
        file.close()
        activeWin.originalFilePath = path # yssr
        activeWin.SetTitle(path) # yssr
        activeWin.isModified = 0 # yssr

  def OnAccelF2(self,evt):
    #wx.MessageBox("OnAccelF2")
    self.OnArrangeWindows(evt)

  def OnAccelF3(self,evt):
    wx.MessageBox("OnAccelF3")

  def OnAccelF4(self,evt):
    wx.MessageBox("OnAccelF4")

  def OnAccelF5(self,evt):
    wx.MessageBox("OnAccelF5")

  def OnAccelF6(self,evt):
    wx.MessageBox("OnAccelF6")

  def OnAccelF7(self,evt):
    wx.MessageBox("OnAccelF7")

  def OnAccelF8(self,evt):
    wx.MessageBox("OnAccelF8")

  def OnAccelF9(self,evt):
    wx.MessageBox("OnAccelF9")

  def OnAccelF10(self,evt):
    wx.MessageBox("OnAccelF10")

  def OnAccelF11(self,evt):
    wx.MessageBox("OnAccelF11")

  def OnAccelF12(self,evt):
    wx.MessageBox("OnAccelF12")

  def OnEvalSelection(self,evt):
    self.Eval()

  def OnLangStop(self,evt):
    self.Stop()
    
  def OnGotoHelpFile(self,evt):
    self.GoToHelpFile()
  
  def OnExit(self, evt):
    self.Close(True)

  def OnCloseWindow(self, event):
    # TODO : make sure users are asked to save docs !!! deal with rtf file saving
    shouldVeto = 0
    for win in self.GetChildren():
      if type(win) == PsycolliderCodeWin:
        if not self.IsAllowedToCloseWindow(win):
          shouldVeto = 1
          break
      
    if shouldVeto:
      event.Veto()
    else:
      self.Destroy()

  def OnStartServer(self, event):
    self.StartServer()

  def OnStopServer(self, event):
    self.StopServer()
  
  def StartServer(self):
    pass

  def StopServer(self):
    PySCLang.setCmdLine('s.sendMsg("/quit");')
    PySCLang.sendMain("interpretPrintCmdLine")
    pass
    
  def OnArrangeWindows(self, evt):
    currentlyActive = self.GetActiveChild()
    clientRect = self.GetClientSize()
    codeLeft = 0
    codeWidth = clientRect[0] - 4
    codeTop = 0
    codeHeight = (clientRect[1]*2)/3
    logLeft = 0
    logWidth = clientRect[0] - 4
    logTop = (clientRect[1]*2)/3
    logHeight = (clientRect[1])/3 - 3
    for win in self.GetChildren():
      if type(win) == PsycolliderLogWindow:
        win.SetDimensions(logLeft,logTop,logWidth,logHeight)
      else:
        win.SetDimensions(codeLeft,codeTop,codeWidth,codeHeight)

  def OnNewCodeWindow(self, evt):
    self.winCount = self.winCount + 1
    win = PsycolliderCodeWin(self, -1, "Untitled %d" % self.winCount)
    win.Show(True)
    win.SetSubWinFocus()
    return win

  def OnNewRTFWindow(self, evt):
    self.winCount = self.winCount + 1
    win = PsycolliderRTFWin(self, -1, "Child Window: %d" % self.winCount)
    #canvas = ScrolledWindow.MyCanvas(win)
    win.Show(True)
    win.SetSubWinFocus()
    return win

  def GoToHelpFile(self):
    # TODO : test this : most help files don't open. remove trailing and leading spaces from sel, too, since wxTextCtrl is behaving strangely
    activeChild = self.GetActiveChild()
    if not activeChild == self.logWin: # yssr
      sel = string.strip(str(activeChild.GetSelectedText()))
    else : sel = ""                    # yssr
    foundFilePath = ""
    filePath = ""
    if   sel == "-" : sel = "subtraction"                 # "subtraction.rtf"
    elif sel == "/" : sel = "division"                    # "division.rtf"
    elif sel == "*" : sel = "(W32) multiplication"        # from "*.rtf"
    elif sel == "**": sel = "(W32) exponentiation"        # from "**.rtf"
    elif sel == "<" : sel = "(W32) less than"             # from "<.rtf"
    elif sel == "<=": sel = "(W32) less than or equal"    # from "<=.rtf"
    elif sel == ">" : sel = "(W32) greater than"          # from ">.rtf"
    elif sel == ">=": sel = "(W32) greater than or equal" # from ">=.rtf"
    if sel != "":
      for helpFolder in [gHelpFolder, os.path.expanduser(gUserExtensionFolder)]:
        for folderPath, foldersInPath, fileNamesInFolder in os.walk(helpFolder):
        # don't visit CVS directories
          if 'CVS' in foldersInPath:
            foldersInPath.remove('CVS')  
          for fileName in fileNamesInFolder:
            filePath = os.path.join(folderPath, fileName)
            if fileName == sel + ".help.rtf":
              foundFilePath = filePath
              break
            if fileName == sel + ".rtf":
              foundFilePath = filePath
              break
          # for fileName
          # if file is found, let's break
          if foundFilePath != "":
            break
        # for folderPath, ....
        # if file is found, let's break
        if foundFilePath != "":
          break
    if foundFilePath == "":     
      foundFilePath = os.path.join(gHelpFolder,"Help.help.rtf")
    self.OpenFile(foundFilePath)
    

# Every wxWindows application must have a class derived from wxApp


class PsycolliderApp(wx.App):
  # wxWindows calls this method to initialize the application
  def OnInit(self):
    # Create an instance of our customized Frame class
    frame = PsycolliderMainFrame(None, -1, "PsyCollider", wx.DefaultPosition, wx.Size(400,400))
    frame.Show(1)

    # Tell wxWindows that this is our main window
    self.SetTopWindow(frame)
    
    #this creates a log window and tells PySCLang about it
    frame.CreateLogWindow( )
        
    self.theMainFrame = frame
    
    PySCLang.setPyPrOpenWinTextFile(OpenTextFile)
    
    self.ChangeDirToSCClassLibraryFolder()

    # start the sc lang interpreter
    PySCLang.start( )
    
    (addr,port) = self.GetServerAddressAndPort()
    
    # TODO : "s.serverRunning=true;" is a temp hack for lack of proper boot sequence....
    PySCLang.setCmdLine('s.initTree;s.serverRunning=true;') 
    PySCLang.sendMain('interpretPrintCmdLine')
    
    # Return a success flag
    return 1

  def OnProut(self):
    pass
    
    
  def GetServerAddressAndPort(self):
    return ("127.1.0.1","57110")
     
  def ChangeDirToSCClassLibraryFolder(self):
    # first, we check if the current working folder
    # contains an item called 'SCClassLibrary'
    curPath = os.getcwd()
    listOfFolders = os.listdir(curPath)

    # if the cwd contains 'SCClassLibrary', we're done
    if 'SCClassLibrary' in listOfFolders:
      return None
      
    # then, we try to retrieve the SCClassLibrary folder
    # from the registry
    config  = wx.Config("Psycollider")

    # uniqueName is what gets returned from config.Read(...) 
    # if nothing was stored in the config yet
    uniqueName = "{1FB0EC09-A883-4684-AD73-1D49A98A89DE}" 
    classLibPath = config.Read("SCClassLibraryPath",uniqueName)
    leafName = (os.path.split(classLibPath))[1]

    # if the folder stored in the reg is actually an existing
    # folder called 'SCClassLibrary', we change cwd to that 
    # folder and we're done
    if os.path.isdir(classLibPath) and leafName == 'SCClassLibrary':
      classLibPath_split = os.path.split(classLibPath)
      classLibParentFolder = classLibPath_split[0]
      os.chdir(classLibParentFolder)
      return None
      
    # if something was stored in the registry, but does not exist
    # anymore or is not correct, let's warn the user
    if classLibPath != uniqueName:
      wx.MessageBox("The path stored in the application preferences is not a valid SCClassLibrary folder. You will now be requested to select an existing SCClassLibrary folder","Error", wx.OK | wx.ICON_ERROR)

    # ask the user to locate the folder
    continueLookingForFolder = True
    classLibFolderFound = False
    while continueLookingForFolder:
      dlg = wx.DirDialog(None,"Please locate the SCClassLibrary")
      if dlg.ShowModal( ) == wx.ID_CANCEL:
        wx.MessageBox("Sorry. No class library available. Psycollider will not work correctly","Error", wx.OK | wx.ICON_ERROR)
        continueLookingForFolder = False
      else:
        classLibPath = dlg.GetPath( )
        leafName = (os.path.split(classLibPath))[1]
        if leafName != 'SCClassLibrary':
          wx.MessageBox("The folder needs to be called SCClassLibrary for Psycollider to work correctly","Error", wx.OK | wx.ICON_ERROR)
        else:
          continueLookingForFolder = False
          classLibFolderFound = True

    # only if a valid SCClassLibrary folder was found, then 
    # set the current folder as its parent
    if classLibFolderFound:
      config.Write("SCClassLibraryPath",classLibPath)
      classLibPath_split = os.path.split(classLibPath)
      classLibParentFolder = classLibPath_split[0]
      os.chdir(classLibParentFolder)
    return None
      
                     
def OpenTextFile(path,rangeStart,rangeSize):
  if wx.GetApp().theMainFrame == None:
    wx.MessageBox("Cannot open %s since the main window is not created yet","Error",wx.OK | wx.ICON_ERROR)
  else:
    codeWin = wx.GetApp().theMainFrame.OpenFile(path)
    codeWin.SelectRange(rangeStart,rangeSize)

def WriteInLogWindow(text):
  if wx.GetApp().theMainFrame == None:
    sys.stdout.write(text)
  else:
    wx.GetApp().theMainFrame.logWin.logSubWin.AppendText(text)


#---------------------------------------------------------------------------


app = PsycolliderApp(0)     # Create an instance of the application class
app.MainLoop()     # Tell it to start processing events


    
    


