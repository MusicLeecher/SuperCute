{\rtf1\mac\ansicpg10000\cocoartf824\cocoasubrtf330
{\fonttbl\f0\fswiss\fcharset77 Helvetica;\f1\fswiss\fcharset77 Helvetica-Bold;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red0\green0\blue191;\red191\green0\blue0;
\red96\green96\blue96;\red0\green115\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs30 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b\fs28 \cf0 Triggering functions from the Keyboard\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b0\fs30 \cf0 \

\fs24 \cf0 Drag Functions to keys in the window.\
Typing keys will execute the Function.\
If the Function returns another Function, the new Function will\
replace the action of a key.
\fs30 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf2 \
(\
\cf3 var\cf2  w; \cf4 // window object\cf2 \
\cf3 var\cf2  courier; \cf4 // font object\cf2 \
\
\cf4 // an Array of Strings representing the key layout.\cf2 \
\cf3 var\cf2  keyboard = #[\cf5 "`1234567890-="\cf2 , \cf5 "QWERTYUIOP[]\\\\"\cf2 , \
							\cf5 "ASDFGHJKL;'"\cf2 , \cf5 "ZXCVBNM,./"\cf2 ];\
\
\cf4 // horizontal offsets for keys.\cf2 \
\cf3 var\cf2  offsets = #[42, 48, 57, 117];\
\
\cf3 var\cf2  actions; \cf4 // an IdentityDictionary mapping keys to action functions.\cf2 \
\cf3 var\cf2  makeKey; \cf4 // function to create an SCDragSink for a key.\cf2 \
\
courier = \cf3 Font\cf2 (\cf5 "Courier-Bold"\cf2 , 14);\
\
\cf4 // an IdentityDictionary is used to map keys to functions so that\cf2 \
\cf4 // we can look up the action for a key\cf2 \
actions = \cf3 IdentityDictionary\cf2 .new; \cf4 // create actions dictionary\cf2 \
\
\cf4 // define a function that will create an SCDragSink for a key.\cf2 \
makeKey = \{\cf3 |char, keyname, bounds|\cf2 \
	\cf3 var\cf2  v;\
\
	keyname = keyname ? char.asString;\
	bounds = bounds ? (24 @ 24);\
\
	v = \cf3 SCDragBoth\cf2 (w, bounds);\
	v.font = courier;\
	v.string = keyname;\
	v.align = \cf6 \\center\cf2 ;\
	v.setBoth = \cf3 false\cf2 ;\
	v.canReceiveDragHandler = \{\
		\cf3 SCView\cf2 .currentDrag.isKindOf(\cf3 Function\cf2 )\
	\};\
	v.action = \{ \
		(\cf5 "added key action : "\cf2  ++ keyname).postln;\
		if (char.isAlpha) \{\
			actions[char.toUpper] = v.object;\
			actions[char.toLower] = v.object;\
		\}\{\
			actions[char] = v.object;\
		\};\
		w.front;\
	\};\
\};\
\
w = \cf3 SCWindow\cf2 (\cf5 "keyboard"\cf2 , \cf3 Rect\cf2 (128, 320, 420, 150));\
\
w.view.decorator = \cf3 FlowLayout\cf2 (w.view.bounds);\
\
\cf4 // define a function to handle key downs.\cf2 \
w.view.keyDownAction = \{\cf3 |view, char, modifiers, unicode, keycode|\cf2 \
	 \cf3 var\cf2  result;\
	 \
	\cf4 // call the function\cf2 \
	result = actions[char].value(char, modifiers);\
	\
	\cf4 // if the result is a function, that function becomes the \cf2 \
	\cf4 // new action for the key\cf2 \
	if (result.isKindOf(\cf3 Function\cf2 )) \{\
		actions[char] = result;\
	\};\
\};\
\
\cf4 // make the rows of the keyboard\cf2 \
keyboard.do \{\cf3 |row, i|\cf2  \
	row.do \{\cf3 |key|\cf2  makeKey.(key) \};\
	if (i==0) \{ makeKey.(127.asAscii, \cf5 "del"\cf2 , 38 @ 24) \};\
	if (i==2) \{ makeKey.($\\r, \cf5 "retrn"\cf2 , 46 @ 24) \};\
	w.view.decorator.nextLine;\
	w.view.decorator.shift(offsets[i]);\
\};\
\
\cf4 // make the last row\cf2 \
makeKey.($ , \cf5 "space"\cf2 , 150 @ 24);\
makeKey.(3.asAscii, \cf5 "enter"\cf2 , 48 @ 24);\
\
w.front;\
)\
\
\
\
\
\cf4 ////////////////////\cf2 \
\
\cf4 // Drag these things to the keyboard to test it.\cf2 \
\
(\
\{\
	\cf3 var\cf2  synth, original;\
	original = \cf3 thisFunction\cf2 ;\
	synth = \{ \cf3 SinOsc\cf2 .ar(exprand(500,1200),0,0.2) \}.play;\
	\{ synth.free; original \}\
\}\
)\
\
\
(\
\{\
	\{ \
		\cf3 Pan2\cf2 .ar(\
			\cf3 SinOsc\cf2 .ar(\
				\cf3 ExpRand\cf2 (300,3000), \
				0,\
				\cf3 SinOsc\cf2 .kr(\cf3 ExpRand\cf2 (1,15),0,0.05).max(0)), \
			\cf3 Rand\cf2 (-1,1)) \
	\}.play;\
\}\
)\
\
\{ s.sendMsg(\cf6 \\n_free\cf2 , \cf6 \\h\cf2 , 0); \} \cf4 // kill head\cf2 \
\
\{ s.sendMsg(\cf6 \\n_free\cf2 , \cf6 \\t\cf2 , 0); \} \cf4 // kill tail\cf2 \
\
(\
\{\{\
	\cf3 var\cf2  eg, o, freq, noise;\
	eg = \cf3 EnvGen\cf2 .kr(\cf3 Env\cf2 .linen(0.1,2,0.4,0.2), doneAction: 2);\
	freq = \cf3 Rand\cf2 (600,1200);\
	noise = \{\cf3 LFNoise2\cf2 .ar(freq*0.1, eg)\}.dup;\
	o = \cf3 SinOsc\cf2 .ar(freq,0,noise);\
	\cf3 Out\cf2 .ar(0, o);\
\}.play\})\
\
\
(\
\{\{\
	\cf3 var\cf2  in, sr;\
    in = \cf3 LFSaw\cf2 .ar([21000,21001], 0, \cf3 LFPulse\cf2 .kr(\cf3 ExpRand\cf2 (0.1,1),0,0.3,0.2,0.02));\
    sr = \cf3 ExpRand\cf2 (300,3000) + [-0.6,0.6];\
	\cf3 Out\cf2 .ar(0,  \cf3 RLPF\cf2 .ar(in * \cf3 LFPulse\cf2 .ar(sr, 0, \cf3 MouseY\cf2 .kr(0.01, 0.99)), sr * (\cf3 LFPulse\cf2 .kr(\cf3 ExpRand\cf2 (0.1,12),0,0.4,0.2,0.2) + \cf3 LFPulse\cf2 .kr(\cf3 ExpRand\cf2 (0.1,12),0,0.7,0.2)), 0.1));\
\}.play;\})\
\
(\
\{\{ \cf3 var\cf2  in;\
	in = \cf3 In\cf2 .ar(0,2);\
	\cf3 ReplaceOut\cf2 .ar(0, \cf3 CombN\cf2 .ar(in, 0.24, 0.24, 8, 1, in.reverse).distort);\
\}.play\})\
\
(\
\{\{ \cf3 var\cf2  in;\
	in = \cf3 In\cf2 .ar(0,2);\
	\cf3 ReplaceOut\cf2 .ar(0, in * \cf3 SinOsc\cf2 .ar(\cf3 MouseX\cf2 .kr(2,2000,1)));\
\}.play\})\
\
}