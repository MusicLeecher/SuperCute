{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue191;\red0\green115\blue0;
\red96\green96\blue96;\red0\green0\blue0;\red0\green0\blue191;\red96\green96\blue96;\red191\green0\blue0;
\red0\green115\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 SuperCollider 3 Server Tutorial\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 \
To follow this tutorial you should read \
\
	
\f0\b Server-Architecture\

\f1\b0 and\
	
\f0\b Server-Command-Reference\
	
\f1\b0 \
This tutorial also assumes that you are familiar with SuperCollider version 2 since the creating a SynthDef in SC3 is very similar to creating a Synth in SC2.\
\
There are two parts to SuperCollider. One part is the language application and another is  a synthesis server that can run either inside the language application, or as a separate program on the same machine, or run on a different computer across a network connection. The language application sends command messages to the server using a subset of the Open Sound Control protocol.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 Booting a Server\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 \
In order to run sound we need to start a server running. The easiest way to start a server is to click on one of the "Start Server" buttons in the server windows. Sometimes though it is useful to start a server programmatically. To do this we need to get or create a server object and tell it to "boot". Two servers, internal and local, are predefined.\
\
The internal server runs in the same process as the SuperCollider application.  It is internal to the program itself.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf2 // set the interpreter variable s to the internal server object.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 s = \cf3 Server\cf0 .internal;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 VERY IMPORTANT: 
\f1\b0\fs24 This line must be executed for the variable 's' to be set. The mechanics are different depending on your platform. The MacOSX standard is to place the cursor anywhere on this line and press the "Enter" key on the numeric keypad. Pressing the main return key does not execute code! This allows you to write code fragments of multiple lines. To execute a multi-line block of code, select the block and press "Enter." For convenience, a code block can be enclosed in parentheses, and the entire block selected by double-clicking just inside either parenthesis. (For linux or Windows instructions, consult the documentation specific to that platform.)\
\
The local server runs on the same machine as the SuperCollider application, but is a separate program, 'scsynth'. 
\f0\b Note:
\f1\b0  By default the interpreter variable s is set to the local server at startup. For further information see the 
\f0\b Server
\f1\b0  helpfile.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf2 // set the interpreter variable s to the local server object.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 s = \cf3 Server\cf0 .local;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
To boot the server you send it the boot message.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf3 s\cf0 .boot;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
To quit the server send it the quit message.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf3 s\cf0 .quit;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
We can also create a server to run. To create a server object we need to provide the IP address or the server and a port number. Port numbers are somewhat arbitrary but they should not conflict with common protocols like telnet, ftp http, etc. The IP address 127.0.0.1 is defined to mean the local host. This is the IP address to use for running a server on your own machine.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf2 // create a server object that will run on the local host using port #58009\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 s = \cf3 Server\cf0 (\cf4 \\myServer\cf0 , \cf3 NetAddr\cf0 (\cf5 "127.0.0.1"\cf0 , 58009)); \
\
s.boot; \cf2 //start the server\
\cf0 \
s.quit; \cf2 // quit the server\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
It is not possible to boot a server on a remote machine, but if you have one running already or you know of one running, you can send messages to it. You create the server object using the IP address of the machine running the server and the port it is using.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf2 // create a server object for talking to the server running on a machine having \
// IP address 192.168.0.47 using port #57110\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 s = \cf3 Server\cf0 (\cf4 \\myServer\cf0 , \cf3 NetAddr\cf0 (\cf5 "192.168.0.47"\cf0 , 57110)); \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 Making Sound\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 \
(note: This tutorial uses raw OSC commands as described in 
\f0\b Server-Command-Reference, 
\f1\b0 rather than the classes 
\f0\b Synth
\f1\b0  and 
\f0\b Group
\f1\b0 .  See those helpfiles also for some simpler ways of working with Synths.  This tutorial explains the basic underlying design of Synths and SynthDefs).\
\
Now lets make some audio. \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 s = \cf3 Server\cf0 .local; \cf2 // assign it to interpreter variable 's' \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
Boot it.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 s.boot;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
Create a SynthDef. A SynthDef is a description of a processing module that you want to run on the server. It can read audio from the server's audio buses, read control from the control buses and write control or audio back to buses. Here we will create a sine oscillator and send it to audio bus zero.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf6 (\
\cf7 SynthDef\cf6 (\cf8 "sine"\cf6 , \{ \cf7 arg\cf6  freq=800;\
	\cf7 var\cf6  osc;\
	osc = \cf7 SinOsc\cf6 .ar(freq, 0, 0.1); \cf9 // 800 Hz sine oscillator\cf6 \
	\cf7 Out\cf6 .ar(0, osc); \cf9 // send output to audio bus zero.\cf6 \
\}).writeDefFile; \cf9 // write the def to disk in the default directory synthdefs/\cf6 \
)\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
Send the SynthDef to the server.  \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 s.sendSynthDef(\cf5 "sine"\cf0 );\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 Start the sound. The 
\f0\b /s_new
\f1\b0  command creates a new Synth which is an instance of the "sine" SynthDef. Each synth running on the server needs to have a unique ID. The simplest and safest way to do this is to get an ID from the server's NodeIDAllocator. This will automatically allow IDs to be reused, and will prevent conflicts both with your own nodes, and with nodes created automatically for purposes such as visual scoping and recording. Each synth needs to be installed in a Group. We install it in group one which is the default group. There is a group zero, called the RootNode, which contains the default group, but it is generally best not to use it as doing so can result in order of execution issues with automatically created nodes such as those mentioned above. (For more detail see the 
\f0\b default_group
\f1\b0 , 
\f0\b RootNode
\f1\b0 , and 
\f0\b Order-of-execution
\f1\b0  helpfiles.)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \
s.sendMsg(\cf5 "/s_new"\cf0 , \cf5 "sine"\cf0 , x = s.nextNodeID, 1, 1);
\f1\fs24 \
\
Stop the sound.\

\f2\fs18 \
s.sendMsg(\cf5 "/n_free"\cf0 , x);\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 Stop the server.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \
s.quit;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 SynthDef has two methods which send the def automatically, load which writes it to disk, and send which sends it without writing it to disk. The latter can be useful to avoid clutter on your drive.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 (\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 SynthDef\cf0 (\cf5 "sine"\cf0 , \{ \cf3 arg\cf0  freq=800;\
	\cf3 var\cf0  osc;\
	osc = \cf3 SinOsc\cf0 .ar(freq, 0, 0.1); \cf2 // 800 Hz sine oscillator\cf0 \
	\cf3 Out\cf0 .ar(0, osc); \cf2 // send output to audio bus zero.\cf0 \
\}).load(s); \cf2 // write to disk and send\cf0 \
)\
\
(\
\cf3 SynthDef\cf0 (\cf5 "sine"\cf0 , \{ \cf3 arg\cf0  freq=800;\
	\cf3 var\cf0  osc;\
	osc = \cf3 SinOsc\cf0 .ar(freq, 0, 0.1); \cf2 // 800 Hz sine oscillator\cf0 \
	\cf3 Out\cf0 .ar(0, osc); \cf2 // send output to audio bus zero.\cf0 \
\}).send(s); \cf2 // send without writing\cf0 \
)
\f1\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 \
Using Arguments\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 It is useful to be able to specify parameters of a synth when it is created. Here a frequency argument is added to the sine SynthDef so that we can create it 
\f0\b\fs28 \

\f1\b0\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf6 s = \cf7 Server\cf6 .local; \cf9 // assign it to interpreter variable 's' \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 s.boot;\
\
(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 SynthDef\cf0 (\cf5 "sine"\cf0 , \{ arg freq;\
	\cf3 var\cf0  osc;\
	osc = \cf3 SinOsc\cf0 .ar(freq, 0, 0.1); \cf2 // 800 Hz sine oscillator\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 	\cf3 Out\cf0 .ar(0, osc); \cf2 // send output to audio bus zero.\
\cf0 \}).send(s);\
)\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 Play a 900 Hz sine wave.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \
s.sendMsg(\cf5 "/s_new"\cf0 , \cf5 "sine"\cf0 , x = s.nextNodeID, 1, 1, "freq", 900);\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 s.sendMsg(\cf5 "/n_free"\cf0 , x);\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 Play a 1000 Hz sine wave.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \
s.sendMsg(\cf5 "/s_new"\cf0 , \cf5 "sine"\cf0 , y = s.nextNodeID, 1, 1, "freq", 1000);\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 s.sendMsg(\cf5 "/n_free"\cf0 , y);\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 Playing three voices at once\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \
(\
s.sendMsg(\cf5 "/s_new"\cf0 , \cf5 "sine"\cf0 , x = s.nextNodeID, 1, 1, \cf5 "freq"\cf0 , 800);\
s.sendMsg(\cf5 "/s_new"\cf0 , \cf5 "sine"\cf0 , y = s.nextNodeID, 1, 1, \cf5 "freq"\cf0 , 1001);\
s.sendMsg(\cf5 "/s_new"\cf0 , \cf5 "sine"\cf0 , z = s.nextNodeID, 1, 1, \cf5 "freq"\cf0 , 1202);\
)\
\
(\
s.sendMsg(\cf5 "/n_free"\cf0 , x);\
s.sendMsg(\cf5 "/n_free"\cf0 , y);\
s.sendMsg(\cf5 "/n_free"\cf0 , z);\
)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 Playing three voices at once using bundles. Bundles allow you to send multiple messages with a time stamp. The messages in the bundle will be scheduled to be performed together. The time argument to sendBundle is an offset into the future from the current thread's logical time.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \
(\
s.sendBundle(0.2, \
	[\cf5 "/s_new"\cf0 , \cf5 "sine"\cf0 , x = s.nextNodeID, 1, 1, \cf5 "freq"\cf0 , 800],\
	[\cf5 "/s_new"\cf0 , \cf5 "sine"\cf0 , y = s.nextNodeID, 1, 1, \cf5 "freq"\cf0 , 1001],\
	[\cf5 "/s_new"\cf0 , \cf5 "sine"\cf0 , z = s.nextNodeID, 1, 1, \cf5 "freq"\cf0 , 1202]);\
s.sendBundle(1.2, [\cf5 "/n_free"\cf0 , x],[\cf5 "/n_free"\cf0 , y],[\cf5 "/n_free"\cf0 , z]);\
)
\f0\b\fs28 \
\
Controlling a Synth\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 You can send messages to update the values of a Synth's arguments.\
\
Play a 900 Hz sine wave.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \
s.sendMsg(\cf5 "/s_new"\cf0 , \cf5 "sine"\cf0 , x = s.nextNodeID, 1, 1, "freq", 900);\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
Change the frequency using the 
\f0\b /n_set
\f1\b0  command. You send the node ID, the parameter name and the value.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \
s.sendMsg(\cf5 "/n_set"\cf0 , x, "freq", 800);\
\
s.sendMsg(\cf5 "/n_set"\cf0 , x, "freq", 700);\
\
s.sendMsg(\cf5 "/n_free"\cf0 , x);\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 \
Adding an Effect Dynamically\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 You can dynamically add and remove an effect to process another synth. In order to do this, the effect has to be added after the node to be processed.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs18 \cf0 (\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // define a noise pulse\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 SynthDef\cf0 (\cf5 "tish"\cf0 , \{ \cf3 arg\cf0  freq = 1200, rate = 2;\
	\cf3 var\cf0  osc, trg;\
	trg = \cf3 Decay2\cf0 .ar(\cf3 Impulse\cf0 .ar(rate,0,0.3), 0.01, 0.3);\
	osc = \{\cf3 WhiteNoise\cf0 .ar(trg)\}.dup;\
	\cf3 Out\cf0 .ar(0, osc); \cf2 // send output to audio bus zero.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \}).send(s);\
)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs18 \cf0 (\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // define an echo effect\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 SynthDef\cf0 (\cf5 "echo"\cf0 , \{ \cf3 arg\cf0  delay = 0.2, decay = 4;\
	\cf3 var\cf0  in;\
	in = \cf3 In\cf0 .ar(0,2);\
	\cf2 // use ReplaceOut to overwrite the previous contents of the bus.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 	\cf3 ReplaceOut\cf0 .ar(0, \cf3 CombN\cf0 .ar(in, 0.5, delay, decay, 1, in));\
\}).send(s);\
)\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // start the pulse\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 s.sendMsg(\cf5 "/s_new"\cf0 , \cf5 "tish"\cf0 , x = s.nextNodeID, 1, 1, \cf4 \\freq\cf0 , 200, \cf4 \\rate\cf0 , 1.2);\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // add an effect\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 s.sendMsg(\cf5 "/s_new"\cf0 , \cf5 "echo"\cf0 , y = s.nextNodeID, 1, 1);\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // stop the effect\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 s.sendMsg(\cf5 "/n_free"\cf0 , y);\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // add an effect (time has come today.. hey!)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 s.sendMsg(\cf5 "/s_new"\cf0 , \cf5 "echo"\cf0 , z = s.nextNodeID, 1, 1, \cf4 \\delay\cf0 , 0.1, \cf4 \\decay\cf0 , 4);\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // stop the effect\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 s.sendMsg(\cf5 "/n_free"\cf0 , z);\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // stop the pulse\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 s.sendMsg(\cf5 "/n_free"\cf0 , x);\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 This works because we added the effect after the other node. Sometimes you will need to use groups or /n_after to insure that an effect gets added after what it is supposed to process.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 \
\
Chaining Effects\
\
Using Control Buses\
\
Mapping an Argument to a Control Bus\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs18 \cf0 (\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // define a control\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 SynthDef\cf0 (\cf5 "line"\cf0 , \{ \cf3 arg\cf0  i_bus=10, i_start=1000, i_end=500, i_time=1;\
	\cf3 ReplaceOut\cf0 .kr(i_bus, \cf3 Line\cf0 .kr(i_start, i_end, i_time, doneAction: 2));\
\}).send(s)\
)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 Play a 900 Hz sine wave.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \
s.sendMsg(\cf5 "/s_new"\cf0 , \cf5 "sine"\cf0 , x = s.nextNodeID, 1, 1, "freq", 900);\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
Put a frequency value on the control bus.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf6 s.sendMsg(\cf8 "/c_set"\cf6 , 10, x);\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
Map the node's freq argument to read from control bus #10.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf6 s.sendMsg(\cf8 "/n_map"\cf6 , x, \cf10 \\freq\cf6 , 10);\cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 Change the value on the control bus.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \
\cf6 s.sendMsg(\cf8 "/c_set"\cf6 , 10, 1200);\cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 Start a control process that writes to bus #10. \
The EnvGen doneAction will free this node automatically when it finishes.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 s.sendMsg(\cf5 "/s_new"\cf0 , \cf5 "line"\cf0 , s.nextNodeID, 0, 1);\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
Free the node.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 s.sendMsg(\cf5 "/n_free"\cf0 , x);\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 \
Gating Envelopes\
\
Adding a GUI\
\
Using Buffers\
\
Filling Wavetables\
\
Frequency Domain Processing\
\
Sequencing with Routines\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs18 \cf0 (\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 var\cf0  space,offset,timer, saw, envsaw, sampler, delay;\
\
\cf3 SynthDef\cf0 (\cf5 "saw"\cf0 ,\{ \cf3 arg\cf0  out=100, pan=0, trig=0.0, freq=500, amp=1, cutoff=10000, rezz=1;\
	freq = Lag.kr(freq,0.1);\
	\cf3 Out\cf0 .ar(out,\cf3 Pan2\cf0 .ar(\cf3 RLPF\cf0 .ar(\cf3 Saw\cf0 .ar(\cf3 [freq,freq*2]\cf0 ,amp),cutoff,rezz),\
		pan));\
	\}).load(s);    \
\
\cf3 SynthDef\cf0 (\cf5 "envsaw"\cf0 ,\{ \cf3 arg\cf0  out=100, pan=0, dur=0.5, freq=500, amp=1, cutoff=10000, rezz=1;\
	\cf3 var\cf0  env;\
	env = \cf3 EnvGen\cf0 .kr(\cf3 Env\cf0 .perc(0.01, dur, 0.2), doneAction:0, gate:amp);\
	\cf3 Out\cf0 .ar(out,\cf3 Pan2\cf0 .ar(\cf3 RLPF\cf0 .ar(\cf3 Saw\cf0 .ar(\cf3 Lag\cf0 .kr(freq,0.1),env),cutoff,rezz)*amp,\
		pan));\
	\}).load(s);    \
\
\cf3 SynthDef\cf0 (\cf5 "delay"\cf0 , \{ \cf3 arg\cf0  out=0, delay = 0.4, decay = 14;\
	\cf3 var\cf0  in;\
	in = \cf3 In\cf0 .ar(out,2);\
	\cf3 Out\cf0 .ar(out, \cf3 CombN\cf0 .ar(in, 0.5, delay, decay, 1, in));\
\}).load(s);\
\
\cf3 SynthDef\cf0 (\cf5 "sampler"\cf0 ,\{ \cf3 arg\cf0  sample, trig=1,rate=1.0,out=0,bufnum=0,pan=0,amp=1, dur=0.25;\
	\cf3 var\cf0  env;\
	env = \cf3 EnvGen\cf0 .kr(\cf3 Env\cf0 .perc(0.001, dur, 0.001), doneAction:2);\
	\cf3 Out\cf0 .ar(out,\
		\cf3 Pan2\cf0 .ar(\
		\cf3 PlayBuf\cf0 .ar(1,bufnum,rate,\cf3 InTrig\cf0 .kr(trig),0,0)*amp,\
			pan);\
	)\
\}).load(s);\
\
\cf3 Tempo\cf0 .bpm = 120;\
timer=\cf3 BeatSched\cf0 .new;\
offset = \cf3 Tempo\cf0 .tempo.reciprocal;\
\
space = \cf3 Buffer\cf0 .read(s,\cf5 "sounds/a11wlk01.wav"\cf0 );\
\
saw=\cf3 Synth\cf0 (\cf5 "saw"\cf0 );\
delay=\cf3 Synth.after\cf0 (saw,\cf5 "delay", [\\decay, 20]\cf0 );\
\
timer.sched(0,\{\
\cf3 	var r;\
	r=Routine\cf0 (\{ \cf3 var\cf0  wait, freq, cutoff,rezz;\
	wait = \cf3 Pseq\cf0 ([2],\cf3 inf\cf0 ).asStream;\
	freq = \cf3 Pseq\cf0 ([30,40,42,40],\cf3 inf\cf0 ).asStream;\
	cutoff = Pfunc(\{500.rand2+1000\}).asStream;\
	rezz = 0.5;\
	\cf3 inf\cf0 .do(\{saw.set(\cf5 "freq"\cf0 , freq.next.midicps, \cf5 "cutoff"\cf0 , cutoff.next, \cf5 "rezz"\cf0 , rezz, \cf5 "amp"\cf0 , 0.1, \cf5 "out"\cf0 , 0);\
    (wait.next*offset).wait\});\});\
    timer.sched(0,r); \
\});\
\
timer.sched(0,\{\
\cf3 	var r;\
	r=Routine\cf0 (\{ \cf3 var\cf0  wait, rate;\
	wait = \cf3 Pseq\cf0 ([0.25],\cf3 inf\cf0 ).asStream;\
	rate = Pfunc(\{0.5.rand\}).asStream;\
	\cf3 inf\cf0 .do(\{\cf3 Synth\cf0 .before(delay, \cf5 "sampler"\cf0 , [\cf4 \\bufnum\cf0 , space.bufnum, \cf4 \\trig\cf0 , 1, \cf4 \\amp\cf0 ,0.1, \cf4 \\rate\cf0 , \cf3 rate.next\cf0 , \cf4 \\dur\cf0 , wait.next]);    \
    (wait.next*offset).wait\});\});\
    timer.sched(0,r); \
\});\
\
)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 \
\
Sequencing with Patterns\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs18 \cf0 (\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 //sappy emo electronica example... \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 Tempo\cf0 .bpm = 120;\
\cf3 SynthDef\cf0 (\cf5 "patternefx_Ex"\cf0 , \{ \cf3 arg\cf0  out, in; \
	\cf3 var\cf0  audio, efx;\
	audio = \cf3 In\cf0 .ar([20,21],2);\
	efx=\cf3 CombN\cf0 .ar(audio, 0.5, [0.24,0.4], 2, 1); \
	\cf3 Out\cf0 .ar([0,1], audio+efx);\
	\}).load(s);\
\
\cf3 Synth\cf0 .new(\cf5 "patternefx_Ex"\cf0 );\
\
\cf3 SynthDef\cf0 (\cf5 "pattern_Ex"\cf0 , \{ \cf3 arg\cf0  out, freq = 1000, gate = 1, pan = 0, cut = 4000, rez = 0.8, amp = 1;\
	\cf3 Out\cf0 .ar(out,\
		\cf3 Pan2\cf0 .ar(\
			\cf3 RLPF\cf0 .ar(\
				\cf3 Pulse\cf0 .ar(freq,0.05),\
			cut, rez),\
		pan) * \cf3 EnvGen\cf0 .kr(\cf3 Env\cf0 .linen(0.01, 1, 0.3), gate, amp, doneAction:2);\
	) \
	\}).load(s);\
\
\cf3 SynthDef\cf0 (\cf5 "bass_Ex"\cf0 , \{ \cf3 arg\cf0  out, freq = 1000, gate = 1, pan = 0, cut = 4000, rez = 0.8, amp = 1;\
	\cf3 Out\cf0 .ar(out,\
		\cf3 Pan2\cf0 .ar(\
			\cf3 RLPF\cf0 .ar(\
				\cf3 SinOsc\cf0 .ar(freq,0.05),\
			cut, rez),\
		pan) * \cf3 EnvGen\cf0 .kr(\cf3 Env\cf0 .linen(0.01, 1, 0.3), gate, amp, doneAction:2);\
	) \
	\}).load(s);\
\
\cf3 SynthDescLib\cf0 .global.read;\
\
\
\cf3 Pseq\cf0 ([\
\
\cf3 Ptpar\cf0 ([\
0,\cf3 Pbind\cf0 (\cf4 \\instrument\cf0 ,\cf4 \\pattern_Ex\cf0 , \cf4 \\out\cf0 , 20, \cf4 \\dur\cf0 ,\cf3 Pseq\cf0 ([2],16), \cf4 \\root\cf0 ,[-24,-17], \cf4 \\degree\cf0 ,\cf3 Pseq\cf0 ([0,3,5,7,9,11,5,1],2), 	\cf4 \\pan\cf0 ,1,\cf4 \\cut\cf0 ,\cf3 Pxrand\cf0 ([1000,500,2000,300],16), \cf4 \\rez\cf0 ,\cf3 Pfunc\cf0 (\{0.7.rand +0.3\}), \cf4 \\amp\cf0 ,0.12),\
\
0.5,\cf3 Pbind\cf0 (\cf4 \\instrument\cf0 ,\cf4 \\pattern_Ex\cf0 , \cf4 \\out\cf0 , 20, \cf4 \\dur\cf0 ,\cf3 Pseq\cf0 ([\cf3 Pseq\cf0 ([2],15),1.5],1),  \cf4 \\root\cf0 ,-12, \cf4 \\degree\cf0 ,\cf3 Pseq\cf0 ([0,3,5,7,9,11,5,1],2), \cf4 \\pan\cf0 ,-1,\cf4 \\cut\cf0 ,2000, \cf4 \\rez\cf0 ,0.6, \cf4 \\amp\cf0 ,0.1);\
]),\
\
\cf3 Ptpar\cf0 ([\
0,\cf3 Pbind\cf0 (\cf4 \\instrument\cf0 ,\cf4 \\pattern_Ex\cf0 , \cf4 \\out\cf0 , 20, \cf4 \\dur\cf0 ,2, \cf4 \\root\cf0 ,[-24,-17], \cf4 \\degree\cf0 ,\cf3 Pseq\cf0 ([0,3,5,7,9,11,5,1],\cf3 inf\cf0 ), 	\cf4 \\pan\cf0 ,1,\cf4 \\cut\cf0 ,\cf3 Pxrand\cf0 ([1000,500,2000,300],\cf3 inf\cf0 ), \cf4 \\rez\cf0 ,\cf3 Pfunc\cf0 (\{0.7.rand +0.3\}), \cf4 \\amp\cf0 ,0.12),\
\
0,\cf3 Pbind\cf0 (\cf4 \\instrument\cf0 ,\cf4 \\bass_Ex\cf0 , \cf4 \\dur\cf0 ,1, \cf4 \\root\cf0 ,-24, \cf4 \\degree\cf0 ,\cf3 Pseq\cf0 ([0],\cf3 inf\cf0 ), \cf4 \\pan\cf0 ,0, \cf4 \\cut\cf0 ,128, \cf4 \\rez\cf0 ,0.1, \cf4 \\amp\cf0 ,0.3),\
\
0.5,\cf3 Pbind\cf0 (\cf4 \\instrument\cf0 ,\cf4 \\pattern_Ex\cf0 , \cf4 \\out\cf0 , 20, \cf4 \\dur\cf0 ,2, \cf4 \\root\cf0 ,-12, \cf4 \\degree\cf0 ,\cf3 Pseq\cf0 ([0,3,5,7,9,11,5,1],\cf3 inf\cf0 ), \cf4 \\pan\cf0 ,-1,\cf4 \\cut\cf0 ,2000, \cf4 \\rez\cf0 ,0.6, \cf4 \\amp\cf0 ,0.1);\
]);\
\
\
]).play;\
\
)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 \
}