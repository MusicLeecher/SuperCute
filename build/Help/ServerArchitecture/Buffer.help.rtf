{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red0\green0\blue0;\red0\green0\blue191;
\red96\green96\blue96;\red0\green115\blue0;\red96\green96\blue96;\red191\green0\blue0;\red0\green115\blue0;
\red191\green0\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 Buffer
\f1\b0\fs24 \
\
Represents and encapsulates all the common tasks, \
OSC messages and  capabilities of a buffer on a server.\
\
BufferIDs are automatically allocated from the Server's bufferID allocator.  \
The Buffer object you create can be sent the message 
\f0\b .free
\f1\b0  and it will release \
the buffer on the server, and return the bufferID for future reallocation.\
\
Buffers are used with [PlayBuf], [RecordBuf], [DiskIn], [DiskOut] and other UGens.\
See individual help files for more examples.\
\
notes:\
	Internal server will not post file not found notifications.\
	SD2 file support has been dropped since SC2.\

\f2\fs18 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 completionMessage
\f1\b0  \
Many buffer operations are asynchronous.  They are passed to the background thread on the server so as not to steal CPU time from the audio synthesis thread.    At the end of these messages, another OSC message may be included that will be executed as soon as the first operation is done.\
It is also possible to pass in a function that creates the OSC message.  It will be passed the Buffer as an argument.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 \ul Creating
\f2\b0\fs18 \ulnone \
	\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 	Buffer.alloc(server, numFrames, numChannels, completionMessage);\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs18 \cf0 	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 	Allocate a buffer on the server.  \
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 		//Allocate 8 second stereo buffer\
		s = \cf2 Server\cf0 .local;\
		b = \cf2 Buffer\cf0 .alloc(s,44100 * 8.0,2);\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 	\
	
\f0\b\fs24 Buffer.read(server, path, startFrame = 0, numFrames = -1,completionMessage);\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 \
	Allocate a buffer and immediately read a soundfile into it.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 	\
\cf3 	(\
	\
	s = \cf4 Server\cf3 .local.boot;\
	b = \cf4 Buffer\cf3 .read(s,\cf5 "sounds/a11wlk01.wav"\cf3 );\
	\
	\cf4 SynthDef\cf3 (\cf5 "help-Buffer"\cf3 ,\{ \cf4 arg\cf3  out=0,bufnum;\
		\cf4 Out\cf3 .ar( out,\
			\cf4 PlayBuf\cf3 .ar(1,bufnum,\cf4 BufRateScale\cf3 .kr(bufnum))\
		)\
	\}).play(s,[\cf6 \\bufnum\cf3 , b.bufnum ]);\
	\
	)\cf0 \
	\
	\
	( // with a completion message\
	\cf2 SynthDef\cf0 (\cf7 "help-Buffer"\cf0 ,\{ \cf2 arg\cf0  out=0,bufnum;\
		\cf2 Out\cf0 .ar( out,\
			\cf2 PlayBuf\cf0 .ar(1,bufnum,\cf2 BufRateScale\cf0 .kr(bufnum))\
		)\
	\}).load(s);\
	\
	\
\cf3 	y = \cf4 Synth\cf3 .prNew(\cf5 "help-Buffer"\cf3 ); \cf8 // not sent yet\
\cf3 	b = \cf4 Buffer\cf3 .read(s,\cf5 "sounds/a11wlk01.wav"\cf3 , \
		completionMessage: \{ \cf4 arg\cf3  buffer;\
			\cf8 // synth add its s_new msg to follow \
\cf3 			\cf8 // after the buffer read completes\
\cf3 			y.newMsg(s,\cf6 \\addToTail\cf3 ,[\cf6 \\bufnum\cf3 ,buffer.bufnum])\
		\});\
	\
	\
	\cf8 // when done...\
\cf3 	y.free;\
	b.free;\
	\cf0 \
	)\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 	Buffer.cueSoundFile(server, path, startFrame, numChannels, \
							bufferSize,completionMessage);\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 	\
		Allocate a buffer and preload a soundfile for use with DiskIn.\
		\
		
\f0\b path
\f1\b0  - path of the sound file\
		
\f0\b startFrame
\f1\b0  - frame of the soundfile that DiskIn will start playing at\
		
\f0\b numChannels
\f1\b0  - number of channels in the soundfile\
		
\f0\b bufferSize
\f1\b0  - a multiple of  (2 * synth block size), by default (2 * 128).\
			32768 is the default and is suitable for most cases.\
		
\f0\b completionMessage\
			
\f1\b0 osc message or function that returns an osc message\
		\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 		\cf2 SynthDef\cf0 (\cf7 "help-Buffer"\cf0 ,\{ \cf2 arg\cf0  out=0,bufnum;\
			\cf2 Out\cf0 .ar(out,\
				\cf2 DiskIn\cf0 .ar( 2, bufnum )\
			)\
		\}).load(s);\
		\
		m = \{ \cf2 arg\cf0  buf; [\cf7 "/s_new"\cf0 , \cf7 "help-Buffer"\cf0 , s.nodeAllocator.alloc, 1, 0, \
						\cf9 \\bufnum\cf0 ,buf.bufnum]\};\
		\cf2 File\cf0 .openDialog(\cf7 "Choose a long stereo soundfile..."\cf0 ,\{ \cf2 arg\cf0  path;\
			\cf10 //read a file into the buffer and play it right away\
\cf0 			b = \cf2 Buffer\cf0 .cueSoundFile(s,path,0,2, completionMessage: m);\
		\});\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 \ul \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs24 \cf0 \ulnone 	Buffer.new(server, numFrames, numChannels,);\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs18 \cf0 	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 	Allocate bufferID from the server's bufferID allocator.\
	Does not allocate the buffer on the server, does not send any\
	OSC messages.  This is more flexible for use in bundles.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 	\
	s = \cf2 Server\cf0 .local;\
	b = \cf2 Buffer\cf0 .new(s,44100 * 8.0,2);\
	b = \cf2 Buffer\cf0 .new(s,44100 * 8.0,2);\
	s.sendBundle(0,b.allocMsg,c.allocMsg); // sent both at the same time\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 \ul \
instance methods:
\f1\b0\fs24 \ulnone \
	\
	Each method has a version that sends immeditely, and one that just\
	returns the message to you, but does not send it to the server.\
		\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 	read(path,fileStartFrame, numFrames, bufStartFrame, leaveOpen, \
										completionMessage);\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 	
\f0\b readMsg(path,fileStartFrame, numFrames, bufStartFrame, leaveOpen, \
										completionMessage);\

\f1\b0 \
		Read a soundfile into the buffer.\
		
\f0\b path
\f1\b0  - path of the soundfile\
		
\f0\b fileStartFrame
\f1\b0  - where in the soundfile to start\
		
\f0\b numFrames
\f1\b0  - how many frames to read or -1 to read as much of the file\
			as will fit in the Buffer\
			if leaving the file open for DiskIn usage, use -1 to fill the whole buffer\
		
\f0\b bufStartFrame
\f1\b0  - which frame in the buffer to start reading into\
		
\f0\b leaveOpen
\f1\b0  -\
			for DiskIn you will want this to be\cf2  
\f2\fs18 \cf2 true
\f1\fs24 \cf0 , the buffer will be\
			used for streaming the soundfile from disk.\
			the buffer must have been allocated with a multiple of\
			(2 * synth block size).  most commonly 32768 frames.\
			The class method .cueSoundFile simplifies this.\
		
\f0\b completionMessage\
			
\f1\b0 osc message or function that returns an osc message\
	
\f0\b 	\

\f1\b0 	
\f0\b \
		\
	write( path,headerFormat,sampleFormat,numFrames,startFrame,leaveOpen,\
										completionMessage);\
	writeMsg( path,headerFormat,sampleFormat,numFrames,startFrame,\
						leaveOpen,completionMessage);\

\f1\b0 \
		Write the contents of the buffer to a file.\
		set leaveOpen to 
\f2\fs18 \cf2 true
\f1\fs24 \cf0  for use with DiskOut\
	\
		see 
\f0\b SoundFile
\f1\b0  for headerFormat and sampleFormat\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 	free(completionMessage)
\f1\b0 \

\f0\b 	freeMsg(completionMessage)
\f1\b0 \
	\
		release the buffer on the server and return the bufferID back to the\
		allocator for future reallocation.\
		
\f0\b completionMessage\
			
\f1\b0 osc message or function that returns an osc message\
\
	\

\f0\b 	zero(completionMessage)
\f1\b0 \
	
\f0\b zeroMsg(completionMessage)
\f1\b0 \
	\
		sends 
\f2\fs18 /b_zero
\f1\fs24  message to the buffer, setting all samples to 0.0\
		
\f0\b completionMessage\
			
\f1\b0 osc message or function that returns an osc message\
	\

\f0\b 	set(index,float ... morePairs)\
	setMsg(index,float ... morePairs)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 		set the sample at index to float\
		additional pairs of indices and floats may be included in the same message\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 		b.set(0,0.2,1,0.3,2,0.4);	\
		\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 	setn(startAt,values ... morePairs)\
	setnMsg(startAt,values ... morePairs)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 	\
		values should be an array of floats.  starting at the index startAt, sets\
		each sample to the corresponding value.\
		additional pairs of starting indices and float arrays may be included\
		in the same message.\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 	fill(startAt,numFrames,value ... more)\
	fillMsg(startAt,numFrames,value ... more)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 		\
		starting at the index startAt, set the next numFrames samples to value.\
		additional triplets may be included in the same message.\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 	close(completionMessage)\
	closeMsg(completionMessage)\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 		after using a Buffer with DiskOut, close the soundfile and write the\
		header information.\
		\
		
\f0\b completionMessage\
			
\f1\b0 osc message or function that returns an osc message\
	
\f2\fs18 \
\
\
\
\
\
\
\
}