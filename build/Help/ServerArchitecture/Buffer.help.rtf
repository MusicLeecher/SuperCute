{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red96\green96\blue96;\red0\green115\blue0;
\red191\green0\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 Buffer
\f1\b0\fs24 \
\
Represents and encapsulates all the common tasks, OSC messages and capabilities of a sample buffer on a server.\
\
Buffer numbers are automatically allocated from the Server's bufferAllocator. When you call 
\f0\b .free
\f1\b0  on a Buffer object it will release the buffer on the server, and return the buffer number for future reallocation.\
\
Buffers are used with 
\f0\b PlayBuf
\f1\b0 , 
\f0\b RecordBuf
\f1\b0 , 
\f0\b DiskIn
\f1\b0 , 
\f0\b DiskOut
\f1\b0 , 
\f0\b BufWr
\f1\b0 , 
\f0\b BufRd
\f1\b0 , and other UGens. See their individual help files for more examples.\
\
notes:\
	Internal server will not post file not found notifications.\
	SD2 file support has been dropped since SC2.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 \
completionMessage
\f1\b0  \
Many buffer operations are asynchronous. They are passed to the background thread on the server so as not to steal CPU time from the audio synthesis thread. At the end of these messages, another OSC message may be included so that the server will execute it as soon as the first operation is done. For example, load a sound into the buffer, and when done start a synth to play that sound.\
\
With Buffer methods that take a completionMessage, it is also possible to pass in a function that returns an OSC message. It will be passed the Buffer as an argument. It is important to understand that this function will be evaluated after the Buffer object has been created (so that it's bufnum and other details are accessible), but before the corresponding message is sent to the server.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 \ul Creation
\f2\b0\fs18 \ulnone \
	\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 	Buffer.alloc(server, numFrames, numChannels, completionMessage);\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs18 \cf0 	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 	Allocate a buffer on the server.  \
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 		//Allocate 8 second stereo buffer\
		s = \cf2 Server\cf0 .local;\
		b = \cf2 Buffer\cf0 .alloc(s,44100 * 8.0,2);\
	\
	
\f0\b\fs24 Buffer.read(server, path, startFrame = 0, numFrames = -1, completionMessage);\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 \
	Allocate a buffer and immediately read a soundfile into it.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 	\
	(\
	\
	s = \cf2 Server\cf0 .local.boot;\
	b = \cf2 Buffer\cf0 .read(s,\cf3 "sounds/a11wlk01.wav"\cf0 );\
	\
	\cf2 SynthDef\cf0 (\cf3 "help-Buffer"\cf0 ,\{ \cf2 arg\cf0  out=0,bufnum;\
		\cf2 Out\cf0 .ar( out,\
			\cf2 PlayBuf\cf0 .ar(1,bufnum,\cf2 BufRateScale\cf0 .kr(bufnum))\
		)\
	\}).play(s,[\cf4 \\bufnum\cf0 , b.bufnum ]);\
	\
	)\
	\
	\
	( // with a completion message\
	\cf2 SynthDef\cf0 (\cf3 "help-Buffer"\cf0 ,\{ \cf2 arg\cf0  out=0,bufnum;\
		\cf2 Out\cf0 .ar( out,\
			\cf2 PlayBuf\cf0 .ar(1,bufnum,\cf2 BufRateScale\cf0 .kr(bufnum))\
		)\
	\}).send(s);\
	\
	\
	y = \cf2 Synth\cf0 .basicNew(\cf3 "help-Buffer"\cf0 ); \cf5 // not sent yet\
\cf0 	b = \cf2 Buffer\cf0 .read(s,\cf3 "sounds/a11wlk01.wav"\cf0 , \
		completionMessage: \{ \cf2 arg\cf0  buffer;\
			\cf5 // synth add its s_new msg to follow \
\cf0 			\cf5 // after the buffer read completes\
\cf0 			y.newMsg(s,\cf4 \\addToTail\cf0 ,[\cf4 \\bufnum\cf0 ,buffer.bufnum])\
		\});\
	\
	)\
	\cf5 // when done...\
\cf0 	y.free;\
	b.free;\
	\
	\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 	Buffer.cueSoundFile(server, path, startFrame, numChannels, bufferSize,completionMessage);\

\f1\b0 	\
		Allocate a buffer and preload a soundfile for use with DiskIn.\
		\
		
\f0\b path
\f1\b0  - path of the sound file\
		
\f0\b startFrame
\f1\b0  - frame of the soundfile that DiskIn will start playing at\
		
\f0\b numChannels
\f1\b0  - number of channels in the soundfile\
		
\f0\b bufferSize
\f1\b0  - a multiple of  (2 * synth block size), by default (2 * 128).\
			32768 is the default and is suitable for most cases.\
		
\f0\b completionMessage\
			
\f1\b0 osc message or function that returns an osc message\
		\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 		\cf2 SynthDef\cf0 (\cf3 "help-Buffer"\cf0 ,\{ \cf2 arg\cf0  out=0,bufnum;\
			\cf2 Out\cf0 .ar(out,\
				\cf2 DiskIn\cf0 .ar( 2, bufnum )\
			)\
		\}).send(s);\
		\
		m = \{ \cf2 arg\cf0  buf; [\cf3 "/s_new"\cf0 , \cf3 "help-Buffer"\cf0 , s.nodeAllocator.alloc, 1, 0, \
						\cf4 \\bufnum\cf0 ,buf.bufnum]\};\
		\cf2 File\cf0 .openDialog(\cf3 "Choose a long stereo soundfile..."\cf0 ,\{ \cf2 arg\cf0  path;\
			\cf5 //read a file into the buffer and play it right away\
\cf0 			b = \cf2 Buffer\cf0 .cueSoundFile(s,path,0,2, completionMessage: m);\
		\});\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 \ul \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs24 \cf0 \ulnone 	Buffer.new(server, numFrames, numChannels);\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs18 \cf0 	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 	Allocate bufferID from the server's bufferID allocator.\
	Does not allocate the buffer on the server, does not send any\
	OSC messages.  This is more flexible for use in bundles.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 	\
	s = \cf2 Server\cf0 .local;\
	b = \cf2 Buffer\cf0 .new(s,44100 * 8.0,2);\
	c = \cf2 Buffer\cf0 .new(s,44100 * 8.0,2);\
	s.sendBundle(0,b.allocMsg,c.allocMsg); // sent both at the same time\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 \ul \
Accessing Instance Variables\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 \ulnone 	
\f0\b server
\f1\b0  - this returns the corresponding Server object.\
	
\f0\b bufnum 
\f1\b0 - this returns the Buffer's buffer number.\
	
\f0\b numFrames
\f1\b0  - this returns the number of frames.\
	
\f0\b numChannels 
\f1\b0 - this returns the number of channels.\
	
\f0\b path
\f1\b0  - if the Buffer has read or written to a soundfile, this returns it's path. Otherwise nil.\
	\
	
\f2\fs18 b = \cf2 Buffer\cf0 .new(s,44100 * 8.0,2);\
	b.bufnum.postln;
\f1\fs24 \
	
\f0\b\fs28 \ul \
Instance Methods
\f1\b0\fs24 \ulnone \
	\
	Each method has a version that sends immediately, and one that just returns the message to you, but does not send it to the server.\
		\

\f0\b 	read(path,fileStartFrame, numFrames, bufStartFrame, leaveOpen, completionMessage);\

\f1\b0 	
\f0\b readMsg(path,fileStartFrame, numFrames, bufStartFrame, leaveOpen, completionMessage);\

\f1\b0 \
		Read a soundfile into the buffer.\
		
\f0\b path
\f1\b0  - path of the soundfile\
		
\f0\b fileStartFrame
\f1\b0  - where in the soundfile to start\
		
\f0\b numFrames
\f1\b0  - how many frames to read or -1 to read as much of the file\
			as will fit in the Buffer\
			if leaving the file open for DiskIn usage, use -1 to fill the whole buffer\
		
\f0\b bufStartFrame
\f1\b0  - which frame in the buffer to start reading into\
		
\f0\b leaveOpen
\f1\b0  -\
			for DiskIn you will want this to be\cf2  
\f2\fs18 \cf2 true
\f1\fs24 \cf0 , the buffer will be\
			used for streaming the soundfile from disk.\
			the buffer must have been allocated with a multiple of\
			(2 * synth block size).  most commonly 32768 frames.\
			The class method .cueSoundFile simplifies this.\
		
\f0\b completionMessage\
			
\f1\b0 osc message or function that returns an osc message\
	
\f0\b 	\

\f1\b0 \

\f0\b 	cueSoundFile(path,fileStartFrame, bufferSize, completionMessage);\

\f1\b0 	
\f0\b cueSoundFileMsg(path,fileStartFrame, bufferSize, completionMessage);\

\f1\b0 \
		Cue a soundfile into the buffer for use with DiskIn\
		
\f0\b path
\f1\b0  - path of the soundfile\
		
\f0\b fileStartFrame
\f1\b0  - where in the soundfile to start\
		
\f0\b bufferSize
\f1\b0  - the default is 32768, suitable for most situations.\
		
\f0\b completionMessage\
			
\f1\b0 osc message or function that returns an osc message\
	
\f0\b \
		\
	write( path,headerFormat,sampleFormat,numFrames,startFrame,leaveOpen,\
										completionMessage);\
	writeMsg( path,headerFormat,sampleFormat,numFrames,startFrame,\
						leaveOpen,completionMessage);\

\f1\b0 \
		Write the contents of the buffer to a file.\
		set leaveOpen to 
\f2\fs18 \cf2 true
\f1\fs24 \cf0  for use with DiskOut\
	\
		see 
\f0\b SoundFile
\f1\b0  for headerFormat and sampleFormat\

\f0\b \

\f1\b0 \
\

\f0\b 	free(completionMessage)
\f1\b0 \

\f0\b 	freeMsg(completionMessage)
\f1\b0 \
	\
		release the buffer on the server and return the bufferID back to the\
		allocator for future reallocation.\
		
\f0\b completionMessage\
			
\f1\b0 osc message or function that returns an osc message\
\
	\

\f0\b 	zero(completionMessage)
\f1\b0 \
	
\f0\b zeroMsg(completionMessage)
\f1\b0 \
	\
		sends 
\f2\fs18 /b_zero
\f1\fs24  message to the buffer, setting all samples to 0.0\
		
\f0\b completionMessage\
			
\f1\b0 osc message or function that returns an osc message\
	\

\f0\b 	set(index,float ... morePairs)\
	setMsg(index,float ... morePairs)\

\f1\b0 		set the sample at index to float\
		additional pairs of indices and floats may be included in the same message\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 		b.set(0,0.2,1,0.3,2,0.4);	\
		\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \

\f0\b 	setn(startAt,values ... morePairs)\
	setnMsg(startAt,values ... morePairs)\

\f1\b0 	\
		values should be an array of floats.  starting at the index startAt, sets\
		each sample to the corresponding value.\
		additional pairs of starting indices and float arrays may be included\
		in the same message.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 		(\
			s = \cf2 Server\cf0 .local;\
			b = \cf2 Buffer\cf0 .new(s,16);\
			b.alloc;\
			b.setn(0,\cf2 Array\cf0 .fill(16,\{ rrand(0,1) \}));\
		)\
		(\
			s = \cf2 Server\cf0 .local;\
			b = \cf2 Buffer\cf0 .new(s,16);\
			s.sendMsg(\
				b.allocMsg( \
					b.setnMsg(0,\cf2 Array\cf0 .fill(16,\{ rrand(0,1) \}))\
				)\
			);\
		)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 			\
\

\f0\b 	fill(startAt,numFrames,value ... more)\
	fillMsg(startAt,numFrames,value ... more)\

\f1\b0 		\
		starting at the index startAt, set the next numFrames samples to value.\
		additional triplets may be included in the same message.\
	\

\f0\b 	copyTo(buf, numSamples, dstSamplePos, srcSamplePos)\
	copyToMsg(buf, numSamples, dstSamplePos, srcSamplePos)\

\f1\b0 		\
		starting at the sample index srcSamplePos, copy numSamples samples\
		from this to the destination buffer buf starting at dstSamplePos.\
		if numSamples is negative, the maximum number of samples possible is\
		copied.\
\
		
\f2\fs18 (\
			s = \cf2 Server\cf0 .local;\
			\cf2 SynthDef\cf0 (\cf3 "help-Buffer"\cf0 , \{ \cf2 arg\cf0  out=0, buf;\
				\cf2 Line\cf0 .ar(0, 0, dur: \cf2 BufDur\cf0 .kr(buf), doneAction: 2);\
				\cf2 Out\cf0 .ar(out, \cf2 PlayBuf\cf0 .ar(1, buf, 0.25));\
			\}).send(s);\
		)\
		\
		(\
			b = \cf2 Buffer\cf0 .read(s, \cf3 "sounds/a11wlk01.wav"\cf0 );\
			c = \cf2 Buffer\cf0 .alloc(s, 120000);\
		)\
\
		\cf2 Synth\cf0 (\cf3 "help-Buffer"\cf0 , [\cf4 \\buf\cf0 , b.bufnum]);		\
		\
		c.zero;								\cf5 // copy the whole buffer\cf0 \
		b.copyTo(c);\
		\cf2 Synth\cf0 (\cf3 "help-Buffer"\cf0 , [\cf4 \\buf\cf0 , c.bufnum]);\
		\
		c.zero;								\cf5 // copy some samples\cf0 \
		b.copyTo(c, numSamples: 4410);\
		\cf2 Synth\cf0 (\cf3 "help-Buffer"\cf0 , [\cf4 \\buf\cf0 , c.bufnum]);\
		\
		c.zero;								\cf5 // buffer "compositing"\cf0 \
		b.copyTo(c, numSamples: 4410);\
		b.copyTo(c, dstStartAt: 4410, numSamples: 15500);\
		\cf2 Synth\cf0 (\cf3 "help-Buffer"\cf0 , [\cf4 \\buf\cf0 , c.bufnum]);\

\f1\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 		b.free;\
		c.free;
\f1\fs24 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 	close(completionMessage)\
	closeMsg(completionMessage)\
	\

\f1\b0 		after using a Buffer with DiskOut, close the soundfile and write the\
		header information.\
		\
		
\f0\b completionMessage\
			
\f1\b0 osc message or function that returns an osc message\
	
\f2\fs18 \
\
\
\
\
\
\
\
}