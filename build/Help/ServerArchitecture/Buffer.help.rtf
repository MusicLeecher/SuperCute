{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red96\green96\blue96;\red0\green0\blue0;
\red191\green0\blue0;\red0\green0\blue191;\red96\green96\blue96;\red0\green115\blue0;\red191\green0\blue0;
}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 Buffer
\f1\b0\fs24 \
\
Represents and encapsulates all the common tasks, \
OSC messages and  capabilities of a buffer on a server.\
\
BufferIDs are automatically allocated from the Server's bufferID allocator.  \
The Buffer object you create can be sent the message 
\f0\b .free
\f1\b0  and it will release \
the buffer on the server, and return the bufferID for future reallocation.\
\
Buffers are used with [PlayBuf], [RecordBuf], [DiskIn], [DiskOut] and other UGens.\
See individual help files for more examples.\
\
note:\
	internal server will not post file not found notifications\
	sd2 file support has been dropped since SC2\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 completionMessage
\f1\b0  is a osc message that is executed as soon as the\
command is done. This is important as buffer commands are asynchronous .\
it is also possible to pass in a function that creates the osc message\
(the buffer is passed into the function)
\f2\fs18 \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 \ul Creating
\f2\b0\fs18 \ulnone \
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 	Buffer.new(server, numFrames, numChannels, completionMessage);\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs18 \cf0 	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 	Allocate 8 second stereo buffer\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 	\
	s = \cf2 Server\cf0 .local;\
	b = \cf2 Buffer\cf0 .new(s,44100 * 8.0,2);\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 	Buffer.read(server, path, startFrame = 0, numFrames = -1,completionMessage);\

\f1\b0 \
	Allocate a buffer and immediately read a soundfile into it\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 	\
	(\
	s = \cf2 Server\cf0 .local.boot;\
	\cf2 SynthDef\cf0 (\cf3 "help-PlayBuf"\cf0 ,\{ \cf2 arg\cf0  out=0,bufnum;\
		\cf2 Out\cf0 .ar( out,\
			\cf2 PlayBuf\cf0 .ar(1,bufnum,\cf2 BufRateScale\cf0 .kr(bufnum))\
		)\
	\}).load(s);\
	)\
	\cf4 \
	\cf5 //create a function that returns an osc message and plays the synth\
\cf4 	m = \{ \cf6 arg\cf4  buf; [\cf7 "/s_new"\cf4 , \cf7 "help-PlayBuf"\cf4 , 7000, 1, 0, \cf8 \\bufnum\cf4 ,\cf0 buf\cf4 .bufnum]\};\
	\cf5 //read a file into the buffer and play it right away\
\cf4 	b = \cf6 Buffer\cf4 .read(s,\cf7 "sounds/a11wlk01.wav"\cf4 , completionMessage: m);\
	\cf0 \
	\cf9 // when done...\
\cf0 	b.free;\
	\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 	Buffer.cueSoundFile(server, path, startFrame, numChannels, \
							bufferSize,completionMessage);\

\f1\b0 	\
	Allocate a buffer and preload a soundfile for use with DiskIn.\
	
\f0\b path
\f1\b0  - path of the sound file\
	
\f0\b startFrame
\f1\b0  - frame of the soundfile that DiskIn will start playing at\
	
\f0\b numChannels
\f1\b0  - number of channels in the soundfile\
	
\f0\b bufferSize
\f1\b0  - a multiple of  (2 * synth block size), by default (2 * 128).\
		32768 is the default and is suitable for most cases.\
	
\f0\b completionMessage\
		
\f1\b0 osc message or function that returns an osc message\
		\
		\
		\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 \ul instance methods:
\f1\b0\fs24 \ulnone \
		\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 	read(path,fileStartFrame, numFrames, bufStartFrame, leaveOpen, \
										completionMessage);\

\f1\b0 	\
	Read a soundfile into the buffer.\
	
\f0\b path
\f1\b0  - path of the soundfile\
	
\f0\b fileStartFrame
\f1\b0  - where in the soundfile to start\
	
\f0\b numFrames
\f1\b0  - how many frames to read or -1 to read as much of the file\
		as will fit in the Buffer\
		if leaving the file open for DiskIn usage, use -1 to fill the whole\
		buffer\
	
\f0\b bufStartFrame
\f1\b0  - which frame in the buffer to start reading into\
	
\f0\b leaveOpen
\f1\b0  -\
		for DiskIn you will want this to be\cf2  
\f2\fs18 \cf2 true
\f1\fs24 \cf0 , the buffer will be\
		used for streaming the soundfile from disk.\
		the buffer must have been allocated with a multiple of\
		(2 * synth block size).  most commonly 32768 frames.\
	
\f0\b completionMessage\
		
\f1\b0 osc message or function that returns an osc message\

\f0\b 	\
	\
	write( path,headerFormat,sampleFormat,numFrames,startFrame,leaveOpen,\
										completionMessage);\

\f1\b0 	Write the contents of the buffer to a file.\
	set leaveOpen to 
\f2\fs18 \cf2 true
\f1\fs24 \cf0  for use with DiskOut\
	\
	see 
\f0\b SoundFile
\f1\b0  for headerFormat and sampleFormat\
	\
\

\f0\b 	free(completionMessage)
\f1\b0 \
	\
		release the buffer on the server and return the bufferID back to the\
		allocator for future reallocation.\
		
\f0\b completionMessage\
			
\f1\b0 osc message or function that returns an osc message\
	\

\f0\b 	zero(completionMessage)
\f1\b0 \
	\
		sends 
\f2\fs18 /b_zero
\f1\fs24  message to the buffer, setting all samples to 0.0\
		
\f0\b completionMessage\
			
\f1\b0 osc message or function that returns an osc message\
	\
	\

\f0\b 	set(index,float ... morePairs)\

\f1\b0 \
		set the sample at index to float\
		additional pairs of indices and floats may be included in the same message\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 		b.set(0,0.2,1,0.3,2,0.4);	\
		\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \

\f0\b 	setn(startAt,values ... morePairs)\

\f1\b0 		\
		values should be an array of floats.  starting at the index startAt, sets\
		each sample to the corresponding value.\
		additional pairs of starting indices and float arrays may be included\
		in the same message.\
\
\

\f0\b 	fill(startAt,numFrames,value ... more)\

\f1\b0 		\
		starting at the index startAt, set the next numFrames samples to value.\
		additional triplets may be included in the same message.\
	\

\f0\b 	close(completionMessage)\
	\

\f1\b0 		after using a Buffer with DiskOut, close the soundfile and write the\
		header information.\
		\
		
\f0\b completionMessage\
			
\f1\b0 osc message or function that returns an osc message\
	
\f2\fs18 \
\
\
\
\
\
\
\
}