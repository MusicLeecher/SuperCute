{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fswiss\fcharset77 Helvetica-Oblique;
\f3\fswiss\fcharset77 Helvetica-BoldOblique;\f4\fnil\fcharset77 Monaco;}
{\colortbl;\red255\green255\blue255;\red0\green115\blue0;\red0\green0\blue0;\red191\green0\blue0;
\red0\green0\blue191;\red96\green96\blue96;\red0\green115\blue0;\red191\green0\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 SynthDef				
\fs30 definition of a synth architecture \

\f1\b0\fs24 \
\
\
Evaluates a UGen function, generating a ugenGraph that describes the exact architecture of a Synth.  \
All constants, Controls, and UGens that will be used in synthesis are formatted for the Server and written to disk.  \
\
\

\f0\b *new(synthDefName,ugenGraphFunc, specs/lags, prependArgs)\

\f1\b0 	Create a synthDef instance, evaluate the ugenGraphFunc and build the ugenGraph.\
\
	
\f0\b synthDefName\
			
\f1\b0 string or symbol: "name", 'name', or \\name\
			\
	
\f0\b ugenGraphFunc\
		\
		evaluation :\
			
\f1\b0 Functions inside of a SynthDef are evaluated 
\f2\i only at the time of building 
\f1\i0 \
			the ugenGraph.  Once the graph is built, it is a fixed architecture.\
		\
		
\f0\b arguments:
\f1\b0 \
			the arguments of the ugenGraphFunction are converted into instances of 
\f0\b Control\
			
\f1\b0 \
			arguments to the ugenGraphFunc that begin with "i_" will be 
\f0\b static
\f1\b0  and non-modulatable.\
			They will not respond to /n_set or /n_map.\
		\
			arguments to the ugenGraphFunc that begin with "t_" will be made as 
\f0\b TrigControl
\f1\b0 . Setting \
			the value will create a k-rate impulse. This is useful for triggers.\
		\
			other arguments are all Float inputs, representing 
\f0\b control rate values
\f1\b0  (integer indices \
			for use in In or Out are floats that are truncated to the integer value)\
			\
			there is two argument names that have a 
\f3\i\b common use
\f1\i0\b0  and thus are of significance:\
			(they do not have to be used, but it is very convenient)\
			\
				
\f0\b out
\f1\b0 		the out bus index\
				
\f0\b gate
\f1\b0 		envelope gate, 
\f2\i which can free the synth
\f1\i0 .\
						if a gate arg is specified within an EnvGen with the 
\f0\b doneAction 2
\f1\b0  or larger,\
						the running synth object (which is not the SynthDef!) can be sent the\
						message 
\f0\b release
\f1\b0 . Also in Event Patterns like 
\f0\b Pbind
\f1\b0 , this scheme is used.\
						see also 
\f0\b EnvGen
\f1\b0  help\
	\
		\
		
\f0\b specs/lags
\f1\b0  \
			an Array of specifications for the ugenGraphFunc's arguments. \
			one specification can be:\
				
\f0\b nil/zero
\f1\b0 :	a standard control rate Control si created\
				
\f0\b a float
\f1\b0 	the Control will have a lag of the specified time. t_ and i_ args cannot be lagged\
				
\f0\b \\ir
\f1\b0 		the Control can be set only at creation ('initial rate'): see i_ argument\
				
\f0\b \\tr
\f1\b0 		the Control is used as a trigger: see t_ argument\
		\
	\
\
\

\f0\b *writeOnce(synthDefName,ugenGraphFunc, lags, prependArgs, dir)\
			\
			
\f1\b0 Create a new SynthDef and write it to disk, only if a defFile with this name does not \
			already exist. \
			This is useful in class definitions so the def is not written every time the library is compiled.\
			Note that this will not check for differences, so you will need to delete the defFile to get it to 			rebuild. Default for dir is synthdefs/\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs26 \cf0 \ul Instance Methods
\fs24 \ul \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 \ulnone 	\
	
\f0\b \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 		name
\f1\b0 \
			return my name.\
			a SynthDef is always referred to by its name, which should be unique.\
		
\f0\b \
		writeDefFile(dir)
\f1\b0 \
			encode the graph into a file called name.scsyndef. Default for dir = synthdefs/
\f0\b \
		\
		load(server, completionMessage, dir)\
		
\f1\b0 	write the defFile and send a message to the server to load this file.\
			when this asynchronous command is completed, the completionMessage is evaluated\
			default for dir is synthdefs/\
		\
		
\f0\b send(server, completionMessage)\
		
\f1\b0 	compile the def and send it to the server without writing to disk.\
			(thus avoiding that annoying SynthDef buildup)\
			when this asynchronous command is completed, the completionMessage is evaluated\
		\
		
\f0\b play(target, args, addAction)\
		
\f1\b0 	write the defFile and send a message to the server specified by target to load this file.\
			when this asynchronous command is completed, play one synth from this definition.\
			returns a synth object.\
			for a list of valid addActions see 
\f0\b Synth
\f1\b0 . The default is \cf2 \\addToTail\cf0 \
		\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 	\
see also basic introductions, like [
\f0\b SynthDefsVsSynths]
\f1\b0 \
	\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs26 \cf0 \ul Examples
\fs24 \ul \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f4\fs18 \cf0 \ulnone \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 	\cf3 \
\cf0 	\cf4 // Note that SynthDef(...) is short for SynthDef.new(...).\cf3 \
\cf0 	\cf4 // Thus the following calls *new to create a SynthDef, and then .play on the resulting instance.\cf3 \
\cf0 	\cf4 // It is common to use similar constructions for .send, .load, and so on.\cf3 \
\cf0 	\cf3 \
\cf0 	\cf3 (\
\cf0 	\cf3 d = \cf5 SynthDef\cf3 (\cf6 "trigTest"\cf3 , \{ \cf5 arg\cf3  t_trig=0, freq=440; \cf4 // t_trig creates a TrigControl\cf3 \
\cf0 	\cf3 	\cf5 Out\cf3 .ar(0, \cf5 SinOsc\cf3 .ar(freq+[0,1], 0, \cf5 Decay2\cf3 .kr(t_trig, 0.005, 1.0)));\
\cf0 	\cf3 \
\cf0 	\cf3 	\}, [0, 4]		\cf4 // lag the freq, but not t_trig (won't work anyway)\cf3 \
\cf0 	\cf3 );\
\cf0 	\cf3 )\
\cf0 	\cf3 \
\cf0 	\cf4 //if specs are used, the above can be written also like this:\cf3 \
\cf0 	\cf3 (\
\cf0 	\cf3 d = \cf5 SynthDef\cf3 (\cf6 "trigTest"\cf3 , \{ \cf5 arg\cf3  trig=0, freq=440; \
\cf0 	\cf3 	\cf5 Out\cf3 .ar(0, \cf5 SinOsc\cf3 .ar(freq+[0,1], 0, \cf5 Decay2\cf3 .kr(trig, 0.005, 1.0)));\
\cf0 	\cf3 \
\cf0 	\cf3 	\}, [\cf7 \\tr\cf3 , 4]		\cf4 // lag the freq (lagtime: 4s),\cf8  \\tr creates a TrigControl\cf4  for trig\cf3 \
\cf0 	\cf3 ); 		\
\cf0 	\cf3 )\
\cf0 	\cf3 \
\cf0 	\cf4 //send the def to the local server:\cf3 \
\cf0 	\cf3 s = \cf5 Server\cf3 .local;\
\cf0 	\cf3 d.send(s);\
\cf0 	\cf3 \
\cf0 	\cf4 //create a synth on the server with the synthdef name:\cf3 \
\cf0 	\cf3 \
\cf0 	\cf3 z = \cf5 Synth\cf3 .head(s, \cf7 \\trigTest\cf3 );\
\cf0 	\cf3 z.set(\cf7 \\trig\cf3 , 1); 				\cf4 // you can do this multiple times \cf3 \
\cf0 	\cf3 z.set(\cf7 \\trig\cf3 , 1, \cf7 \\freq\cf3 , 220); 	\cf4 // hear how the freq lags\cf3 \
\cf0 	\cf3 z.set(\cf7 \\trig\cf3 , 1, \cf7 \\freq\cf3 , 880);\
\cf0 	\cf3 \
\cf0 	\cf3 d.free; \cf4 //free the synth
\f1\fs24 \cf3 \
\cf0 	\cf3 \
\cf0 	\cf3 \
\cf0 	
\f4\fs18 \cf8 //play shortcut syntax: this syntax is used in many helpfiles.
\f1\fs24 \cf3 \
\cf0 	
\f4\fs18 z = d.play(s); \cf8 // .play returns a Synth object, assigned here to d. sending the def is done internally.\
\cf0 	z.set(\cf2 \\trig\cf0 , 1);
\f1\fs24 \cf3 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 \
\

\f0\b \cf0 common \cf3 argument names: 
\f3\i out
\f0\i0  
\f1\b0 and
\f0\b  
\f3\i gate
\f1\i0\b0 \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 	
\f4\fs18 \cf3 (\
\cf0 	\cf5 SynthDef\cf3 (\cf6 \\synthDefTest\cf3 , \{ \cf5 arg\cf3  out, gate=1, freq=440; \
\cf0 	\cf3 		\cf5 Out\cf3 .ar(out, \cf5 SinOsc\cf3 .ar(freq) * \cf5 EnvGen\cf3 .kr(\cf5 Env\cf3 .asr(0.1, 0.3, 1.3), gate, doneAction:2));\
\cf0 	\cf3 \
\cf0 	\cf3 	\}).send(s); 		\
\cf0 	\cf3 )\
\cf0 	\cf3 \
\cf0 	\cf3 x = \cf5 Synth\cf3 (\cf7 \\synthDefTest\cf3 , [\cf7 \\out\cf3 , 0]); \cf4 //play out through hardware output bus 0 (see Out.help)\cf3 \
\cf0 	\cf3 x.release;\cf4 //releases and frees the synth, if and only if doneAction is > 2\cf3 \
\cf0 	\cf3 \
\cf0 	\cf4 //equivalent:\cf3 \
\cf0 	\cf3 \
\cf0 	\cf3 x = \cf5 Synth\cf3 (\cf7 \\synthDefTest\cf3 ); \cf4 // out defaults to zero, if no default arg is given.\cf3 \
	x.set(\cf7 \\gate\cf3 , 0); \cf8 //releases and frees the synth, if and only if doneAction is > 2\cf3 \
\cf0 	\cf3 \
\cf0 	\cf4 //if value is negative, it describes the release time:\cf3 \
\cf0 	\cf3 \
\cf0 	\cf3 x = \cf5 Synth\cf3 (\cf7 \\synthDefTest\cf3 );\
\cf0 	\cf3 x.set(\cf7 \\gate\cf3 , -5);\
\cf0 	\cf3 \
\cf0 	\cf3 \
\cf0 	\cf4 //equivalent:\cf3 \
\cf0 	\cf3 x = \cf5 Synth\cf3 (\cf7 \\synthDefTest\cf3 );\
\cf0 	\cf3 x.release(5);\
\cf0 	\cf3 \
\cf0 	\cf3 \
\cf0 	\cf3 \
\cf0 	\cf4 //if the out arg is used in a standard way, it can always be changed without knowing the synth def\cf3 \
\cf0 	\cf3 x = \cf5 Synth\cf3 (\cf7 \\synthDefTest\cf3 , [\cf7 \\out\cf3 , 0]);\
\cf0 	\cf3 x.set(\cf7 \\out\cf3 , 1); \cf4 //play through channel 1\cf3 \
\cf0 	\cf3 \
\cf0 	\cf4 //also it can be used in an event stream:\cf3 \
\cf0 	\cf4 //if the doneAction is 1 the synths pile up and do not get freed.\cf3 \
\cf0 	\cf3 (\
\cf0 	\cf5 Pbind\cf3 (\
\cf0 	\cf3 	\cf7 \\instrument\cf3 , \cf7 \\synthDefTest\cf3 ,\
\cf0 	\cf3 	\cf7 \\freq\cf3 , \cf5 Pseq\cf3 ([500, 600, \cf5 Prand\cf3 ([200, 456, 345],1)], \cf5 inf\cf3 ),\
\cf0 	\cf3 	\cf7 \\legato\cf3 , \cf5 Pseq\cf3 ([1.5, 0.2], \cf5 inf\cf3 ),\
\cf0 	\cf3 	\cf7 \\dur\cf3 , 0.4\
\cf0 	\cf3 ).play;\
\cf0 	\cf3 )\
\cf0 	\cf3 \
\cf0 	\cf3 \
\cf0 	\cf3 \
}