{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fswiss\fcharset77 Helvetica-Oblique;
\f3\fswiss\fcharset77 Helvetica-BoldOblique;\f4\fnil\fcharset77 Monaco;}
{\colortbl;\red255\green255\blue255;\red0\green115\blue0;\red191\green0\blue0;\red0\green0\blue191;
\red96\green96\blue96;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 SynthDef				
\fs30 definition of a synth architecture \

\f1\b0\fs24 \
\
\
Evaluates a UGen function, generating a ugenGraph that describes the exact architecture of a Synth.  \
All constants, Controls, and UGens that will be used in synthesis are formatted for the Server and written to disk.  \
\
\

\f0\b *new(synthDefName,ugenGraphFunc, rates, prependArgs)\

\f1\b0 	Create a synthDef instance, evaluate the ugenGraphFunc and build the ugenGraph.\
\
	
\f0\b synthDefName\
			
\f1\b0 string or symbol: "name", 'name', or \\name\
			\
	
\f0\b ugenGraphFunc\
		\
		evaluation :\
			
\f1\b0 Functions inside of a SynthDef are evaluated 
\f2\i only at the time of building 
\f1\i0 \
			the ugenGraph.  Once the graph is built, it is a fixed architecture.\
		\
		
\f0\b arguments:
\f1\b0 \
			the arguments of the ugenGraphFunction are converted into instances of 
\f0\b Control\
			
\f1\b0 \
			arguments to the ugenGraphFunc that begin with "i_" will be 
\f0\b static
\f1\b0  and non-modulatable.\
			They will not respond to /n_set or /n_map.\
		\
			arguments to the ugenGraphFunc that begin with "t_" will be made as 
\f0\b TrigControl
\f1\b0 . Setting \
			the value will create a k-rate impulse. This is useful for triggers.\
		\
			other arguments are all Float inputs, representing 
\f0\b control rate values
\f1\b0  (integer indices \
			for use in In or Out are floats that are truncated to the integer value)\
			\
			there is two argument names that have a 
\f3\i\b common use
\f1\i0\b0  and thus are of significance:\
			(they do not have to be used, but it is very convenient)\
			\
				
\f0\b out
\f1\b0 		the out bus index\
				
\f0\b gate
\f1\b0 		envelope gate, 
\f2\i which can free the synth
\f1\i0 .\
						if a gate arg is specified within an EnvGen with the 
\f0\b doneAction 2
\f1\b0  or larger,\
						the running synth object (which is not the SynthDef!) can be sent the\
						message 
\f0\b release
\f1\b0 . Also in Event Patterns like 
\f0\b Pbind
\f1\b0 , this scheme is used.\
						see also 
\f0\b EnvGen
\f1\b0  help\
	\
		\
		
\f0\b rates
\f1\b0  \
			an Array of specifications for the ugenGraphFunc's arguments. \
			one specification can be:\
				
\f0\b nil/zero
\f1\b0 :	a standard control rate Control si created\
				
\f0\b a float
\f1\b0 	the Control will have a lag of the specified time. t_ and i_ args cannot be lagged\
				
\f0\b \\ir
\f1\b0 		the Control can be set only at creation ('initial rate'): see i_ argument\
				
\f0\b \\tr
\f1\b0 		the Control is used as a trigger: see t_ argument\
		\
	\
\
\

\f0\b *writeOnce(synthDefName,ugenGraphFunc, rates, prependArgs, dir)\
			\
			
\f1\b0 Create a new SynthDef and write it to disk, only if a defFile with this name does not \
			already exist. \
			This is useful in class definitions so the def is not written every time the library is compiled.\
			Note that this will not check for differences, so you will need to delete the defFile to get it to 			rebuild. Default for dir is synthdefs/\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs26 \cf0 \ul Instance Methods
\fs24 \ul \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 \ulnone 	\
	
\f0\b \
		name
\f1\b0 \
			return my name.\
			a SynthDef is always referred to by its name, which should be unique.\
		
\f0\b \
		writeDefFile(dir)
\f1\b0 \
			encode the graph into a file called name.scsyndef. Default for dir = synthdefs/
\f0\b \
		\
		load(server, completionMessage, dir)\
		
\f1\b0 	write the defFile and send a message to the server to load this file.\
			when this asynchronous command is completed, the completionMessage is evaluated\
			default for dir is synthdefs/\
		\
		
\f0\b send(server, completionMessage)\
		
\f1\b0 	compile the def and send it to the server without writing to disk.\
			(thus avoiding that annoying SynthDef buildup)\
			when this asynchronous command is completed, the completionMessage is evaluated\
		\
		
\f0\b play(target, args, addAction)\
		
\f1\b0 	write the defFile and send a message to the server specified by target to load this file.\
			when this asynchronous command is completed, play one synth from this definition.\
			returns a synth object.\
			for a list of valid addActions see 
\f0\b Synth
\f1\b0 . The default is \cf2 \\addToTail\cf0 \
		\
	\
see also basic introductions, like [
\f0\b SynthDefsVsSynths]
\f1\b0 \
	\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs26 \cf0 \ul Examples
\fs24 \ul \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f4\fs18 \cf0 \ulnone \
	\
	\cf3 // Note that SynthDef(...) is short for SynthDef.new(...).\cf0 \
	\cf3 // Thus the following calls *new to create a SynthDef, and then .play on the resulting instance.\cf0 \
	\cf3 // It is common to use similar constructions for .send, .load, and so on.\cf0 \
	\
	(\
	d = \cf4 SynthDef\cf0 (\cf5 "trigTest"\cf0 , \{ \cf4 arg\cf0  t_trig=0, freq=440; \cf3 // t_trig creates a TrigControl\cf0 \
		\cf4 Out\cf0 .ar(0, \cf4 SinOsc\cf0 .ar(freq+[0,1], 0, \cf4 Decay2\cf0 .kr(t_trig, 0.005, 1.0)));\
	\
		\}, [0, 4]		\cf3 // lag the freq, but not t_trig (won't work anyway)\cf0 \
	);\
	)\
	\
	\cf3 //if specs are used, the above can be written also like this:\cf0 \
	(\
	d = \cf4 SynthDef\cf0 (\cf5 "trigTest"\cf0 , \{ \cf4 arg\cf0  trig=0, freq=440; \
		\cf4 Out\cf0 .ar(0, \cf4 SinOsc\cf0 .ar(freq+[0,1], 0, \cf4 Decay2\cf0 .kr(trig, 0.005, 1.0)));\
	\
		\}, [\cf2 \\tr\cf0 , 4]		\cf3 // lag the freq (lagtime: 4s), \\tr creates a TrigControl for trig\cf0 \
	); 		\
	)\
	\
	\cf3 //send the def to the local server:\cf0 \
	s = \cf4 Server\cf0 .local;\
	d.send(s);\
	\
	\cf3 //create a synth on the server with the synthdef name:\cf0 \
	\
	z = \cf4 Synth\cf0 .head(s, \cf2 \\trigTest\cf0 );\
	z.set(\cf2 \\trig\cf0 , 1); 				\cf3 // you can do this multiple times \cf0 \
	z.set(\cf2 \\trig\cf0 , 1, \cf2 \\freq\cf0 , 220); 	\cf3 // hear how the freq lags\cf0 \
	z.set(\cf2 \\trig\cf0 , 1, \cf2 \\freq\cf0 , 880);\
	\
	d.free; \cf3 //free the synth
\f1\fs24 \cf0 \
	\
	\
	
\f4\fs18 \cf3 //play shortcut syntax: this syntax is used in many helpfiles.
\f1\fs24 \cf0 \
	
\f4\fs18 z = d.play(s); \cf3 // .play returns a Synth object, assigned here to d. sending the def is done internally.\
\cf0 	z.set(\cf2 \\trig\cf0 , 1);
\f1\fs24 \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 common argument names: 
\f3\i out
\f0\i0  
\f1\b0 and
\f0\b  
\f3\i gate
\f1\i0\b0 \
\
\
	
\f4\fs18 (\
	\cf4 SynthDef\cf0 (\cf5 \\synthDefTest\cf0 , \{ \cf4 arg\cf0  out, gate=1, freq=440; \
			\cf4 Out\cf0 .ar(out, \cf4 SinOsc\cf0 .ar(freq) * \cf4 EnvGen\cf0 .kr(\cf4 Env\cf0 .asr(0.1, 0.3, 1.3), gate, doneAction:2));\
	\
		\}).send(s); 		\
	)\
	\
	x = \cf4 Synth\cf0 (\cf2 \\synthDefTest\cf0 , [\cf2 \\out\cf0 , 0]); \cf3 //play out through hardware output bus 0 (see Out.help)\cf0 \
	x.release;\cf3 //releases and frees the synth, if and only if doneAction is > 2\cf0 \
	\
	\cf3 //equivalent:\cf0 \
	\
	x = \cf4 Synth\cf0 (\cf2 \\synthDefTest\cf0 ); \cf3 // out defaults to zero, if no default arg is given.\cf0 \
	x.set(\cf2 \\gate\cf0 , 0); \cf3 //releases and frees the synth, if and only if doneAction is > 2\cf0 \
	\
	\cf3 //if value is negative, it describes the release time:\cf0 \
	\
	x = \cf4 Synth\cf0 (\cf2 \\synthDefTest\cf0 );\
	x.set(\cf2 \\gate\cf0 , -5);\
	\
	\
	\cf3 //equivalent:\cf0 \
	x = \cf4 Synth\cf0 (\cf2 \\synthDefTest\cf0 );\
	x.release(5);\
	\
	\
	\
	\cf3 //if the out arg is used in a standard way, it can always be changed without knowing the synth def\cf0 \
	x = \cf4 Synth\cf0 (\cf2 \\synthDefTest\cf0 , [\cf2 \\out\cf0 , 0]);\
	x.set(\cf2 \\out\cf0 , 1); \cf3 //play through channel 1\cf0 \
	\
	\cf3 //also it can be used in an event stream:\cf0 \
	\cf3 //if the doneAction is 1 the synths pile up and do not get freed.\cf0 \
	(\
	\cf4 Pbind\cf0 (\
		\cf2 \\instrument\cf0 , \cf2 \\synthDefTest\cf0 ,\
		\cf2 \\freq\cf0 , \cf4 Pseq\cf0 ([500, 600, \cf4 Prand\cf0 ([200, 456, 345],1)], \cf4 inf\cf0 ),\
		\cf2 \\legato\cf0 , \cf4 Pseq\cf0 ([1.5, 0.2], \cf4 inf\cf0 ),\
		\cf2 \\dur\cf0 , 0.4\
	).play;\
	)\
	\
	\
	\
}