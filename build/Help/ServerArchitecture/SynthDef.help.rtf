{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red0\green115\blue0;\red191\green0\blue0;
\red0\green0\blue191;\red96\green96\blue96;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 SynthDef
\f1\b0\fs24 \
\
Evaluates a UGen function, generating a ugenGraph that describes the exact architecture of a Synth.  \
\
All constants, Controls, and UGens that will be used in synthesis are formatted for the Server and written to disk.  \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 *new(synthDefName,ugenGraphFunc, lags, prependArgs)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 	Create a synthDef instance, evaluate the ugenGraphFunc and build the ugenGraph.\
\
	Arguments to the ugenGraphFunc that begin with "i_" will be static and non-modulatable.\
		They will not respond to /n_set or /n_map.\
	Arguments to the ugenGraphFunc that begin with "t_" will be made as TrigControls. Setting \
		the value will create a k-rate impulse. This is useful for triggers.\
	Other arguments are all Float inputs, representing either values or bus indices\
		for use in In or Out.\
	Functions inside of a SynthDef are evaluated only at the time of building \
		the ugenGraph.  Once the graph is built, it is a fixed architecture.\
	lags is an Array of lagtimes for the ugenGraphFunc's arguments. Values other than 0 will result in \
		smoothing. Naturally t_ and i_  type arguments cannot be lagged.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 *writeOnce(synthDefName,ugenGraphFunc, lags, prependArgs, dir)\
	
\f1\b0 Create a new SynthDef and write it to disk, if a defFile with this name does not already exist.\
		This is useful in class definitions. Note that this will not check for differences, so you will \
		need to delete the defFile to get it to rebuild. Default for dir is synthdefs/\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs26 \cf0 \ul Instance Methods
\fs24 \ul \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 \ulnone 	
\f0\b \
name
\f1\b0 \
	return my name.\
	a SynthDef is always referred to by its name, which should be unique.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 \
writeDefFile(dir)
\f1\b0 \
	encode the graph into a file called name.scsyndef. Default for dir = synthdefs/
\f0\b \
\
load(server, completionMessage, dir)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 	write the defFile and send a message to the server to load this file.\
	when this asynchronous command is completed, the completionMessage is evaluated\
	default for dir is synthdefs/\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 send(server, completionMessage)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 	compile the def and send it to the server without writing to disk.\
	(thus avoiding that annoying SynthDef buildup)\
	when this asynchronous command is completed, the completionMessage is evaluated\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 play(target, args, addAction)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 	write the defFile and send a message to the server specified by target to load this file.\
	when this asynchronous command is completed, play one synth from this definition.\
	returns a synth object.\
	for a list of valid addActions see 
\f0\b Synth
\f1\b0 . The default is\cf2  \cf3 \\addtoTail\cf0 \
\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs26 \cf0 \ul Examples
\fs24 \ul \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \ulnone \
\cf2 (\
\cf4 // Note that SynthDef(...) is short for SynthDef.new(...).\cf2 \
\cf4 // Thus the following calls *new to create a SynthDef, and then .play on the resulting instance.\
// It is common to use similar constructions for .send, .load, and so on.\
\cf2 \
d = \cf5 SynthDef\cf2 (\cf6 "trigTest"\cf2 , \{ \cf5 arg\cf2  t_trig=0, freq=440; \cf4 // t_trig creates a TrigControl\cf2 \
	\cf5 Out\cf2 .ar(0, \cf5 SinOsc\cf2 .ar(freq+[0,1], 0, \cf5 Decay2\cf2 .kr(t_trig, 0.005, 1.0)));\
\
	\}, [0, 4]		\cf4 // lag the freq, but not t_trig (won't work anyway)\cf2 \
).play(s); 		\cf4 // .play returns a Synth object, assigned here to d.\cf2 \
)\
\
d.set(\cf3 \\t_trig\cf2 , 1); \cf4 // you can do this multiple times \cf2 \
\
d.set(\cf3 \\t_trig\cf2 , 1, \cf3 \\freq\cf2 , 220); \cf4 // hear how the freq lags\cf2 \
d.set(\cf3 \\t_trig\cf2 , 1, \cf3 \\freq\cf2 , 880);\
\
d.free;
\f1\fs24 \cf0 \
\
}