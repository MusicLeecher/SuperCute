{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red0\green115\blue0;\red191\green0\blue0;\red0\green0\blue191;
\red96\green96\blue96;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 Synth					
\fs24 client-side representation of a synth node on the server
\f1\b0 \
\

\f0\b superclass: Node
\f1\b0 \
\
A Synth is the client-side representation of a synth node on the server. A Synth represents a single sound producing unit.  What it does is defined in a 
\f0\b SynthDef
\f1\b0 , which specifies what UGens are used and how they are patched together.  It also specifies what inputs and outputs the Synth will have. A SynthDef is thus a kind of fixed pattern, upon which Synths are be based. (Despite this, a given SynthDef can provide a surprising amount of variation.) For more detail on SynthDefs, their construction, and how to send them to a server, see the 
\f0\b SynthDef
\f1\b0  help file.\
\
For more on the important distinction between client objects and server nodes, see 
\f0\b ClientVsServer
\f1\b0 . For information on creating nodes without using objects, see 
\f0\b NodeMessaging
\f1\b0 .\
\

\f0\b N.B. 
\f1\b0 Synth is a subclass of 
\f0\b Node
\f1\b0 , and thus many of its most useful and important methods are documented in the 
\f0\b Node
\f1\b0  help file.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 \ul \ulc0 Order of Execution\ulnone \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 \
Order of execution is a crucial issue when creating Synths which interact with each other.\

\f0\b \
	sound ->  filter\

\f1\b0 	\
If a sound is to be passed through a filter, the synth that does the filtering must be later in the order of execution than the synth which is its input.  The computer must calculate a buffer's worth of sound, and then the computer moves on to calculate a buffer's worth of the filtered version of that sound.\
\
The actual interconnection between synth nodes is accomplished with buses. See 
\f0\b Bus
\f1\b0  and 
\f0\b Server-Architecture
\f1\b0  for details.\
\
See the 
\f0\b Order-of-execution
\f1\b0  help file for a more detailed discussion of this important topic.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ri-620\ql\qnatural

\f0\b\fs28 \cf0 \ul Bundling
\f1\b0\fs24 \ulnone \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
Some of the methods below have two versions: a regular one which sends its corresponding message to the server immediately, and one which returns the message in an 
\f0\b Array
\f1\b0  so that it can be added to a bundle. It is also possible to capture the messages generated by the regular methods using Server's automated bundling capabilities. See 
\f0\b Server
\f1\b0  and 
\f0\b bundledCommands
\f1\b0  for more details.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ri-620\ql\qnatural

\f0\b\fs28 \cf0 \ul Accessing Instance Variables\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural

\fs24 \cf0 \ulnone \
	defName 
\f1\b0 - Returns the name of this Synth's SynthDef.\
	\
For other instance variables see 
\f0\b Node
\f1\b0 .\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ri-620\ql\qnatural

\f0\b\fs28 \cf0 \ul Creation with Immediate Instantiation on the Server
\fs24 \ulnone \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 	\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural
\cf0 	*new(defName, args: [ arg1, value1, ... argN, valueN  ], target, addAction)
\f1\b0 \
		\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural
\cf0 		Create and return a new Synth object, and immediately start the corresponding synth node on the server.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural
\cf0 		\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf0 		
\f0\b defName 
\f1\b0 - A 
\f0\b String
\f1\b0  or 
\f0\b Symbol
\f1\b0  specifying the name of the 
\f0\b SynthDef
\f1\b0  to use in creating the Synth.\
		\
		
\f0\b args 
\f1\b0 - An optional array specifying initial values for the SynthDef's arguments (controls). These are specified in pairs of control name or index and value. If names are used they can be specified with either Strings or Symbols. e.g. 
\f2\fs18 [\cf2 \\frequency\cf0 , 440, \cf2 \\amplitude\cf0 , 1, ...]\
		\
		
\f0\b\fs24 target 
\f1\b0 - A target for this Synth. If target is not a 
\f0\b Group
\f1\b0  or Synth, it will be converted as follows: If it is a 
\f0\b Server
\f1\b0 , it will be converted to the 
\f0\b default_group
\f1\b0  of that server. If it is nil, to the 
\f0\b default_group
\f1\b0  of the default Server. If it is an integer, it is created relative to a group with that id. \
			
\f0\b Note: 
\f1\b0 A Synth is not a valid target for 
\f2\fs18 \cf2 \\addToHead
\f1\fs24 \cf0  and 
\f2\fs18 \cf2 \\addToTail
\f1\fs24 \cf0 .\
		\
		
\f0\b addAction
\f1\b0  - one of the following Symbols:		\

\f2\fs18 			\cf2 \\addToHead 	
\f1\fs24 \cf0 - (the default) add at the head of the group specified by 
\f0\b target
\f1\b0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural

\f2\fs18 \cf0 			\cf2 \\addToTail 	
\f1\fs24 \cf0 - add at the tail of the group specified by 
\f0\b target
\f1\b0 \

\f2\fs18 			\cf2 \\addAfter
\f1\fs24 \cf0  	- add immediately after 
\f0\b target 
\f1\b0 in its server's node order\

\f2\fs18 			\cf2 \\addBefore
\f1\fs24 \cf0  	- add immediately before 
\f0\b target 
\f1\b0 in its server's node order\
			
\f2\fs18 \cf2 \\addReplace
\f1\fs24 \cf0  	- replace 
\f0\b target
\f1\b0  and take its place in its server's node order\
			\
		
\f2\fs18 s.boot;\
		\cf3 // create a Synth at the head of the default Server's default group\
		// based on the SynthDef "default"\cf0 \
		x = \cf4 Synth\cf0 .new("default"); \
		s.queryAllNodes; \cf3 // note the default group (ID 1)\cf0 \
		x.free;
\f1\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ri-620\ql\qnatural
\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 	*newPaused(defName, args: [ arg1, value1,... argN, valueN  ], target, addAction)\

\f1\b0 		\
		As 
\f0\b *new
\f1\b0  above, but creates a node which is paused. This can be started by calling run on it.\
		\
		
\f2\fs18 s.boot;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural
\cf0 		x = \cf4 Synth\cf0 .newPaused(\cf5 "default"\cf0 ); \
		s.queryAllNodes; \cf3 // see I'm here\cf0 \
		x.run; \cf3 // true is the default\cf0 \
		x.run(\cf4 false\cf0 ); \cf3 // pause me again\cf0 \
		x.free;
\f1\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 		\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural
\cf0 	
\f0\b *grain(defName, args: [ arg1, value1, ... argN, valueN  ], target, addAction)\
	\
		
\f1\b0 A convenience method which will create a synth node with an node ID of -1. Such a node cannot be messaged after creation. As such this method does not create an object, and returns nil. For details of its arguments see 
\f0\b *new
\f1\b0  above.\
		\
		\
The following convenience methods correspond to the add actions of 
\f0\b Synth.new
\f1\b0 :\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural

\f2\fs18 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural

\f0\b\fs24 \cf0 	*after(aNode, defName, args)\
		\
		
\f1\b0 Create and return a Synth and add it immediately after 
\f0\b aNode.
\f1\b0 \

\f0\b \
	*before(aNode, defName, args)\
		\
		
\f1\b0 Create and return a Synth and add it immediately before 
\f0\b aNode.
\f1\b0 \

\f0\b \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural

\f2\b0\fs18 \cf0 	
\f0\b\fs24 *head(aGroup, defName, args)\
	\
		
\f1\b0 Create and return a Synth. If 
\f0\b aGroup
\f1\b0  is a 
\f0\b Group
\f1\b0  add it at the head of that group. If it is a 
\f0\b Server
\f1\b0 , add it at the head of the 
\f0\b default_group
\f1\b0  of that server. If it is nil, add it at the head of the 
\f0\b default_group
\f1\b0  of the default server
\f0\b . 
\f1\b0 If it is an integer, it is created relative to a group with that id. \
				\

\f2\fs18 	
\f0\b\fs24 *tail(aGroup, defName, args)\
		\
		
\f1\b0 Create and return a Synth. If 
\f0\b aGroup
\f1\b0  is a 
\f0\b Group
\f1\b0  add it at the tail of that group. If it is a 
\f0\b Server
\f1\b0 , add it at the tail of the 
\f0\b default_group
\f1\b0  of that server. If it is nil, add it at the tail of the 
\f0\b default_group
\f1\b0  of the the default server
\f0\b . 
\f1\b0 If it is an integer, it is created relative to a group with that id. 
\f0\b \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural

\f1\b0 \cf0 		\
	
\f0\b *replace(nodeToReplace, defName, args)\
		\
		
\f1\b0 Create and return a Synth and use it to replace 
\f0\b nodeToReplace
\f1\b0 , taking its place in its server's node order.\
		\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ri-620\ql\qnatural

\f0\b\fs28 \cf0 \ul Creation without Instantiation on the Server\

\f1\b0\fs24 \ulnone \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 For use in message bundles it is also possible to create a Synth object in the client app without immediately creating a synth node on the server. Once done one can call methods which create messages to add to a bundle, which when sent to the server will instantiate the synth.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural
\cf0 \
	
\f0\b *basicNew(defName, server, nodeID)\
	\
		
\f1\b0 Create and return a Synth object without creating a synth node on the server. \
		\
		
\f0\b defName 
\f1\b0 - A 
\f0\b String
\f1\b0  or 
\f0\b Symbol
\f1\b0  specifying the name of the 
\f0\b SynthDef
\f1\b0  to use in creating the Synth.\
		\
		
\f0\b server
\f1\b0  - An optional instance of 
\f0\b Server
\f1\b0 . If nil this will default to the default 
\f0\b Server
\f1\b0 . \
		\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf0 		
\f0\b nodeID 
\f1\b0 - An optional node ID number. If not supplied one will be generated by the Server's NodeIDAllocator. Normally you should not need to supply an ID.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural
\cf0 		\
		
\f2\fs18 s.boot;\
		x = \cf4 Synth\cf0 .basicNew("default", s); \cf3 // Create without sending\cf0 \
		s.sendBundle(\cf4 nil\cf0 , x.newMsg;); \cf3 // Now send a message; create at the head of s' default group\cf0 \
		s.queryAllNodes;\
		x.free;
\f1\fs24 \
		\
	
\f0\b newMsg(target, args, addAction
\f1\b0 )
\f0\b \
	\
		
\f1\b0 Returns a message of the type 
\f0\b s_new
\f1\b0  which can be bundled. When sent to the server this message will instantiate this synth. If target is nil, it will default to the 
\f0\b default_group
\f1\b0  of the Server specified in 
\f0\b *basicNew
\f1\b0  when this Synth was created. The default addAction is 
\f2\fs18 \cf2 \\addToHead
\f1\fs24 \cf0 . (See 
\f0\b *new
\f1\b0  above for details of addActions and args.)\
		\
	
\f0\b addToHeadMsg(aGroup, args)
\f1\b0 \
	\
		Returns a message of the type 
\f0\b s_new
\f1\b0  which can be bundled. When sent to the server this message will instantiate this synth. If 
\f0\b aGroup
\f1\b0  is a 
\f0\b Group
\f1\b0  it will be added at the head of that group. If it is nil, it will be added at the head of the 
\f0\b default_group
\f1\b0  of this Synth's server (as specified when *
\f0\b basicNew
\f1\b0  was called). See 
\f0\b *new
\f1\b0  above for details on 
\f0\b args
\f1\b0 .\
		\
	
\f0\b addToTailMsg(aGroup, args)
\f1\b0 \
	\
		Returns a message of the type 
\f0\b s_new
\f1\b0  which can be bundled. When sent to the server this message will instantiate this synth. If 
\f0\b aGroup
\f1\b0  is a 
\f0\b Group
\f1\b0  it will be added at the tail of that group. If it is nil, it will be added at the tail of the 
\f0\b default_group
\f1\b0  of this Synth's server (as specified when *
\f0\b basicNew
\f1\b0  was called). See 
\f0\b *new
\f1\b0  above for details on 
\f0\b args
\f1\b0 .\
		\
	
\f0\b addBeforeMsg(aNode, args
\f1\b0 )
\f0\b \
	\
		
\f1\b0 Returns a message of the type 
\f0\b s_new
\f1\b0  which can be bundled. When sent to the server this message will instantiate this synth, immediately before 
\f0\b aNode
\f1\b0 . See 
\f0\b *new
\f1\b0  above for details on 
\f0\b args
\f1\b0 .\
		\
	
\f0\b addAfterMsg(aNode, args
\f1\b0 )
\f0\b \
	\
		
\f1\b0 Returns a message of the type 
\f0\b s_new
\f1\b0  which can be bundled. When sent to the server this message will instantiate this synth, immediately after 
\f0\b aNode
\f1\b0 . See 
\f0\b *new
\f1\b0  above for details on 
\f0\b args
\f1\b0 .\
		\
	
\f0\b addReplaceMsg(nodeToReplace, args
\f1\b0 )
\f0\b \
	\
		
\f1\b0 Returns a message of the type 
\f0\b s_new
\f1\b0  which can be bundled. When sent to the server this message will instantiate this synth, replacing 
\f0\b nodeToReplace
\f1\b0  in the server's node order. See 
\f0\b *new
\f1\b0  above for details on 
\f0\b args
\f1\b0 .\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural

\f0\b\fs28 \cf0 \ul Control\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural

\f1\b0\fs24 \cf0 \ulnone \
For further methods of controlling Synths (set, map, busMap, etc.), see the 
\f0\b Node
\f1\b0  helpfile.\
\
	
\f0\b get(index, action)\
	getMsg(index)
\f1\b0 \
		\
		Query the server for the current value of a 
\f0\b Control
\f1\b0  (argument). 
\f0\b index
\f1\b0  is a control name or index. 
\f0\b action
\f1\b0  is a 
\f0\b Function
\f1\b0  which will be evaluated with the value passed as an argument when the reply is received.\
		\
		
\f2\fs18 s.boot;\
		(\
		\cf4 SynthDef\cf0 (\cf5 "help-Synth-get"\cf0 , \{ \cf4 arg\cf0  freq = 440; \
			\cf4 Out\cf0 .ar(0, \cf4 SinOsc\cf0 .ar(freq, 0, 0.1));\
		\}).send(s);\
		)\
		x = \cf4 Synth\cf0 (\cf5 "help-Synth-get"\cf0 );\
		x.set(\cf2 \\freq\cf0 , 220 + 440.rand);\
		x.get(\cf2 \\freq\cf0 , \{ \cf4 arg\cf0  value; (\cf5 "freq is now:"\cf0  + value + \cf5 "Hz"\cf0 ).postln; \});\
		x.free;
\f1\fs24 \
		\
	
\f0\b getn(index, count, action)\
	getnMsg(index, count)
\f1\b0 \
		\
		Query the server for the current values of a sequential range of Controls (arguments). 
\f0\b index
\f1\b0  is a control name or index. 
\f0\b count
\f1\b0  is the number of sequential controls to query, starting at 
\f0\b index
\f1\b0 . 
\f0\b action
\f1\b0  is a 
\f0\b Function
\f1\b0  which will be evaluated with an 
\f0\b Array
\f1\b0  containing the values passed as an argument when the reply is received.	\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural

\f0\b\fs28 \cf0 \ul Examples
\f1\b0\fs24 \ul \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \ulnone \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 // boot the default server\cf0 \
s = \cf4 Server\cf0 .default; \cf3 // just to be sure\cf0 \
s.boot;\
\
\
(\
\cf3 // send a synth def to server\cf0 \
\cf4 SynthDef\cf0 (\cf5 "tpulse"\cf0 , \{ \cf4 arg\cf0  out = 0,freq = 700, sawFreq = 440.0; \
	\cf4 Out\cf0 .ar(out, \cf4 SyncSaw\cf0 .ar(freq, sawFreq, 0.1));\
\}).send(s);\
)\
\
\cf3 // Here the defaults for *new will result in a Synth at the head of the default group\cf0 \
\cf3 // of the default Server. This will use the SynthDef's default arguments;\cf0 \
y = \cf4 Synth\cf0 .new(\cf5 "tpulse"\cf0 ); \
y.free;\
\
\cf3 // The same done explicitly\cf0 \
y = \cf4 Synth\cf0 .new(\cf5 "tpulse"\cf0 , \cf4 nil\cf0 , s, \cf2 \\addToHead\cf0 ); \
y.free;\
\
\cf3 // With some arguments\cf0 \
y = \cf4 Synth\cf0 .new(\cf5 "tpulse"\cf0 , [\cf2 \\freq\cf0 , 350, \cf2 \\sawFreq\cf0 , 220]);\
y.free;\
\
\cf3 // make a new synth\cf0 \
y = \cf4 Synth\cf0 (\cf5 "tpulse"\cf0 );\
\
\cf3 // pause\cf0 \
y.run(\cf4 false\cf0 );\
\
y.run(\cf4 true\cf0 );\
\
\cf3 // set a control by argument name\cf0 \
y.set(\cf5 "freq"\cf0 , 200);\
\
\cf3 // or by index\cf0 \
y.set(2, 100.0);\
\
\cf3 // modulate out to bus number 1 (the right speaker)\cf0 \
y.set(0, 1);\
\
\cf3 //  multiple set commands in one message\cf0 \
y.set(\cf5 "out"\cf0 , 0, \cf5 "freq"\cf0 ,300);\
\
\cf3 // free the synth from the server\cf0 \
y.free;\
\
\
\
\cf3 //////////// Filtering\cf0 \
\
(\
\cf3 // first collect some things to play with\cf0 \
\cf4 SynthDef\cf0 (\cf5 "moto-rev"\cf0 , \{ \cf4 arg\cf0  out=0;\
	\cf4 var\cf0  x;\
	x = \cf4 RLPF\cf0 .ar(\cf4 LFPulse\cf0 .ar(\cf4 SinOsc\cf0 .kr(0.2, 0, 10, 21), [0,0.1], 0.1), \
		100, 0.1).clip2(0.4);\
	\cf4 Out\cf0 .ar(out, x);\
\}).send(s);\
\
\cf4 SynthDef\cf0 (\cf5 "bubbles"\cf0 , \{ \cf4 arg\cf0  out=0;\
	\cf4 var\cf0  f, zout;\
	f = \cf4 LFSaw\cf0 .kr(0.4, 0, 24, \cf4 LFSaw\cf0 .kr([8,7.23], 0, 3, 80)).midicps; \
	zout = \cf4 CombN\cf0 .ar(\cf4 SinOsc\cf0 .ar(f, 0, 0.04), 0.2, 0.2, 4); \cf3 // echoing sine wave\cf0 \
	\cf4 Out\cf0 .ar(out, zout);\
\}).send(s);\
\
\
\cf4 SynthDef\cf0 (\cf5 "rlpf"\cf0 ,\{ \cf4 arg\cf0  out=0,ffreq=600,rq=0.1;\
	\cf4 ReplaceOut\cf0 .ar( out, \cf4 RLPF\cf0 .ar( \cf4 In\cf0 .ar(out), ffreq,rq) )\
\}).send(s);\
\
\
\cf4 SynthDef\cf0 (\cf5 "wah"\cf0 , \{ \cf4 arg\cf0  out, rate = 1.5, cfreq = 1400, mfreq = 1200, rq=0.1;\
	\cf4 var\cf0  zin, zout;\
\
	zin = \cf4 In\cf0 .ar(out, 2);\
	cfreq = \cf4 Lag3\cf0 .kr(cfreq, 0.1);\
	mfreq = \cf4 Lag3\cf0 .kr(mfreq, 0.1);\
	rq   = \cf4 Ramp\cf0 .kr(rq, 0.1);\
	zout = \cf4 RLPF\cf0 .ar(zin, \cf4 LFNoise1\cf0 .kr(rate, mfreq, cfreq), rq, 10).distort \
					* 0.15;\
\
	\cf3 // replace the incoming bus with the effected version\cf0 \
	\cf4 ReplaceOut\cf0 .ar( out , zout ); \
	\
\}).send(s);\
\
\cf4 SynthDef\cf0 (\cf5 "modulate"\cf0 ,\{ \cf4 arg\cf0  out = 0, freq = 1, center = 440, plusMinus = 110;\
	\cf4 Out\cf0 .kr(out, \cf4 SinOsc\cf0 .kr(freq, 0, plusMinus, center));\
\}).send(s);\
)\
\
\cf3 // execute these one at a time\cf0 \
\
\cf3 // y is playing on bus 0\cf0 \
y = \cf4 Synth\cf0 (\cf5 "moto-rev"\cf0 ,[\cf5 "out"\cf0 ,0]);\
\
\cf3 // z is reading from bus 0 and replacing that; It must be *after* y\cf0 \
z = \cf4 Synth\cf0 .after(y,\cf5 "wah"\cf0 ,[\cf5 "out"\cf0 ,0]);\
\
\cf3 // stop the wah-ing\cf0 \
z.run(\cf4 false\cf0 );\
\
\cf3 // resume the wah-ing\cf0 \
z.run(\cf4 true\cf0 );\
\
\cf3 // add a rlpf after that, reading and writing to the same buss\cf0 \
x = \cf4 Synth\cf0 .after(z,\cf5 "rlpf"\cf0 ,[\cf5 "out"\cf0 ,0]);\
\
\cf3 // create another rlpf after x\cf0 \
t = \cf4 Synth\cf0 .after(x,\cf5 "rlpf"\cf0 ,[\cf5 "out"\cf0 ,0]);\
\
x.set(\cf5 "ffreq"\cf0 , 400);\
\
x.set(\cf2 \\ffreq\cf0 , 800); \cf3 // Symbols work for control names too\cf0 \
\
\cf3 // Now let's modulate x's ffreq arg\cf0 \
\cf3 // First get a control Bus\cf0 \
b = \cf4 Bus\cf0 .control(s, 1);\
\
\cf3 // now the modulator, *before* x\cf0 \
m = \cf4 Synth\cf0 .before(x, \cf5 "modulate"\cf0 , [\cf2 \\out\cf0 , b.index]);\
\cf3 \
// now map x's ffreq to b\cf0 \
x.busMap(\cf5 "ffreq"\cf0 , b);\
\
m.set(\cf5 "freq"\cf0 , 4, \cf5 "plusMinus"\cf0 , 20);\
\
x.free;\
z.free;\
m.free;\
\
\cf3 // now place another synth after y, on the same bus\cf0 \
\cf3 // they both write to the buss, adding their outputs\cf0 \
r = \cf4 Synth\cf0 .after(y,\cf5 "bubbles"\cf0 ,[\cf5 "out"\cf0 ,0]);\
\
y.free;\
\
r.free;\
\
\cf3 // look at the Server window\cf0 \
\cf3 // still see 4 Ugens and 1 synth?\cf0 \
\cf3 // you can't hear me, but don't forget to free me\cf0 \
t.free;\
\
\
\
\
\
\
\
\
}