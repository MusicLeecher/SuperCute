{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue191;\red96\green96\blue96;
\red0\green115\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs38 \cf0 Bundled Server Messages
\f1\b0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs24 \cf0 Using Synth/Node/Group sclang objects to build classes often\
there is the need to construct bundles to send messages together.\
One example is you want to start a synth that should be mapped\
instantly to certain buses.\
\
This extension uses a list that is passed to all message methods\
which add their message to it and do all needed preparation on \
language side. \
\

\f0\b Note
\f1\b0 : you have to use this with care. Normally the other ways\
of creating Synths and Groups are more safe.\
\
aNode.
\f0\b msgToBundle
\f1\b0 (bundle, cmdName, argList) \
	adds a message to the bundle (a list)\
aNode.
\f0\b getMsg
\f1\b0 (cmdName or number, argList) \
	returns a message\
\

\f0\b instance creation and adding to a bundle ( usually a List )
\f1\b0 \
\
Synth.
\f0\b newToBundle
\f1\b0 (bundle, defName, argList, target, addAction)\
	returns a new synth and adds commands to the bundle\
	all initialisations and registring the node are done\
\
Group.
\f0\b newToBundle
\f1\b0 (bundle, target, addAction)\
	returns a new synth and adds commands to the bundle\
	all initialisations and registring the node are done\
\
\

\f0\b creating messages that can be added to a bundle\

\f1\b0 \
aSynth.
\f0\b newMsg
\f1\b0 (target, addAction, argList) \
	use this with a synth that was created by prNew(defName).\
	all initialisations and registring the node are done\
	\
aGroup.
\f0\b newMsg
\f1\b0 (target, addAction) \
	use this with a group that was created by prNew\
	all initialisations and registring the node are done\
\
aNode.
\f0\b moveBeforeMsg
\f1\b0 (aNode)\
	returns a message that causes the server to move this node before another one\
\
analogous messages: \

\f0\b moveAfterMsg / moveToHeadMsg / moveToTailMsg / \
moveNodeToHeadMsg / moveNodeToTailMsg
\f2\b0\fs20 \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 //prepare some def\cf0 \
s = \cf3 Server\cf0 .local;\
s.boot;
\f1\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs20 \cf0 (\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 SynthDef\cf0 (\cf4 "void"\cf0 , \{ \cf3 arg\cf0  freq=800, out=0;\
	\cf3 Out\cf0 .ar(out, \cf3 SinOsc\cf0 .ar(\cf3 SinOsc\cf0 .ar(\cf3 SinOsc\cf0 .kr([2,1.1],0,8,12),freq*0.3,freq), 0, 0.2));\
\}).send(s);\
)
\f1\fs24 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs20 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 //create a list to add all messages\cf0 \
b = \cf3 List\cf0 .new; \
\cf2 //return an in instance of synth (registered) and adds the message to the list \cf0 \
y = \cf3 Synth\cf0 .newToBundle(b, \cf4 "void"\cf0 );\
\
\cf2 //add a couple of messages\cf0 \
b.add(y.getMsg(\cf4 "/n_set"\cf0 , [\cf5 \\freq\cf0 , 500]));\
b.add(y.getMsg(\cf4 "/n_set"\cf0 , [\cf5 \\out\cf0 , 0]));\
\
\cf2 //create a second list to add message\cf0 \
\
c = [y.getMsg(\cf4 "/n_free"\cf0 )];\
\
\cf2 //send the messages (do this only once.)\cf0 \
(\
s.listSendBundle(1, b); \cf2 //start after one sec.\cf0 \
s.listSendBundle(1.1, c);\cf2 //runs for exactly 0.1 sec.\cf0 \
)\
\
\
}