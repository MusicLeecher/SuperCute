{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 Server
\f1\b0\fs24 			
\f0\b object representing an sc-server application
\f1\b0 \
\
\
superclass: Model\
\
\
Server is used to control an sc-server application from sc-lang. It forwards osc-messages\
and keeps a number of allocators that return id's for nodes, buses and buffers. The server\
application is a commandline program, so all commands apart from the osc-messages\
are unix commands.\
\
\ul instance creation:\ulnone \
\
	
\f0\b *new(name, address, options, clientID)
\f1\b0 \
		\
			
\f0\b name
\f1\b0  	\
					each server object is stored in one global classvariable under its name.\
			\
			
\f0\b address
\f1\b0  	\
					instance of 
\f0\b NetAddr
\f1\b0 , providing host and port\
			\
			
\f0\b options
\f1\b0 	\
					instance of 
\f0\b ServerOptions
\f1\b0 , providing all special options\
			\
			
\f0\b clientID
\f1\b0 	an integer. \
					in multi client situations, every client can be given a separate nodeID range\
	\
	
\f0\b *local
\f1\b0 \
			returns the local server, stored in classvar local (created already on initClass)\
	\
	
\f0\b *internal
\f1\b0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 			returns the local server, stored in classvar local (created already on initClass)\
			\
\
\ul instance methods:\ulnone \
			\
	
\f0\b sendMsg(arg1, arg2, arg3, ... argN)
\f1\b0 \
	\
			send an osc message to the server.\
			\
			s.sendMsg("/s_new", "default", 1980, 0);\
			\
	
\f0\b sendBundle(time, array1, array1, array1, ... arrayN)
\f1\b0 \
			\
			send  osc bundles to the server.\
			\
			time:  \
				as the network might have irregular performance the message is \
				scheduled to be evaluated the future so that all messages are synchroneous\
				relative to each other, but delayed by a constant offset.\
				if such a bundle arrives late, the server replies with a late message but still evaluates it.				\
			\
			s.sendBundle(0.2, ["/s_new", "default", 1980, 0], ["/n_map", 1980, "freq", 0]);\
			\
	
\f0\b sendRaw(aRawArray)
\f1\b0 \
	\
	
\f0\b listSendMsg([arg1, arg2, arg3, ... argN])\
	
\f1\b0 \
			same like sendMsg, but takes an array as argument\
			\
	
\f0\b listSendBundle(time, [array1, array1, array1, ... arrayN])\
	
\f1\b0 \
			same like sendMsg, but takes an array as argument, which allows to send a list of bundles\
			\
	
\f0\b sendSynthDef(name, directory)\
		
\f1\b0 \
			send a synthDef to the server that was written in a local directory\
			\
	
\f0\b loadSynthDef(name, completionMsg, directory)\

\f1\b0 \
			load a synthDef that resides in the remote directory\
			\
	
\f0\b nextNodeID
\f1\b0 \
			get a unique nodeID. if the synth is freed, also the nodeID is freed by the NodeIDWatcher \
			\
	
\f0\b wait(responseName)
\f1\b0 \
			this can be used within a Routine to wait for a server reply\
			\
	
\f0\b waitForBoot(func, limit)
\f1\b0 \
			evaluate the function as soon as the server has booted. \
			if it is running, it is evaluated immediately.\
			if it is not running, boot the server and evaluate the function.\
			limit: maximum times to try. (5 times/sec)\
	\
	
\f0\b doWhenBooted(func, limit)
\f1\b0 \
			evaluate the function as soon as the server has booted. \
			if it is running, it is evaluated immediately.\
			limit: maximum times to try. (5 times/sec)\
			\
	
\f0\b boot(startAliveThread)
\f1\b0 \
			boot the remote server, create new allocators.\
			startAliveThread: if set to false, the server is not queried to give information for the window.\
	\
	
\f0\b quit
\f1\b0 \
			quit the server application\
			\
	
\f0\b reboot
\f1\b0 \
			quit and restart the server application\
	\
	
\f0\b *quitAll
\f1\b0 \
			quit all registered servers\
			\
	
\f0\b *killAll
\f1\b0 \
			query the system for any sc-servers and quit them\
			\
	
\f0\b *freeAll
\f1\b0 \
			free all nodes in all servers\
			\
	
\f0\b freeAll
\f1\b0 \
			free all nodes in this server \
			\
	
\f0\b status
\f1\b0 \
			query the server status\
	\
	\
	
\f0\b notify(flag)
\f1\b0 \
			server sends notifications, for example if a node was created, a 'tr' message from a SendTrig,\
			or a /done action. if flag is set to false, these messages are not sent.\
	\
	\
	
\f0\b dumpOSC(code)
\f1\b0 \
		
\f2\fs18 \cf2 	0 - turn dumping OFF.\
			1 - print the parsed contents of the message.\
			2 - print the contents in hexadecimal.\
			3 - print both the parsed and hexadecimal representations of the contents.\
		
\f1\fs24 \cf0 \
	\
	\
			\
			\
			\
			\
			}