{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red96\green96\blue96;\red191\green0\blue0;\red0\green0\blue191;
\red0\green115\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 Server
\f1\b0\fs24 			
\f0\b object representing an sc-server application
\f1\b0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 superclass: Model
\f1\b0 \
\
A Server object is the client-side representation of a server app and is used to control the app from the SuperCollider language application. (See 
\f0\b ClientVsServer
\f1\b0  for more details on the distinction.) It forwards osc-messages and has a number of allocators that keep track of IDs for nodes, buses and buffers. The server application is a commandline program, so all commands apart from osc-messages are unix commands. The server application represented by a Server object might be running on the same machine as the client (in the same address space as the language application or separately; see below), or it may be running on a remote machine. \
\
Most of a Server's options are contolled through its instance of 
\f0\b ServerOptions
\f1\b0 . See the 
\f0\b ServerOptions
\f1\b0  helpfile for more detail.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs30 \cf0 \ul \ulc0 Paths
\f1\b0\fs24 \ulnone \
\
Server apps running on the local machine have two unix environment variables: SC_SYNTHDEF_PATH and SC_PLUGIN_PATH. These indicate directories of synthdefs and ugen plugins that will be loaded at startup. These are in addition to the default synthdef/ and plugin/ directories which are hard-coded. These can be set within SC using the getenv and setenv methods of class 
\f0\b String
\f1\b0 .\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf2 "SC_SYNTHDEF_PATH"\cf0 .setenv(\cf2 "~/scwork/"\cf0 ); \cf3 // all defs in this directory will be loaded at startup\cf0 \
\cf2 "echo $SC_SYNTHDEF_PATH"\cf0 .unixCmd;
\f1\fs24 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs30 \cf0 \ul The default group\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 \ulnone \
When a Server is booted there is a top level group with an ID of 0 that defines the root of the node tree. (This is represented by a subclass of Group: 
\f0\b RootNode
\f1\b0 .) There is also a 
\f0\b default_group
\f1\b0  with an ID of 1, which is the default group for all Nodes when using object style. This provides a predictable basic node tree so that methods such as Server-scope, Server-record, etc. can function without running into order of execution problems. The default group is persistent, i.e. it is recreated after a reboot, pressing cmd-., etc. See 
\f0\b RootNode
\f1\b0  and 
\f0\b default_group
\f1\b0  for more information.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs30 \cf0 \ul Local vs. Internal
\f1\b0\fs24 \ulnone \
\
In general, when working with a single machine one will probably be using one of two Server objects which are created at startup and stored in the class variables 
\f0\b local
\f1\b0  and 
\f0\b internal
\f1\b0 . By default two GUI windows are created to control these. The difference between the two is that the local server runs as a separate application with its own address space, and the internal server runs within the same space as the language/client app. The internal server has the advantage of being able to access shared memory, thus allowing for things like scope windows (see below) and 
\f0\b SharedIn
\f1\b0 /
\f0\b SharedOut
\f1\b0 . It also minimizes messaging latency. The local server, and any other server apps running on your local machine, have the advantage that if the language app crashes, it (and thus possibly your piece) will continue to run. It is thus an inherently more robust arrangement.\
\

\f0\b\fs30 \ul The default Server\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 \ulnone There is always a default Server, which is stored in the class variable 
\f0\b default
\f1\b0 . Any Synths or Groups created without a target will be created on the default server. At startup this is set to be the 
\f0\b local
\f1\b0  server (see above), but can be set to be any Server.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs30 \cf0 \ul Class Methods
\f1\b0\fs24 \ulnone \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 *new(name, addr, options, clientID)
\f1\b0 \
	\

\f0\b name
\f1\b0  
\f0\b - 
\f1\b0 a symbol;  each Server object is stored in one global classvariable under its name.\

\f0\b addr - 
\f1\b0 an optional instance of 
\f0\b NetAddr
\f1\b0 , providing host and port. The default is the localhost address using port 57110; the same as the local server.\

\f0\b options
\f1\b0  
\f0\b - 
\f1\b0 an optional instance of 
\f0\b ServerOptions
\f1\b0 . If nil, an instance of ServerOptions will be created, using the default values.\

\f0\b clientID - 
\f1\b0 an integer. In multi client situations, every client can be given a separate nodeID range. The default is 0.\
\

\f0\b *local - 
\f1\b0 returns the local server, stored in classvar local (created already on initClass)\
\

\f0\b *internal - 
\f1\b0 returns the internal server, stored in classvar local (created already on initClass)\

\f0\b \
*default - 
\f1\b0 returns the default server. By default this is the local server (see above)\
\

\f0\b *default(aServer) - 
\f1\b0 sets the default Server to be aServer\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf4 	Server\cf0 .default = \cf4 Server\cf0 .internal; \cf3 // set the internal Server to be the default Server
\f1\fs24 \cf0 \
		\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 *quitAll - 
\f1\b0 quit all registered servers\
		\

\f0\b *killAll - 
\f1\b0 query the system for any sc-server apps and hard quit them\
		\

\f0\b *freeAll - 
\f1\b0 free all nodes in all registered servers	\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs30 \cf0 \ul Instance Methods
\f1\b0\fs24 \ulnone \
			\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 sendMsg(arg1, arg2, arg3, ... argN) - 
\f1\b0 send an osc message to the server.\
		\
	
\f2\fs18 s.sendMsg(\cf2 "/s_new"\cf0 , \cf2 "default"\cf0 , s.nextNodeID, 0, 1);
\f1\fs24 \
\

\f0\b sendBundle(time, array1, array1, array1, ... arrayN) - 
\f1\b0 send an osc bundle to the server. Since the network may have irregular performance, 
\f0\b time
\f1\b0  allows for the bundle to be evaluated at a specified point in the future. Thus all messages are synchronous relative to each other, but delayed by a constant offset. If such a bundle arrives late, the server replies with a late message but still evaluates it.				\
	
\f2\fs18 s.sendBundle(0.2, [\cf2 "/s_new"\cf0 , \cf2 "default"\cf0 , x = s.nextNodeID, 0, 1], [\cf2 "/n_set"\cf0 , x, \cf2 "freq"\cf0 , 500]);
\f1\fs24 \
		\

\f0\b sendRaw(aRawArray)
\f1\b0 \
\

\f0\b listSendMsg([arg1, arg2, arg3, ... argN]) - 
\f1\b0 as sendMsg, but takes an array as argument.\
		\

\f0\b listSendBundle(time, [array1, array1, array1, ... arrayN]) - 
\f1\b0 as sendBundle, but takes an array as argument. This allows you to collect messages in an array and then send them.\
\
	
\f2\fs18 s.listSendBundle(0.2, [[\cf2 "/s_new"\cf0 , \cf2 "default"\cf0 , x = s.nextNodeID, 0, 1], \
		[\cf2 "/n_set"\cf0 , x, \cf2 "freq"\cf0 , 600]]);
\f1\fs24 \
		\

\f0\b sendSynthDef(name, dir) - 
\f1\b0 send a synthDef to the server that was written in a local directory\
		\

\f0\b loadSynthDef(name, completionMsg, dir) - 
\f1\b0 load a synthDef that resides in the remote directory\
\

\f0\b loadDirectory(dir, completionMsg) - 
\f1\b0 load all the SynthDefs in the directory 
\f0\b dir
\f1\b0 . 
\f0\b dir
\f1\b0  is a String which is a valid path.\
		\

\f0\b nextNodeID - 
\f1\b0 get a unique nodeID. When this node is freed, the nodeID will be freed by this server's NodeIDWatcher. This is useful when using messaging style as it helps to avoid any ID conflicts with automatically created nodes such as those used for recording or scopes (see below).\
		\

\f0\b wait(responseName) - 
\f1\b0 this can be used within a Routine to wait for a server reply\
		\

\f0\b waitForBoot(func, limit) - 
\f1\b0 evaluate the function 
\f0\b func 
\f1\b0 as soon as the server has booted. If it is running, it is evaluated immediately. If it is not running, boot the server and evaluate the function. 
\f0\b limit
\f1\b0  indicates the maximum times to try. (5 times/sec)\
\

\f0\b doWhenBooted(func, limit) - 
\f1\b0 evaluate the function as soon as the server has booted. If it is running, it is evaluated immediately. 
\f0\b limit 
\f1\b0 is the maximum number of times to try. (5 times/sec)\
		\

\f0\b boot(startAliveThread) -
\f1\b0  boot the remote server, create new allocators. 
\f0\b startAliveThread
\f1\b0 : if set to false, the server is not queried to give information for the window.\
\

\f0\b quit - 
\f1\b0 quit the server application\
		\

\f0\b reboot - 
\f1\b0 quit and restart the server application\
		\

\f0\b freeAll - 
\f1\b0 free all nodes in this server \
		\

\f0\b status - 
\f1\b0 query the server status\
\

\f0\b notify(flag) - 
\f1\b0 server sends notifications, for example if a node was created, a 'tr' message from a SendTrig, or a /done action. if flag is set to false, these messages are not sent. The default is true.
\f0\b \
\
dumpOSC(code)\
	code
\f1\b0 :\
		0 - turn dumping OFF.\
		1 - print the parsed contents of the message.\
		2 - print the contents in hexadecimal.\
		3 - print both the parsed and hexadecimal representations of the contents.\
		\

\f0\b queryAllNodes - 
\f1\b0 Post a representation of this Server's current node tree to the post window. Very helpful for debugging.
\f2\fs18 \cf3 \
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 	s.boot;\
	s.queryAllNodes; \cf3 // note the root node (ID 0) and the default group (ID 1)\cf0 \
	s.quit;\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 options - 
\f1\b0 returns this Server's 
\f0\b ServerOptions
\f1\b0  object. Changes take effect when the server is rebooted.\
\

\f0\b options_(aServerOptions) - 
\f1\b0 sets this Server's 
\f0\b ServerOptions
\f1\b0  object. Changes take effect when the server is rebooted.
\f2\fs18 \
	\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs30 \cf0 \ul Automatic Message Bundling\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 \ulnone Server provides support for automatically bundling messages. This is quite convenient in object style. \

\f0\b NOTE:
\f1\b0  Once a bundle is opened (by calling 
\f0\b openBundle
\f1\b0  or any of the add messages below) all osc messages sent to the server (whether by objects or through methods such as 
\f0\b sendMsg
\f1\b0 , above) will be deferred until the bundle is closed or set to nil.\
\

\f0\b openBundle
\f1\b0  - This creates an empty bundle and starts message deferral.\
\

\f0\b addMsgToBundle(...msg) 
\f1\b0 - add a message (either a list of args or an array) to the bundle. If there is no current bundle this will create one and start message deferral..\
\

\f0\b addBundleToBundle(msg) 
\f1\b0 - add a bundle to the bundle. If there is no current bundle this will create one and start message deferral.\
\

\f0\b closeBundle
\f1\b0  - Close the bundle and return it. Normal operation resumes.\
\

\f0\b closeSendBundle
\f1\b0  - Close the bundle and send it. Normal operation resumes.\
\

\f0\b bundle
\f1\b0  - Gets the current bundle.\
\

\f0\b bundle_(aBundle) 
\f1\b0 - Sets the current bundle. Setting this to anything other than nil will begin message deferral.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 	s.boot;\
	(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 	// send a synth def to server\cf0 \
\cf4 	SynthDef\cf0 (\cf2 "tpulse"\cf0 , \{ \cf4 arg\cf0  out=0,freq=700,sawFreq=440.0;\
		\cf4 Out\cf0 .ar(out, \cf4 SyncSaw\cf0 .ar(freq,  sawFreq,0.1) )\
	\}).send(s);\
	)\
\
	s.openBundle;\
	y = \cf4 Synth\cf0 .new(\cf2 "tpulse"\cf0 );\
	y.set(\cf5 \\freq\cf0 , 800); \cf3 // won't send yet\cf0 \
	s.closeSendBundle;\
	y.set(\cf5 \\freq\cf0 , 500);\
	y.free;\
	
\f1\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs30 \cf0 \ul \
Shared Controls\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs24 \cf0 \ulnone \

\f1\b0 The internal server has a number of shared control buses. Their values can be set or polled using the methods below.\
\

\f0\b getSharedControl(num)
\f1\b0  - get the current value of a shared control bus. 
\f0\b num
\f1\b0  is the index of the bus to poll. This command is synchronous and only works with the internal server.\
\

\f0\b setSharedControl(num, value)
\f1\b0  - set the current value of a shared control bus to 
\f0\b value
\f1\b0 . 
\f0\b num
\f1\b0  is the index of the bus to set. This command is synchronous and only works with the internal server.\
\

\f0\b allocSharedControls(numControls)
\f1\b0  - set the number of shared control buses. Must be done before the internal server is booted. The default is 1024.\
\

\f0\b \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs30 \cf0 \ul Persistent Node Trees\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs24 \cf0 \ulnone \

\f1\b0 The instance variable 
\f0\b tree
\f1\b0  can be used to store a function which will be evaluated after the server is booted, after all nodes are freed, and after cmd-. is pressed. This allows, for example, for one to create a persistent basic node structure. 
\f0\b tree
\f1\b0  is evaluated after the default group is created, so its existence can be relied upon.\
 		\

\f0\b tree_(aFunction) - 
\f1\b0 sets the function to be evaluated\
\
	
\f2\fs18 s.quit;\
	s.tree = \{\cf4 Group\cf0 .new(s.defaultGroup); \cf2 "Other code can be evaluated too"\cf0 .postln;\};\
	s.boot;\
	s.queryAllNodes; \cf3 // note the group within the default group\cf0 \
	s.tree = \cf4 nil\cf0 ; s.quit; \cf3 // reset to default
\f0\b\fs24 \cf0 \
		
\f2\b0\fs18 \cf3 \

\f0\b\fs24 \cf0 tree - 
\f1\b0 returns the contents of this Server's tree instance variable (most likely a Function).\
	
\f0\b \
defaultGroup - 
\f1\b0 returns this Server's default group.
\f2\fs18 \cf3 \

\f1\fs24 \cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs30 \cf0 \ul Scope Support
\f1\b0\fs24 \ulnone \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 \

\f1\b0 This only works with the internal server, and currently only on OSX.\
see
\f0\b  [Stethoscope] 
\f1\b0 for further details.\

\f0\b \
scope(numChannels, index, bufsize, zoom, rate) - 
\f1\b0 Open a scope window showing the output of the Server. \
		\

\f0\b numChannels 
\f1\b0 - the number of channels to be scoped out. The default is this server's options' numOutputBusChannels.\

\f0\b index 
\f1\b0 - the first channel to be output. The default is 0.\

\f0\b bufsize 
\f1\b0 - the size of the buffer for the ScopeView. The default is 4096.\

\f0\b zoom
\f1\b0  - a zoom value for the scope's X axis. Larger values show more. The default is 1.\

\f0\b rate
\f1\b0  - whether to display audio or control rate buses (either \\audio or \\control)\
		\
		\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs30 \cf0 \ul Recording Support
\fs24 \ulnone \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 The following methods are for convenience use. For recording with sample accurate start and stop times you should make your own nodes. See the 
\f0\b DiskOut
\f1\b0  helpfile for more info. For non-realtime recording, see the 
\f0\b Non-Realtime-Synthesis
\f1\b0  helpfile. \
\
This functionality is also available through the recording button on the server windows. Pressing it once calls 
\f0\b prepareForRecord
\f1\b0 , pressing it again calls 
\f0\b record
\f1\b0 , and pressing it a third time calls 
\f0\b stopRecording
\f1\b0  (see below). When doing so the file created will be in the recordings/ folder and be named for the current date and time.\
\

\f0\b NOTE:
\f1\b0  
\f0\b record
\f1\b0  creates the recording synth after the Server's default group and uses 
\f0\b In.ar
\f1\b0 . Thus if you add nodes after the recording synth their output will not be captured. To avoid this, either use 
\f0\b Node
\f1\b0  objects (which use the default node as their target) or (when using messaging style) use a target nodeID of 1 .\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf4 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 s.sendMsg(\cf2 "/s_new"\cf0 , \cf2 "default"\cf0 , s.nextNodeID, 1,1);
\f1\fs24 \
\
For more detail on this subject see 
\f0\b Order-of-execution,
\f1\b0  
\f0\b default_group
\f1\b0 , and 
\f0\b NodeMessaging
\f1\b0 .\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 \
prepareForRecord(path) - 
\f1\b0 Allocates the necessary buffer, etc. for recording the server's output. (See 
\f0\b record
\f1\b0  below.) 
\f0\b path 
\f1\b0 is a String representing the path and name of the output file. If you do not specify a path than a file will be created in the folder recordings/ called SC_thisDateAndTime. Changes to the header or sample format, or to the number of channels must be made BEFORE calling this.\
		\

\f0\b record - 
\f1\b0 Starts or resumes recording the output. You must have called prepareForRecord first (see above).\
			\

\f0\b pauseRecording - 
\f1\b0 Pauses recording. Can be resumed by executing record again.\
		\

\f0\b stopRecording - 
\f1\b0 Stops recording, closes the file, and frees the associated resources. You must call this when finished recording or the output file will be unusable. Cmd-. while recording has the same effect.\
		\

\f0\b recordNode - 
\f1\b0 Returns the current recording synth so that it can be used as a target. This should only be necessary for nodes which are not created in the default group.\
\
\
The following setter methods have corresponding getters. See 
\f0\b SoundFile
\f1\b0  for information on the various sample and header formats.	Not all sample and header formats are compatible.\
\

\f0\b recChannels_(anInteger) - 
\f1\b0 Sets the number of channels to record. The default is two. Must be called BEFORE prepareForRecord.\
\

\f0\b recHeaderFormat_(aString) - 
\f1\b0 Sets the header format of the output file. The default is "aiff". Must be called BEFORE prepareForRecord.\
	
\f0\b \
recSampleFormat_(aString) - 
\f1\b0 Sets the sample format of the output file. The default is "float". Must be called BEFORE prepareForRecord.\
\
Note that the sampling rate of the ouput file will be the same as that of the server app. This can be set using the Server's 
\f0\b ServerOptions
\f1\b0 .\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 s.boot; \cf3 // start the server\cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 // something to record\cf0 \
(\
\cf4 SynthDef\cf0 (\cf2 "bubbles"\cf0 , \{\
	\cf4 var\cf0  f, zout;\
	f = \cf4 LFSaw\cf0 .kr(0.4, 0, 24, \cf4 LFSaw\cf0 .kr([8,7.23], 0, 3, 80)).midicps; \cf3 // glissando function\cf0 \
	zout = \cf4 CombN\cf0 .ar(\cf4 SinOsc\cf0 .ar(f, 0, 0.04), 0.2, 0.2, 4); \cf3 // echoing sine wave\cf0 \
	\cf4 Out\cf0 .ar(0, zout);\
\}).send(s);\
\cf4 SynthDef\cf0 (\cf2 "tpulse"\cf0 , \{ \cf4 arg\cf0  out=0,freq=700,sawFreq=440.0; \
	\cf4 Out\cf0 .ar(out, \cf4 SyncSaw\cf0 .ar(freq,  sawFreq,0.1) ) \
\}).send(s);\
\
)\
\
x = \cf4 Synth\cf0 .new(\cf2 "bubbles"\cf0 );\
\
s.prepareForRecord; \cf3 // you have to call this first\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
s.record;\
\
s.pauseRecording; \cf3 // pausable\
\cf0 \
s.record \cf3 // start again\
\cf0 \
s.stopRecording; \cf3 // this closes the file and deallocates the buffer recording node, etc.\
\
\cf0 x.free; \cf3 // stop the synths\
\
// look in the recordings/ folder and you'll find a file named for this date and time\
\
\
\
\
}