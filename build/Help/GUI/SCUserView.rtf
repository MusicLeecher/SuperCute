{\rtf1\mac\ansicpg10000\cocoartf824\cocoasubrtf330
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red0\green0\blue191;\red191\green0\blue0;
\red0\green115\blue0;\red96\green96\blue96;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\f0\b\fs36 \cf0 SCUserView				
\fs28 user-definable view
\f1\b0\fs24 \cf0 \
\

\f0\b superclass: SCView
\f1\b0 \
\
SCUserView is a user-definable View intended mainly for use with Pen and drawHooks.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 See also: 
\f0\b [\ul SCWindow\ulnone ]
\f1\b0 , 
\f0\b [\ul Pen\ulnone ], [\ul Color\ulnone ]
\f1\b0 , and 
\f0\b [\ul String\ulnone ]
\f1\b0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural
\cf0 \

\f0\b keyDownFunc_\

\f1\b0 \
	set a.multiply(b)the function which should be evaluated if the view is in focus and a key is pressed.\
\

\f0\b drawFunc_\

\f1\b0 \
	set the function which should be evaluated if the view is refreshed.\
	this happens every time the whole window is refreshed\
	(manually by calling SCWindow-refresh or e.g. by resizing the window)\
	\

\f2\fs18 \cf2 	(\
	\cf3 var\cf2  func;\
	\
	func = \{\cf3 |me|\cf2 \
		\cf3 Pen\cf2 .use\{\
			\cf4 // clipping into the boundingbox\cf2 \
			\cf3 Pen\cf2 .moveTo((me.bounds.left)@(me.bounds.top));\
			\cf3 Pen\cf2 .lineTo(((me.bounds.left)@(me.bounds.top))\
					+ (me.bounds.width@0));\
			\cf3 Pen\cf2 .lineTo(((me.bounds.left)@(me.bounds.top))\
					+ (me.bounds.width@me.bounds.height));\
			\cf3 Pen\cf2 .lineTo(((me.bounds.left)@(me.bounds.top))\
					+ (0@me.bounds.height));\
			\cf3 Pen\cf2 .lineTo((me.bounds.left)@(me.bounds.top));\
			\cf3 Pen\cf2 .clip;\
			\
			\cf4 // draw background\cf2 \
			\cf3 Color\cf2 .gray(0.5).set;\
			\cf3 Pen\cf2 .moveTo((me.bounds.left)@(me.bounds.top));\
			\cf3 Pen\cf2 .lineTo(((me.bounds.left)@(me.bounds.top))\
					+ (me.bounds.width@0));\
			\cf3 Pen\cf2 .lineTo(((me.bounds.left)@(me.bounds.top))\
					+ (me.bounds.width@me.bounds.height));\
			\cf3 Pen\cf2 .lineTo(((me.bounds.left)@(me.bounds.top))\
					+ (0@me.bounds.height));\
			\cf3 Pen\cf2 .lineTo((me.bounds.left)@(me.bounds.top));\
			\cf3 Pen\cf2 .fill;			\
\
			\cf3 Pen\cf2 .translate(100, 100);\
			10.do\{\
				\cf3 Color\cf2 .red(rrand(0.0, 1), rrand(0.0, 0.5)).set;\
				\cf3 Pen\cf2 .addArc((400.exprand(2))@(100.rand), rrand(10, 100), 2pi.rand, pi);\
				\cf3 Pen\cf2 .perform([\cf5 \\stroke\cf2 , \cf5 \\fill\cf2 ].choose);\
			\}\
		\}\
	\};\
\
	w = \cf3 SCWindow\cf2 .new.front;\
	w.view.background_(\cf3 Color\cf2 .white);\
	3.do\{\cf3 |i|\cf2 \
		v = \cf3 SCUserView\cf2 (w, \cf3 Rect\cf2 (20+(i*120), 100, 100, 100));\
		\cf4 //v.background_(Color.white); // not affecting anything...\cf2 \
		v.drawFunc = func;\
	\};\
	w.refresh;\
	)\

\f1\fs24 \cf0 \
	\

\f0\b mouseBeginTrackFunc_\

\f1\b0 \
	set the function which should be evaluated if the mouse is at the beginning of a tracking\
\

\f0\b mouseTrackFunc_\

\f1\b0 \
	set the function which should be evaluated if the mouse is tracked\
\

\f0\b mouseEndTrackFunc_
\f1\b0 \
\
	set the function which should be evaluated if the mouse is at the end of a tracking\
	\

\f2\fs18 \cf2 	(\
	\cf3 var\cf2  drawFunc, beginTrackFunc, endTrackFunc, trackFunc, sat = 0, absX;\
	\
	drawFunc = \{\cf3 |me|\cf2 \
		\cf3 Pen\cf2 .use\{\
			\cf4 // clipping into the boundingbox\cf2 \
			\cf3 Pen\cf2 .moveTo((me.bounds.left)@(me.bounds.top));\
			\cf3 Pen\cf2 .lineTo(((me.bounds.left)@(me.bounds.top))\
					+ (me.bounds.width@0));\
			\cf3 Pen\cf2 .lineTo(((me.bounds.left)@(me.bounds.top))\
					+ (me.bounds.width@me.bounds.height));\
			\cf3 Pen\cf2 .lineTo(((me.bounds.left)@(me.bounds.top))\
					+ (0@me.bounds.height));\
			\cf3 Pen\cf2 .lineTo((me.bounds.left)@(me.bounds.top));\
			\cf3 Pen\cf2 .clip;\
			\
			\cf4 // draw background\cf2 \
			\cf3 Color\cf2 .gray(sat).set;\
			\cf3 Pen\cf2 .moveTo((me.bounds.left)@(me.bounds.top));\
			\cf3 Pen\cf2 .lineTo(((me.bounds.left)@(me.bounds.top))\
					+ (me.bounds.width@0));\
			\cf3 Pen\cf2 .lineTo(((me.bounds.left)@(me.bounds.top))\
					+ (me.bounds.width@me.bounds.height));\
			\cf3 Pen\cf2 .lineTo(((me.bounds.left)@(me.bounds.top))\
					+ (0@me.bounds.height));\
			\cf3 Pen\cf2 .lineTo((me.bounds.left)@(me.bounds.top));\
			\cf3 Pen\cf2 .fill;			\
\
			\cf3 Pen\cf2 .translate(100, 100);\
			10.do\{\
				\cf3 Color\cf2 .red(rrand(0.0, 1), rrand(0.0, 0.5)).set;\
				\cf3 Pen\cf2 .addArc((400.exprand(2))@(100.rand), rrand(10, 100), 2pi.rand, pi);\
				\cf3 Pen\cf2 .perform([\cf5 \\stroke\cf2 , \cf5 \\fill\cf2 ].choose);\
			\}\
		\}\
	\};\
	beginTrackFunc = \{\cf3 |me, x, y, mod|\cf2 \
		absX = x;\
		postf(\cf6 "begin path: x=%\\n"\cf2 ,absX);\
	\};\
	endTrackFunc = \{\cf3 |me, x, y, mod|\cf2 \
		postf(\cf6 "end path: (absX-x)=%\\n"\cf2 , (absX-x))\
	\};\
	trackFunc = \{\cf3 |me, x, y, mod|\cf2 \
		sat = ((absX-x)/100);\
		me.refresh;\
	\};\
\
	w = \cf3 SCWindow\cf2 .new.front;\
	w.view.background_(\cf3 Color\cf2 .white);\
	3.do\{\cf3 |i|\cf2 \
		v = \cf3 SCUserView\cf2 (w, \cf3 Rect\cf2 (20+(i*120), 100, 100, 100));\
		\cf4 //v.background_(Color.white); // not affecting anything...\cf2 \
		v.drawFunc = drawFunc;\
		v.mouseBeginTrackFunc = beginTrackFunc;\
		v.mouseEndTrackFunc = endTrackFunc;\
		v.mouseTrackFunc = trackFunc;\
	\};\
	w.refresh;\
	)
\f1\fs24 \cf0 \
}