{\rtf1\mac\ansicpg10000\cocoartf824\cocoasubrtf330
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
\f3\fswiss\fcharset77 Helvetica-Oblique;\f4\fnil\fcharset77 TrebuchetMS;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red191\green0\blue0;\red0\green115\blue0;
\red96\green96\blue96;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 Pen				
\fs28 draw on an SCWindow
\f1\b0\fs24 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 superclass: Object\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 \
A class which allows you to draw on a 
\f0\b [\ul \ulc2 SCWindow\ulnone ]
\f1\b0 . It has no instance methods.
\f2\fs18 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural
\cf0 The following methods must be called within an SCWindow-drawHook or a SCUserView-drawFunc function, and will only be visible once the window or the view is refreshed. Each call to SCWindow-refresh SCUserView-refresh will 'overwrite' all previous drawing by executing the currently defined function.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
See also: 
\f0\b [\ul SCWindow\ulnone ]
\f1\b0 , 
\f0\b [\ul SCUserView\ulnone ]
\f1\b0 , 
\f0\b [\ul Color\ulnone ]
\f1\b0 , and 
\f0\b [\ul String\ulnone ]\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs28 \cf0 Drawing Methods
\fs24 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 The following methods define paths. You will need to call 
\f0\b *stroke
\f1\b0  or 
\f0\b *fill
\f1\b0  to actually draw them.\

\f0\b \
	*moveTo (point)\

\f1\b0 		Move the Pen to 
\f0\b point
\f1\b0 . 
\f0\b point
\f1\b0  is an instance of 
\f0\b [\ul Point\ulnone ]
\f1\b0 .\

\f2\fs18 		\

\f0\b\fs24 	*lineTo (point)\

\f1\b0 		Draw a line (define a path) from the current position to 
\f0\b point
\f1\b0 . 
\f0\b point
\f1\b0  is an instance of 
\f0\b [\ul Point\ulnone ]
\f1\b0 .\
 \

\f0\b 	*line (p1, p2)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural

\f1\b0 \cf0 		Draw a line (define a path) from p1 to p2. Current position will be p2. 
\f0\b p1
\f1\b0  and 
\f0\b p2
\f1\b0  are instances of 
\f0\b [\ul Point\ulnone ]
\f1\b0 .\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf3 //	*curveTo(point, cpoint1, cpoint2)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 		draws an interpolated curve from the current position to 
\f0\b point
\f1\b0 . \
		
\f0\b cpoint1, cpoint2 
\f1\b0 are help-points determining the curves curvature.\
		(Splines, B-Splines, Nurbs?)\

\f0\b 		Unfortunately not working for now...
\f1\b0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf3 //	*quadCurveTo(point, cpoint1)\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 		draws an interpolated curve from the current position to 
\f0\b point
\f1\b0 . \
		
\f0\b cpoint1 
\f1\b0 is a help-point determining the curves curvature.\

\f0\b 		Unfortunately not working for now...
\f2\b0\fs18 \
\

\f0\b\fs24 	*addArc(center, radius, startAngle, arcAngle)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural
\cf0 		
\f1\b0 Draw an arc around the 
\f0\b [Point]
\f1\b0  
\f0\b center
\f1\b0 , at 
\f0\b radius
\f1\b0  number of pixels. 
\f0\b startAngle
\f1\b0  and 
\f0\b arcAngle
\f1\b0  refer to the starting angle and the extent of the arc, and are in radians [0..2pi].
\f2\fs18 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 		(\
		w = \cf2 SCWindow\cf0 .new.front;\
		w.view.background_(\cf2 Color\cf0 .white);\
		w.drawHook = \{\
			\cf3 // set the Color\cf0 \
			\cf2 Pen\cf0 .translate(100, 100);\
			10.do\{\
				\cf2 Color\cf0 .red(rrand(0.0, 1), rrand(0.0, 0.5)).set;\
				\cf2 Pen\cf0 .addArc((100.rand)@(100.rand), rrand(10, 100), 2pi.rand, pi);\
				\cf2 Pen\cf0 .perform([\cf4 \\stroke\cf0 , \cf4 \\fill\cf0 ].choose);\
			\}\
		\};\
		w.refresh;\
		)\

\f0\b\fs24 \
	*addWedge(center, radius, startAngle, arcAngle)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural
\cf0 		
\f1\b0 Draw a wedge around the 
\f0\b [Point]
\f1\b0  
\f0\b center
\f1\b0 , at 
\f0\b radius
\f1\b0  number of pixels. 
\f0\b startAngle
\f1\b0  and 
\f0\b arcAngle
\f1\b0  refer to the starting angle and the extent of the arc, and are in radians [0..2pi].
\f0\b \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs18 \cf0 		(\
		w = \cf2 SCWindow\cf0 .new.front;\
		w.view.background_(\cf2 Color\cf0 .white);\
		w.drawHook = \{\
			\cf3 // set the Color\cf0 \
			\cf2 Pen\cf0 .translate(100, 100);\
			10.do\{\
				\cf2 Color\cf0 .blue(rrand(0.0, 1), rrand(0.0, 0.5)).set;\
				\cf2 Pen\cf0 .addWedge((100.rand)@(100.rand), rrand(10, 100), 2pi.rand, 2pi.rand);\
				\cf2 Pen\cf0 .perform([\cf4 \\stroke\cf0 , \cf4 \\fill\cf0 ].choose);\
			\}\
		\};\
		w.refresh;\
		)\

\f0\b\fs24 \
	*addAnnularWedge (center, innerRadius, outerRadius, startAngle, arcAngle)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural
\cf0 		
\f1\b0 Draw an annular wedge around the 
\f0\b [Point]
\f1\b0  
\f0\b center
\f1\b0 , from 
\f0\b innerRadius
\f1\b0  to 
\f0\b outerRadius
\f1\b0  in pixels. 
\f0\b startAngle
\f1\b0  and 
\f0\b arcAngle
\f1\b0  refer to the starting angle and the extent of the arc, and are in radians [0..2pi].
\f0\b \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs18 \cf0 		(\
		w = \cf2 SCWindow\cf0 .new.front;\
		w.view.background_(\cf2 Color\cf0 .white);\
		w.drawHook = \{\
			\cf3 // set the Color\cf0 \
			\cf2 Pen\cf0 .translate(100, 100);\
			1000.do\{\
				\cf2 Color\cf0 .green(rrand(0.0, 1), rrand(0.0, 0.5)).set;\
				\cf2 Pen\cf0 .addAnnularWedge(\
					(100.rand)@(100.rand), \
					rrand(10, 50), \
					rrand(51, 100), 	\
					2pi.rand, \
					2pi.rand\
				);\
				\cf2 Pen\cf0 .perform([\cf4 \\stroke\cf0 , \cf4 \\fill\cf0 ].choose);\
			\}\
		\};\
		w.refresh;\
		)\

\f0\b\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 //	*addRect(rect)\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 		adds a rectangle to the drawing; \
		
\f0\b Unfortunately not working for now...\

\f2\b0\fs18 \
	
\f0\b\fs24 *stroke\

\f1\b0 		outline the previous defined path. \

\f2\fs18 		\
		(\
		w = \cf2 SCWindow\cf0 .new.front;\
		w.view.background_(\cf2 Color\cf0 .white);\
		w.drawHook = \{\
			\cf3 // set the Color\cf0 \
			\cf2 Color\cf0 .red.set;\
			\cf2 Pen\cf0 .moveTo(200@100);\
			\
			\cf2 Pen\cf0 .lineTo(250@200);\
			\cf2 Pen\cf0 .lineTo(300@200);\
			\cf2 Pen\cf0 .lineTo(200@250);\
			\cf2 Pen\cf0 .lineTo(100@200);\
			\cf2 Pen\cf0 .lineTo(150@200);\
			\cf2 Pen\cf0 .lineTo(200@100);\
\
			\cf2 Pen\cf0 .stroke\
		\};\
		w.refresh;\
		)\
		\
	
\f0\b\fs24 *fill\

\f1\b0 		fill the previous defined path. \

\f2\fs18 		(\
		w = \cf2 SCWindow\cf0 .new.front;\
		w.view.background_(\cf2 Color\cf0 .white);\
		w.drawHook = \{\
			\cf3 // set the Color\cf0 \
			\cf2 Color\cf0 .red.set;\
			\cf2 Pen\cf0 .moveTo(200@100);\
\
			\cf2 Pen\cf0 .lineTo(250@200);\
			\cf2 Pen\cf0 .lineTo(300@200);\
			\cf2 Pen\cf0 .lineTo(200@250);\
			\cf2 Pen\cf0 .lineTo(100@200);\
			\cf2 Pen\cf0 .lineTo(150@200);\
			\cf2 Pen\cf0 .lineTo(200@100);\
\
			\cf2 Pen\cf0 .fill\
		\};\
		w.refresh;\
		)\
					\

\f1\fs24 These methods do require separate calls to 
\f0\b *stroke
\f1\b0  or 
\f0\b *fill
\f1\b0 .\

\f0\b \
	*strokeRect(rect)\

\f1\b0 		Strokes a rectangle into the window. 
\f0\b rect
\f1\b0  is an instance of 
\f0\b [\ul Rect\ulnone ]
\f1\b0 .\
		\
		
\f2\fs18 (\
		w = \cf2 SCWindow\cf0 (\cf5 "strokeRect"\cf0 , \cf2 Rect\cf0 (128, 64, 360, 360));\
		w.drawHook = \{\
			\cf2 var\cf0  h, v, r;\
			v = h = 300.0;\
			r = \cf2 Rect\cf0 (100, 100, 160, 80);\
			\cf2 Color\cf0 .black.alpha_(0.8).set;\
			\cf2 Pen\cf0 .strokeRect(r);\
		\};\
		w.front;\
		)
\f1\fs24 \

\f0\b \
	*fillRect(rect)\

\f1\b0 		Draws a filled rectangle into the window. 
\f0\b rect
\f1\b0  is an instance of 
\f0\b [\ul Rect\ulnone ]
\f1\b0 .\
\

\f0\b 	*strokeOval(rect)\

\f1\b0 		Strokes an oval into the window. 
\f0\b rect
\f1\b0  is an instance of 
\f0\b [\ul Rect\ulnone ]
\f1\b0 .\
		\
		
\f2\fs18 (\
		w = \cf2 SCWindow\cf0 (\cf5 "strokeOval"\cf0 , \cf2 Rect\cf0 (128, 64, 360, 360));\
		w.drawHook = \{\
			\cf2 var\cf0  h, v, r;\
			v = h = 300.0;\
			r = \cf2 Rect\cf0 (100, 100, 160, 80);\
			\cf2 Color\cf0 .black.alpha_(0.8).set;\
			\cf2 Pen\cf0 .strokeOval(r);\
		\};\
		w.front;\
		)
\f1\fs24 \
\

\f0\b 	*fillOval(rect)\

\f1\b0 		Draws a filled oval into the window. 
\f0\b rect
\f1\b0  is an instance of 
\f0\b [\ul Rect\ulnone ]
\f1\b0 .\

\f2\fs18 	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf3 //	*drawAquaButton(rect, type=0, down=false, on=false)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs18 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 Graphics State Methods\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs18 \cf0 \

\f1\fs24 The following commands transform the graphics state, i.e. they effect all subsequent drawing commands. These transformations are cumulative, i.e. each command applies to the previous graphics state, 
\f3\i not
\f1\i0  the original one.\

\f0\b \
	*translate(x=0, y=0)\

\f1\b0 		translate the coordinate system to have its origin moved by 
\f0\b x
\f1\b0 ,
\f0\b y
\f1\b0 \

\f2\fs18 \
		(\
		w = \cf2 SCWindow\cf0 .new.front;\
		w.view.background_(\cf2 Color\cf0 .white);\
		w.drawHook = \{\
			\cf3 // set the Color\cf0 \
			\cf2 Color\cf0 .blue.set;\
			\cf2 Pen\cf0 .translate(200,100);\
			\
			\cf3 // 0@0 is now 200@100\cf0 \
			\cf2 Pen\cf0 .moveTo(0@0);\
\
			\cf2 Pen\cf0 .lineTo(50@100);\
			\cf2 Pen\cf0 .lineTo(100@100);\
			\cf2 Pen\cf0 .lineTo(0@150);\
			\cf2 Pen\cf0 .lineTo(-100@100);\
			\cf2 Pen\cf0 .lineTo(-50@100);\
			\cf2 Pen\cf0 .lineTo(0@0);\
\
			\cf2 Pen\cf0 .stroke\
		\};\
		w.refresh;\
		)\
		\
		\cf3 // cumulative translations\cf0 		\
		(\
		w = \cf2 SCWindow\cf0 .new.front;\
		w.view.background_(\cf2 Color\cf0 .clear);\
		w.drawHook = \{\
			\cf3 // set the Color\cf0 \
			\cf2 Color\cf0 .black.set;\
			\cf3 // draw 35 lines\cf0 \
			35.do \{\
				\cf2 Pen\cf0 .moveTo(0@0);\
				\cf2 Pen\cf0 .lineTo(50@350);\
				\cf3 // shift 10 to the right every time\cf0 \
				\cf2 Pen\cf0 .translate(10, 0);\
				\cf2 Pen\cf0 .stroke\
			\}\
		\};\
		w.refresh;\
		)\
\

\f0\b\fs24 	*scale (x=0, y=0)\
		
\f1\b0 Scales subsequent drawing. 
\f0\b x
\f1\b0  and 
\f0\b y
\f1\b0  are scaling factors (i.e. 1 is normal, 2 is double size, etc.).\

\f2\fs18 	\
		(\
		w = \cf2 SCWindow\cf0 .new.front;\
		w.view.background_(\cf2 Color\cf0 .white);\
		w.drawHook = \{\
			\cf3 // set the Color\cf0 \
			\cf2 Color\cf0 .green.set;\
			\cf2 Pen\cf0 .translate(200,100);\
			\cf2 Pen\cf0 .scale(0.5, 2);\
			\cf3 // you have to set a starting point...\cf0 \
			\cf2 Pen\cf0 .moveTo(0@0);\
\
			\cf2 Pen\cf0 .lineTo(50@100);\
			\cf2 Pen\cf0 .lineTo(100@100);\
			\cf2 Pen\cf0 .lineTo(0@150);\
			\cf2 Pen\cf0 .lineTo(-100@100);\
			\cf2 Pen\cf0 .lineTo(-50@100);\
			\cf2 Pen\cf0 .lineTo(0@0);\
\
			\cf2 Pen\cf0 .stroke\
		\};\
		w.refresh;\
		)
\f0\b\fs24 \
\
	*skew (x=0, y=0)\
		
\f1\b0 Skews subsequent drawing. 
\f0\b x
\f1\b0  and 
\f0\b y
\f1\b0  are skewing factors (i.e. 1 is normal).\

\f2\fs18 		(\
		w = \cf2 SCWindow\cf0 .new.front;\
		w.view.background_(\cf2 Color\cf0 .white);\
		w.drawHook = \{\
			\cf3 // set the Color\cf0 \
			\cf2 Color\cf0 .green(0.5, 0.8).set;\
			\cf2 Pen\cf0 .translate(200,100);\
			\cf2 Pen\cf0 .skew(0.5, 0.2);\
			\cf3 // you have to set a starting point...\cf0 \
			\cf2 Pen\cf0 .moveTo(0@0);\
\
			\cf2 Pen\cf0 .lineTo(50@100);\
			\cf2 Pen\cf0 .lineTo(100@100);\
			\cf2 Pen\cf0 .lineTo(0@150);\
			\cf2 Pen\cf0 .lineTo(-100@100);\
			\cf2 Pen\cf0 .lineTo(-50@100);\
			\cf2 Pen\cf0 .lineTo(0@0);\
\
			\cf2 Pen\cf0 .fill\
		\};\
		w.refresh;\
		)
\f0\b\fs24 \
\
	*rotate (angle=0, x=0, y=0)\
		
\f1\b0 Rotates subsequent drawing around the 
\f0\b Point
\f1\b0  x@y by the amount 
\f0\b angle 
\f1\b0 in radians [0..2pi].\

\f2\fs18 		(\
		w = \cf2 SCWindow\cf0 .new.front;\
		w.view.background_(\cf2 Color\cf0 .white);\
		c = 0;\
		w.drawHook = \{\
			\cf2 Pen\cf0 .translate(220, 200);\
			\
			10.do(\{\
				\cf2 Pen\cf0 .translate(0,10);\
				\cf3 // set the Color for all "real" drawing\cf0 \
				\cf2 Color\cf0 .hsv(c.fold(0, 1), 1, 1, 0.5).set;\
				\
				\cf3 // you have to set a starting point...\cf0 \
				\cf2 Pen\cf0 .moveTo(0@0);\
	\
				\cf2 Pen\cf0 .lineTo(50@100);\
				\cf2 Pen\cf0 .lineTo(100@100);\
				\cf2 Pen\cf0 .lineTo(0@150);\
				\cf2 Pen\cf0 .lineTo(-100@100);\
				\cf2 Pen\cf0 .lineTo(-50@100);\
				\cf2 Pen\cf0 .lineTo(0@0);\
	\
				\cf2 Pen\cf0 .fill;\
				\cf2 Pen\cf0 .rotate(0.2pi);\
				\
				c = c + 0.1;\
			\});\
		\};\
		w.refresh;\
		)
\f0\b\fs24 \

\f2\b0\fs18 \

\f0\b\fs24 	*matrix_ (array)\

\f1\b0 		transforms coordinate system.\
		array = [a, b, c, d, x, y]\
			a	zoomX\
			b	shearingX\
			c	shearingY\
			d	zoomY\
			x	translateX\
			y	translateY\

\f2\fs18 		(\
		\cf2 var\cf0  controlWindow, w;\
		\cf2 var\cf0  r, a, b, c, d, matrix = [1, 0, 0, 1, 10, 10];\
		\cf2 var\cf0  sliders, spex, name;\
	\
		w = \cf2 SCWindow\cf0 .new.front;\
		w.view.background_(\cf2 Color\cf0 .white);\
		\
		\cf3 // create a controller-window \cf0 \
		controlWindow = \cf2 SCWindow\cf0 (\cf5 "matrix controls"\cf0 , \cf2 Rect\cf0 (400,200,350,120));\
		controlWindow.front;\
	\
		\cf3 // determine the rectangle to be drawn\cf0 \
		r = \cf2 Rect\cf0 .fromPoints(a = 0 @ 0, c = 180 @ 180);\
		b = r.leftBottom;\
		d = r.rightTop;\
	\
		\cf3 // the drawHook\cf0 \
		w.drawHook = \{\
			\cf2 Color\cf0 .red.set;\
		    	\cf2 Pen\cf0 .matrix = matrix;\
		    	\cf2 Pen\cf0 .width = 5;\
		    	\cf2 Pen\cf0 .strokeRect(r);\
		    	\cf2 Pen\cf0 .strokeOval(r);\
			\cf2 Color\cf0 .blue.set;\
		    	\cf2 Pen\cf0 .width = 0.1;\
		    	\cf2 Pen\cf0 .line(a, c);\
		    	\cf2 Pen\cf0 .line(b, d);\
		    	\cf2 Pen\cf0 .stroke;\
		    \
		    	\cf5 "A"\cf0 .drawAtPoint(a - 6, \cf2 Font\cf0 (\cf5 "Helvetica-Bold"\cf0 , 12));\
		    	\cf5 "B"\cf0 .drawAtPoint(b - 6, \cf2 Font\cf0 (\cf5 "Helvetica-Bold"\cf0 , 12));\
		    	\cf5 "C"\cf0 .drawAtPoint(c - (0@6), \cf2 Font\cf0 (\cf5 "Helvetica-Bold"\cf0 , 12));\
		    	\cf5 "D"\cf0 .drawAtPoint(d - (0@6), \cf2 Font\cf0 (\cf5 "Helvetica-Bold"\cf0 , 12));\
		    \
		    	\cf5 "a matrix test"\cf0 .drawInRect(r.moveBy(50,50),   \cf2 Font\cf0 (\cf5 "Helvetica"\cf0 , 10));\
		\};\
	\
		controlWindow.view.decorator = sliders = \cf2 FlowLayout\cf0 (controlWindow.view.bounds);\
		spex = [\
			[0, 2.0].asSpec,\
			[0, 2.0].asSpec,\
			[0, 2.0].asSpec,\
			[0, 2.0].asSpec,\
			[0, 200.0].asSpec,\
			[0, 200.0].asSpec\
		];\
		name = #[zoomX, shearingX, shearingY, zoomY, translateX, translateY];\
		6.do \{ \cf2 |i|\cf0 \
		    \cf2 EZSlider\cf0 (controlWindow, 300 @ 14, name[i], spex[i], \{ \cf2 |ez|\cf0  \cf2 var\cf0  val;\
		            val = ez.value;\
		            [i, val.round(10e-4)].postln;\
		            matrix.put(i, val);\
		            w.refresh; \cf3 // reevaluate drawHook function\cf0 \
		  	\}, matrix[i]);\
		  	sliders.nextLine;\
		\};\
		w.refresh;\
	)\

\f1\fs24 \
\

\f0\b 	*width_(width=1)\

\f1\b0 		sets the width of the Pen for the whole stroke\

\f2\fs18 		(\
		w = \cf2 SCWindow\cf0 .new.front;\
		w.view.background_(\cf2 Color\cf0 .white);\
		w.drawHook = \{\
			\cf3 // set the Color\cf0 \
			\cf2 Color\cf0 .blue(0.5, 0.5).set;\
			\cf2 Pen\cf0 .translate(200,100);\
			\cf2 Pen\cf0 .width = 10;\
			\cf3 // you have to set a starting point...\cf0 \
			\cf2 Pen\cf0 .moveTo(0@0);\
\
			\cf2 Pen\cf0 .lineTo(50@100);\
			\cf2 Pen\cf0 .lineTo(100@100);\
			\cf2 Pen\cf0 .lineTo(0@150);\
			\cf2 Pen\cf0 .lineTo(-100@100);\
			\cf2 Pen\cf0 .lineTo(-50@100);\
			\cf2 Pen\cf0 .lineTo(0@0);\
\
			\cf2 Pen\cf0 .stroke\
		\};\
		w.refresh;\
		)\
\

\f0\b\fs24 	*use (function)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural

\f1\b0 \cf0 		Draw 
\f0\b function
\f1\b0 , and then revert to the previous graphics state. This allows you to make complex transformations of the graphics state without having to explicitly revert to get back to 'normal'.\
		\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 		(\
		\cf3 // modified by an example of Stefan Wittwer\
		\cf0 w = \cf2 SCWindow\cf0 .new.front;\
		w.view.background_(\cf2 Color\cf0 .white);\
		w.drawHook = \{\
			\cf3 //paint origin\cf0 \
			\cf2 Color\cf0 .gray(0, 0.5).set;\
			\cf2 Pen\cf0 .addArc(0@0, 20, 0, 2pi);\
			\cf2 Pen\cf0 .fill;\
			\cf2 Pen\cf0 .width = 10;\
\
			\cf2 Pen\cf0 .use \{ \cf3 // draw something complex...\cf0 \
				\cf2 Pen\cf0 .width = 0.5;\
				\cf2 Pen\cf0 .translate(100,100);\
				\cf2 Color\cf0 .blue.set;\
				\cf2 Pen\cf0 .addArc(0@0, 10, 0, 2pi);\
				\cf2 Pen\cf0 .fill;\
				20.do\{\
					\cf2 Pen\cf0 .moveTo(0@0);\
					\cf2 Pen\cf0 .lineTo(100@0);\
					\cf2 Color\cf0 .red(0.8, rrand(0.7, 1)).set;\
					\cf2 Pen\cf0 .stroke;\
					\cf2 Pen\cf0 .skew(0, 0.1);\
				\};\
			\};\
			\
			\cf3 // now go on with all params as before\
			// translation, skewing, width, and color modifications do not apply\cf0 \
			\cf2 Pen\cf0 .line(10@120, 300@120);\
			\cf2 Pen\cf0 .stroke;\
		\};\
		w.refresh\
		)\
\

\f0\b\fs24 	*path(function)\

\f1\b0 		make a path, consisting of the drawing made in 
\f0\b function.\

\f1\b0 		
\f0\b Unfortunately not working for now... \

\f1\b0 		(there's no Meta_Pen-endPath which currently is used in this method)\

\f0\b 		
\f1\b0 \

\f0\b 	*beginPath\
		
\f1\b0 Discard any previous path.
\f0\b \
		\
		
\f2\b0\fs18 \cf3 // incomplete arrow\cf0 \
		(\
		w = \cf2 SCWindow\cf0 .new.front;\
		w.view.background_(\cf2 Color\cf0 .white);\
		w.drawHook = \{\
			\cf3 // set the Color\cf0 \
			\cf2 Color\cf0 .blue.set;\
			\cf2 Pen\cf0 .translate(200,100);\
			\cf2 Pen\cf0 .moveTo(0@0);\
\
			\cf2 Pen\cf0 .lineTo(50@100);\
			\cf2 Pen\cf0 .lineTo(100@100);\
			\
			\cf3 // forget what we just drew\cf0 \
			\cf2 Pen\cf0 .beginPath;\
			\cf2 Pen\cf0 .moveTo(100@100);\
			\cf2 Pen\cf0 .lineTo(0@150);\
			\cf2 Pen\cf0 .lineTo(-100@100);\
			\cf2 Pen\cf0 .lineTo(-50@100);\
			\cf2 Pen\cf0 .lineTo(0@0);\
\
			\cf2 Pen\cf0 .stroke\
		\};\
		w.refresh;\
		)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf3 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 	*clip\
		
\f1\b0 Use the previously defined path as a clipping path.\
		\

\f2\fs18 		(\
		w = \cf2 SCWindow\cf0 .new.front;\
		w.view.background_(\cf2 Color\cf0 .white);\
		w.drawHook = \{\
	       	\cf3 // outline the clipping path\cf0 \
			\cf2 Pen\cf0 .moveTo(110@110);\
			\cf2 Pen\cf0 .lineTo(290@110);\
			\cf2 Pen\cf0 .lineTo(290@240);\
			\cf2 Pen\cf0 .lineTo(110@240);\
			\cf2 Pen\cf0 .lineTo(110@110);\
			\cf3 // now clip\cf0 \
			\cf2 Pen\cf0 .clip;\
			\
			\cf3 // everything else we draw is now clipped\cf0 \
			\cf2 Color\cf0 .yellow.set;\
			\cf2 Pen\cf0 .fillRect(\cf2 Rect\cf0 (0,0,400,400));\
			\cf2 Color\cf0 .red.set;\
			\cf2 Pen\cf0 .moveTo(200@100);\
			\
			\cf2 Pen\cf0 .lineTo(250@200);\
			\cf2 Pen\cf0 .lineTo(300@200);\
			\cf2 Pen\cf0 .lineTo(200@250);\
			\cf2 Pen\cf0 .lineTo(100@200);\
			\cf2 Pen\cf0 .lineTo(150@200);\
			\
			\cf2 Pen\cf0 .fill;\
		\};\
		w.refresh;\
		)
\f1\fs24 \

\f0\b \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs28 \cf0 Examples\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs24 \cf3 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs18 \cf0 (\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 // simple rotating and scaling\cf0 \
	w = \cf2 SCWindow\cf0 (\cf5 "Pen Rotation and Scaling"\cf0 , \cf2 Rect\cf0 (128, 64, 360, 360));\
	w.drawHook = \{\
		\cf2 var\cf0  h, v;\
		v = h = 300.0;\
		\cf2 Pen\cf0 .use \{\
			\cf3 // use the same rect for everything, just scale and rotate\cf0 \
			\cf2 var \cf0 r = \cf2 Rect\cf0 (0,0,200,80);\
			\cf2 Color\cf0 .black.set;\
			\cf3 // offset all subsequent co-ordinates\cf0 \
			\cf2 Pen\cf0 .translate(80,20);\
			\cf2 Pen\cf0 .fillRect(r);\
			\cf2 Color\cf0 .red.set;\
			\cf3 // scale all subsequent co-ordinates\cf0 \
			\cf2 Pen\cf0 .scale(0.8, 0.8);\
			\cf2 Pen\cf0 .translate(8,10);\
			\cf3 // rotate all subsequent co-ordinates\cf0 \
			\cf2 Pen\cf0 .rotate(0.1pi);\
			\cf2 Pen\cf0 .fillRect(r);\
			\cf2 Color\cf0 .blue.set;\
			\cf3 // lather, rinse, repeat\cf0 \
			\cf2 Pen\cf0 .scale(0.8, 0.8);\
			\cf2 Pen\cf0 .rotate(0.1pi);\
			\cf2 Pen\cf0 .width = 3;\
			\cf2 Pen\cf0 .strokeRect(r);\
			\cf2 Color\cf0 .yellow(1,0.5).set;\
			\cf2 Pen\cf0 .scale(0.8, 0.8);\
			\cf2 Pen\cf0 .rotate(0.1pi);\
			\cf2 Pen\cf0 .translate(20,-20);\
			\cf2 Pen\cf0 .fillOval(r);\
		\}\
	\};\
\
	w.front;\
)\
\
\cf3 // redraw at random interval\cf0 \
\cf3 // different every time\cf0 \
(\
\cf2 var\cf0  w, run = \cf2 true\cf0 ;\
w = \cf2 SCWindow\cf0 (\cf5 "my name is... panel"\cf0 , \cf2 Rect\cf0 (128, 64, 800, 800));\
w.view.background = \cf2 Color\cf0 .white;\
w.onClose = \{ run = \cf2 false\cf0 ; \};\
w.front;\
w.drawHook = \{\
	\cf2 Pen\cf0 .use \{\
		\cf2 Pen\cf0 .width = 0.2;\
		400.do \{\
			\cf2 Pen\cf0 .beginPath;\
			\cf2 Pen\cf0 .moveTo(\cf2 Point\cf0 (10.rand * 80 + 40, 10.rand * 80 + 40));\
			\cf2 Pen\cf0 .lineTo(\cf2 Point\cf0 (10.rand * 80 + 40, 10.rand * 80 + 40));\
			\cf2 Pen\cf0 .stroke;\
		\};\
	\};\
\};\
\
\{ while \{ run \} \{ w.refresh; 1.0.rand.wait \} \}.fork(\cf2 AppClock\cf0 )\
\
)\
\
(\
\cf2 var\cf0  w, run = \cf2 true\cf0 ;\
w = \cf2 SCWindow\cf0 (\cf5 "my name is... panel"\cf0 , \cf2 Rect\cf0 (128, 64, 800, 500));\
w.view.background = \cf2 Color\cf0 .white;\
w.onClose = \{ run = \cf2 false\cf0 ; \};\
w.front;\
w.drawHook = \{\
	\cf2 Pen\cf0 .use \{\
		\cf2 Pen\cf0 .width = 2;\
		80.do \{\
			\cf2 Pen\cf0 .width = rrand(0,4) + 0.5;\
			\cf2 Pen\cf0 .beginPath;\
			\cf2 Pen\cf0 .moveTo(\cf2 Point\cf0 (800.rand, 500.rand));\
			\cf2 Pen\cf0 .lineTo(\cf2 Point\cf0 (800.rand, 500.rand));\
			\cf2 Pen\cf0 .stroke;\
		\};\
	\};\
\};\
\
\{ while \{ run \} \{ w.refresh; 1.0.rand.wait \} \}.fork(\cf2 AppClock\cf0 )\
\
)\
\
\cf3 // Animation\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 // Uses random seed to 'store' data\cf0 \
\cf3 // By reseting the seed each time the same random values and shapes are generated for each 'frame'\cf0 \
\cf3 // These can then be subjected to cumulative rotation, etc., by simply incrementing the phase var.\cf0 \
(\
\cf3 // By James McCartney\cf0 \
\cf2 var\cf0  w, h = 700, v = 700, seed, run = \cf2 true\cf0 , phase = 0;\
w = \cf2 SCWindow\cf0 (\cf5 "wedge"\cf0 , \cf2 Rect\cf0 (40, 40, h, v), false);\
w.view.background = \cf2 Color\cf0 .rand(0,0.3);\
w.onClose = \{ run = \cf2 false\cf0  \}; \cf3 // stop the thread on close\cf0 \
w.front;\
\cf3 // store an initial seed value for the random generator\cf0 \
seed = \cf2 Date\cf0 .seed;\
w.drawHook = \{\
	\cf2 Pen\cf0 .width = 2;\
	\cf2 Pen\cf0 .use \{\
		\cf3 // reset this thread's seed for a moment\cf0 \
		\cf2 thisThread\cf0 .randSeed = \cf2 Date\cf0 .seed;\
		\cf3 // now a slight chance of a new seed or background color\cf0 \
		if (0.006.coin) \{ seed = \cf2 Date\cf0 .seed; \};\
		if (0.02.coin) \{ w.view.background = \cf2 Color\cf0 .rand(0,0.3); \};\
		\cf3 // either revert to the stored seed or set the new one\cf0 \
		\cf2 thisThread\cf0 .randSeed = seed;\
		\cf3 // the random values below will be the same each time if the seed has not changed\cf0 \
		\cf3 // only the phase value has advanced\cf0 \
		\cf2 Pen\cf0 .translate(h/2, v/2);\
		\cf3 // rotate the whole image\cf0 \
		\cf3 // negative random values rotate one direction, positive the other\cf0 \
		\cf2 Pen\cf0 .rotate(phase * 1.0.rand2);\
		\cf3 // scale the rotated y axis in a sine pattern\cf0 \
		\cf2 Pen\cf0 .scale(1, 0.3 * sin(phase * 1.0.rand2 + 2pi.rand) + 0.5 );\
		\cf3 // create a random number of annular wedges\cf0 \
		rrand(6,24).do \{\
			\cf2 Color\cf0 .rand(0.0,1.0).alpha_(rrand(0.1,0.7)).set;\
			\cf2 Pen\cf0 .beginPath;\
			\cf2 Pen\cf0 .addAnnularWedge(\cf2 Point\cf0 (0,0), a = rrand(60,300), a + 50.rand2, 2pi.rand \
				+ (phase * 2.0.rand2), 2pi.rand);\
			if (0.5.coin) \{\cf2 Pen\cf0 .stroke\}\{\cf2 Pen\cf0 .fill\};\
		\};\
	\};\
\};\
\
\cf3 // fork a thread to update 20 times a second, and advance the phase each time\cf0 \
\{ while \{ run \} \{ w.refresh; 0.05.wait; phase = phase + 0.01pi;\} \}.fork(\cf2 AppClock\cf0 )\
\
)\
\
(\
\cf2 var\cf0  w, phase = 0, seed = \cf2 Date\cf0 .seed, run = \cf2 true\cf0 ;\
w = \cf2 SCWindow\cf0 (\cf5 "my name is... panel"\cf0 , \cf2 Rect\cf0 (128, 64, 800, 800));\
w.view.background = \cf2 Color\cf0 .blue(0.4);\
w.onClose = \{ run = \cf2 false\cf0 ; \};\
w.front;\
w.drawHook = \{\
	\cf2 Pen\cf0 .use \{\
		if (0.02.coin) \{ seed = \cf2 Date\cf0 .seed; \};\
		\cf2 thisThread\cf0 .randSeed = seed;\
		\cf2 Color\cf0 .white.set;\
		200.do \{\
			\cf2 var\cf0  a = 4.rand;\
			\cf2 var\cf0  b = 24.rand;\
			\cf2 var\cf0  r1 = 230 + (50 * a);\
			\cf2 var\cf0  a1 = 2pi / 24 * b + phase;\
			\cf2 var\cf0  r2 = 230 + (50 * (a + 1.rand2).fold(0,3));\
			\cf2 var\cf0  a2 = 2pi / 24 * (b + (3.rand2)).wrap(0,23) + phase;\
			\cf2 Pen\cf0 .width = 0.2 + 1.0.linrand;\
			\cf2 Pen\cf0 .beginPath;\
			\cf2 Pen\cf0 .moveTo(\cf2 Polar\cf0 (r1, a1).asPoint + \cf2 Point\cf0 (400,400));\
			\cf2 Pen\cf0 .lineTo(\cf2 Polar\cf0 (r2, a2).asPoint + \cf2 Point\cf0 (400,400));\
			\cf2 Pen\cf0 .stroke;\
		\};\
		\cf2 thisThread\cf0 .randSeed = \cf2 Date\cf0 .seed;\
		40.do \{\
			\cf2 var\cf0  a = 4.rand;\
			\cf2 var\cf0  b = 24.rand;\
			\cf2 var\cf0  r1 = 230 + (50 * a);\
			\cf2 var\cf0  a1 = 2pi / 24 * b + phase;\
			\cf2 var\cf0  r2 = 230 + (50 * (a + 1.rand2).fold(0,3));\
			\cf2 var\cf0  a2 = 2pi / 24 * (b + (3.rand2)).wrap(0,23) + phase;\
			\cf2 Pen\cf0 .width = 0.2 + 1.5.linrand;\
			\cf2 Pen\cf0 .beginPath;\
			\cf2 Pen\cf0 .moveTo(\cf2 Polar\cf0 (r1, a1).asPoint + \cf2 Point\cf0 (400,400));\
			\cf2 Pen\cf0 .lineTo(\cf2 Polar\cf0 (r2, a2).asPoint + \cf2 Point\cf0 (400,400));\
			\cf2 Pen\cf0 .stroke;\
		\};\
	\};\
\};\
\
\{ while \{ run \} \{ w.refresh; 0.1.wait; phase = phase + (2pi/(20*24)) \} \}.fork(\cf2 AppClock\cf0 )\
\
)\
\
\
(\
\cf2 var\cf0  w, h = 800, v = 600, seed = \cf2 Date\cf0 .seed, phase = 0, zoom = 0.7, zoomf = 1, run = \cf2 true\cf0 ;\
w = \cf2 SCWindow\cf0 (\cf5 "affines"\cf0 , \cf2 Rect\cf0 (40, 40, h, v));\
w.view.background = \cf2 Color\cf0 .blue(0.4);\
w.onClose = \{ run = \cf2 false\cf0  \};\
w.front;\
w.drawHook = \{\
	\cf2 thisThread\cf0 .randSeed = \cf2 Date\cf0 .seed;\
	if (0.0125.coin) \{ seed = \cf2 Date\cf0 .seed; phase = 0; zoom = 0.7; zoomf = exprand(1/1.01, 1.01); \}\
	\{ phase = phase + (2pi/80); zoom = zoom * zoomf; \};\
	\cf2 thisThread\cf0 .randSeed = seed;\
	\cf2 Pen\cf0 .use \{\
		\cf2 var\cf0  p1 = \cf2 Point\cf0 (20.rand2 + (h/2), 20.rand2 + (v/2));\
		\cf2 var\cf0  p2 = \cf2 Point\cf0 (20.rand2 + (h/2), 20.rand2 + (v/2));\
		\cf2 var\cf0  xscales = \{ exprand(2** -0.1, 2**0.1) \} ! 2;\
		\cf2 var\cf0  yscales = \{ exprand(2** -0.1, 2**0.1) \} ! 2;\
		\cf2 var\cf0  xlates = \{ 8.rand2 \} ! 2;\
		\cf2 var\cf0  ylates = \{ 8.rand2 \} ! 2;\
		\cf2 var\cf0  rots = \{ 2pi.rand + phase \} ! 2;\
		\cf2 var\cf0  xform;\
		xscales = (xscales ++ (1/xscales)) * 1;\
		yscales = (yscales ++ (1/yscales)) * 1;\
		xlates = xlates ++ xlates.neg;\
		ylates = ylates ++ xlates.neg;\
		rots = rots ++ rots.neg;\
		xform = \{\cf2 |i|\cf0  [xlates[i], ylates[i], rots[i], xscales[i], yscales[i]] \} ! 4;\
		\cf2 Color\cf0 .grey(1,0.5).set;\
		\cf2 Pen\cf0 .width = 8.linrand + 1;\
		\cf2 Pen\cf0 .translate(400, 400);\
		\cf2 Pen\cf0 .scale(zoom, zoom);\
		\cf2 Pen\cf0 .translate(-400, -400);\
		1200.do \{\
			\cf2 var\cf0  p, rot, xlate, ylate, xscale, yscale;\
			\cf2 Pen\cf0 .width = 8.linrand + 1;\
			\cf2 Pen\cf0 .beginPath;\
			#rot, xlate, ylate, xscale, yscale = xform.choose;\
			\cf2 Pen\cf0 .translate(xlate, ylate);\
			\cf2 Pen\cf0 .rotate(rot, h/2, v/2);\
			\cf2 Pen\cf0 .scale(xscale, yscale);\
				\cf2 Pen\cf0 .moveTo(p1);\
				\cf2 Pen\cf0 .lineTo(p2);\
			\cf2 Pen\cf0 .stroke;\
		\};\
	\};\
\};\
\
\{ while \{ run \} \{ w.refresh; 0.05.wait; \} \}.fork(\cf2 AppClock\cf0 )\
\
)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf3 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 -------------------------------------------------------------------------------------------------------\cf3 \
\cf0 NodeBox	vs.	SC3 
\f1\b0 (modified from a mailinglist-post of James McCartney)
\f0\b \
-------------------------------------------------------------------------------------------------------\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f4\b0 \cf0 rect()		\cf2 Pen\cf0 .strokeRect, \cf2 Pen\cf0 .fillRect\
oval()		\cf2 Pen\cf0 .strokeOval, \cf2 Pen\cf0 .fillOval\
line()		\cf2 Pen\cf0 .line -- or use \cf2 Pen\cf0 .moveTo, \cf2 Pen\cf0 .lineTo\
arrow()\
star()\
\
beginpath()	\cf2 Pen\cf0 .beginPath\
moveto()		\cf2 Pen\cf0 .moveTo\
lineto()		\cf2 Pen\cf0 .lineTo\
curveto()		not now\
endpath()		\cf2 Pen\cf0 .stroke, \cf2 Pen\cf0 .fill \
			(paths don't need to be stored as data because you can compose them functionally).\
drawpath()	Pen.stroke, Pen.fill\
beginclip()\
endclip()\
\
transform()	-- not needed since rotate lets you specify the center point.\
translate()	\cf2 Pen\cf0 .translate\
rotate()		\cf2 Pen\cf0 .rotate\
scale()		\cf2 Pen\cf0 .scale\
skew()		\cf2 Pen\cf0 .skew\
push()		\cf2 Pen\cf0 .push			\cf3 // private method???\cf0 \
pop()		\cf2 Pen\cf0 .pop			\cf3 // private method???\cf0 \
reset()		\cf2 Pen\cf0 .matrix = [0,0,0,0,0,0]\
\
colormode()	not necessary use hsv or rgb as needed. missing CMYK though. easy to add.\
color()		\cf2 Color\cf0 .hsv(h,s,v) or \cf2 Color\cf0 (r,g,b)\
fill()			color.setFill\
nofill()		use \cf2 Pen\cf0 .stroke or \cf2 Pen\cf0 .fill as needed.\
stroke()		color.setStroke\
nostroke()		use \cf2 Pen\cf0 .stroke or \cf2 Pen\cf0 .fill as needed.\
strokewidth()	\cf2 Pen\cf0 .width\
\
font()		\cf2 Font\cf0 (name, size)\
fontsize()		\cf2 Font\cf0 (name, size)\
text()		string.drawAtPoint\
textpath()	\
textwidth()	string.bounds -- currently commented out but should work once reenabled.\
textheight()	string.bounds\
textmetrics()\
lineheight()\
align()		use string.drawCenteredIn, string.drawLeftJustIn, string.drawRightJustIn\
\
image()		not yet\
imagesize()	not yet\
\
size()		-- all of these are covered by other mechanisms in SC\
var()\
random()\
choice()\
grid()\
open()\
files()\
autotext()}