{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red0\green115\blue0;\red191\green0\blue0;
}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 Pbind
\f1\b0\fs24 \
\
\
The class 
\f0\b Pbind
\f1\b0  provides a bridge between value patterns and event patterns. It binds symbols in each event to values obtained from a pattern. Pbind takes arguments in pairs, the first of a pair being a Symbol and the second being a value Pattern. Remember that any object can act as a Pattern, so you can use constants as the pattern.\
\
The Pbind stream returns nil whenever the first one of its streams ends.\
\
An event stream is created for a Pattern by sending it the 
\f0\b asEventStream
\f1\b0  message. The 
\f0\b asEventStream
\f1\b0  message takes an Event as an argument. This event is copied for each call to 
\f0\b next
\f1\b0  to pass down and back up the tree of patterns so that each pattern can modify the event. What Pbind does is put the values for its symbols into the event, possibly overwriting previous bindings to those symbols.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 (\
\cf2 SynthDef\cf0 (\cf3 \\cfstring1\cf0 .postln, \{ \cf2 arg\cf0  i_out, freq = 360, gate = 1, pan, amp=0.1;\
	\cf2 var\cf0  out, eg, fc, osc, a, b, w;\
	fc = \cf2 LinExp\cf0 .kr(\cf2 LFNoise1\cf0 .kr(\cf2 Rand\cf0 (0.25,0.4)), -1,1,500,2000);\
	osc = \cf2 Mix\cf0 .fill(8, \{ \cf2 LFSaw\cf0 .ar(freq * [\cf2 Rand\cf0 (0.99,1.01),\cf2 Rand\cf0 (0.99,1.01)], 0, amp) \}).distort * 0.2;\
	eg = \cf2 EnvGen\cf0 .kr(\cf2 Env\cf0 .asr(1,1,1), gate, doneAction:2);\
	out = eg * \cf2 RLPF\cf0 .ar(osc, fc, 0.1);\
	#a, b = out;\
	\cf2 Out\cf0 .ar(i_out, \cf2 Mix\cf0 .ar(\cf2 PanAz\cf0 .ar(4, [a, b], [pan, pan+0.3])));\
\}).load(s);\
)\
\
e = \cf2 Pbind\cf0 (\cf3 \\degree\cf0 , \cf2 Pwhite\cf0 (0,12), \cf3 \\dur\cf0 , 0.2, \cf3 \\instrument\cf0 , \cf3 \\cfstring1\cf0 ).play; \cf4 // returns an EventStream\cf0 \
\
e.stream = \cf2 Pbind\cf0 (\cf3 \\degree\cf0 , \cf2 Pseq\cf0 ([0,1,2,4,6,3,4,8],\cf2 inf\cf0 ), \cf3 \\dur\cf0 , \cf2 Prand\cf0 ([0.2,0.4,0.8],\cf2 inf\cf0 ), \cf3 \\amp\cf0 , 0.05, \cf3 \\octave\cf0 , 5, \cf3 \\instrument\cf0 , \cf3 \\cfstring1\cf0 , \cf3 \\ctranspose\cf0 , 0).asStream;\
\
e.stream = \cf2 Pbind\cf0 (\cf3 \\degree\cf0 , \cf2 Pseq\cf0 ([0,1,2,4,6,3,4,8],\cf2 inf\cf0 ), \cf3 \\dur\cf0 , \cf2 Prand\cf0 ([0.2,0.4,0.8],\cf2 inf\cf0 ), \cf3 \\amp\cf0 , 0.05, \cf3 \\octave\cf0 , 5, \cf3 \\instrument\cf0 , \cf3 \\cfstring1\cf0 , \cf3 \\ctranspose\cf0 , 0).asStream;\
\
e.stream = \cf2 Pbind\cf0 (\cf3 \\degree\cf0 , \cf2 Pxrand\cf0 ([0,1,2,4,6,3,5,7,8],\cf2 inf\cf0 ), \cf3 \\dur\cf0 , \cf2 Prand\cf0 ([0.2,0.4,0.8],\cf2 inf\cf0 ), \cf3 \\amp\cf0 , 0.05, \cf3 \\octave\cf0 , 5, \cf3 \\instrument\cf0 , \cf3 \\cfstring1\cf0 ).asStream;\
\
e.stream = \cf2 Pbind\cf0 (\
	[\cf3 \\degree\cf0 , \cf3 \\dur\cf0 ], \cf2 Pseq\cf0 ([\
			\cf2 Pseq\cf0 ([[0,0.1],[2,0.1],[3,0.1],[4,0.1],[5,0.8]],2),\
			\cf2 Ptuple\cf0 ([\cf2 Pxrand\cf0 ([6,7,8,9],4), 0.4]),\
			\cf2 Ptuple\cf0 ([\cf2 Pseq\cf0 ([9,8,7,6,5,4,3,2]), 0.2])\
		],\cf2 inf\cf0 ),\
	\cf3 \\amp\cf0 , 0.05, \cf3 \\octave\cf0 , 5, \cf3 \\instrument\cf0 , \cf3 \\cfstring1\cf0 , \cf3 \\mtranspose\cf0 , 0).asStream;\
\
e.stream = \cf2 Pbind\cf0 (\
	[\cf3 \\degree\cf0 , \cf3 \\dur\cf0 ], \cf2 Pseq\cf0 ([\
			\cf2 Pseq\cf0 ([[0,0.1],[2,0.1],[3,0.1],[4,0.1],[5,0.8]],2),\
			\cf2 Ptuple\cf0 ([\cf2 Pxrand\cf0 ([6,7,8,9],4), 0.4]),\
			\cf2 Ptuple\cf0 ([\cf2 Pseq\cf0 ([9,8,7,6,5,4,3,2]), 0.2])\
		],\cf2 inf\cf0 ),\
	\cf3 \\amp\cf0 , 0.05, \cf3 \\octave\cf0 , 6, \cf3 \\instrument\cf0 , \cf3 \\cpluck2\cf0 , \cf3 \\mtranspose\cf0 , 0).asStream;\
\
e.mute; \cf4 // keeps playing, but replaces notes with rests\cf0 \
\
e.unmute;\
\
e.reset;  \cf4 // reset the stream.\cf0 \
e.reset;  \cf4 // reset the stream.\cf0 \
e.reset;  \cf4 // reset the stream.\cf0 \
e.reset;  \cf4 // reset the stream.\cf0 \
\
e.pause;  \cf4 // will resume where paused.\cf0 \
\
e.resume;\
\
e.stop;  \cf4 // will reset before resume.\cf0 \
\
e.resume;\
\
(\
\cf2 SynthDef\cf0 (\cf3 \\berlinb\cf0 .postln, \{ \cf2 arg\cf0  i_out=0, freq = 80, amp = 0.2, pan=0, t_trig=1;\
	\cf2 var\cf0  out, a, b;\
	amp = \cf2 Decay2\cf0 .kr(t_trig, 0.05, 8, amp);\
	out = \cf2 RLPF\cf0 .ar(\
		\cf2 LFPulse\cf0 .ar(freq, 0, \cf2 SinOsc\cf0 .kr(0.12,[0,0.5pi],0.48,0.5), amp),\
		freq * \cf2 SinOsc\cf0 .kr(0.21,0,4,8),\
		0.07\
	);\
	#a, b = out;\
	\cf2 DetectSilence\cf0 .ar(a, 0.0001, doneAction: 2);\
	\cf2 Out\cf0 .ar(i_out, \cf2 Mix\cf0 .ar(\cf2 PanAz\cf0 .ar(4, [a, b], [pan, pan+1])));\
\}).load(s);\
)\
\
f = \cf2 Pbind\cf0 (\cf3 \\degree\cf0 , \cf2 Pseq\cf0 ([0,1,2,4,6,3,4,8],\cf2 inf\cf0 ), \cf3 \\dur\cf0 , 0.8, \cf3 \\octave\cf0 , 3, \cf3 \\instrument\cf0 , \cf3 \\berlinb\cf0 , \cf3 \\amp\cf0 , 0.03).play;\
\
f.stream = \cf2 Pbind\cf0 (\cf3 \\degree\cf0 , \cf2 Prand\cf0 ([0,1,2,4,6,3,4,8],\cf2 inf\cf0 ), \cf3 \\dur\cf0 , 1.6, \cf3 \\octave\cf0 , 2, \cf3 \\instrument\cf0 , \cf3 \\berlinb\cf0 , \cf3 \\amp\cf0 , 0.03, \cf3 \\pan\cf0 , rrand(-1.0,1.0)).asStream;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\
\
\
\
\
\
\
\
\
\
\
\
// older docs that need updating...\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 // the theory...\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf2 Instrument\cf0 (\cf3 \\sin\cf0 ,\{ \cf2 arg\cf0  out,freq,amp;\
	\cf2 Out\cf0 .ar(out,\
		\cf2 SinOsc\cf0 .ar(freq,0,amp)\
	)\
\});\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 // have to write the def still...\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 // node def not found...\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf2 Pbind\cf0 (\
	\cf3 \\dur\cf0 ,1 ,\
	\cf3 \\instrument\cf0  , \cf3 \\sin\cf0 \
).play\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 //
\f2 \cf4 (
\fs18 \cf4 \
//var pattern, stream;\
//\
//	// bind Symbol xyz to values obtained from a pattern\
//pattern = Pbind( \
//		\\xyz, Pseq([1, 2, 3]) \
//	);\
//	\
//	// create an event Stream for the Pbind pattern.\
//	// event Streams require a prototype event as input.\
//	// this example uses an empty Event as a prototype\
//stream = pattern.asEventStream(Event.new);\
//\
//	// print the output events.\
//4.do(\{  stream.next.postln; \});\
//\
//
\fs24 \cf4 )\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 Here is an example with more bindings.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 //
\f2 \cf4 (
\fs18 \cf4 \
//var pattern, stream;\
//\
//pattern = Pbind( \
//		\\abc, Prand([6, 7, 8, 9], 8), \
//		\\xyz, Pseq([1, 2, 3], 2),\
//		\\uuu, 999		// a constant represents an infinite sequence of itself\
//	);\
//	\
//stream = pattern.asEventStream(Event.new);\
//\
//7.do(\{  stream.next.postln; \});\
//
\fs24 \cf4 )\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 The ListPatterns discussed in part 3 can be put around Event Streams to create sequences of Event Streams.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 //
\f2 \cf4 (
\fs18 \cf4 \
//var pattern, stream;\
//pattern = \
//	Pseq([\
//		Pbind( \\abc, Pseq([1, 2, 3])),\
//		Pbind( \\def, Pseq([4, 5, 6])),\
//		Pbind( \\xyz, Pseq([7, 8, 9]))\
//	]);	\
//stream = pattern.asEventStream(Event.new);\
//10.do(\{  stream.next.postln; \});\
//
\fs24 \cf4 )\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 //
\f2 \cf4 (\
//var pattern, stream;\
//pattern = \
//	Prand([\
//		Pbind( \\abc, Pseq([1, 2, 3])),\
//		Pbind( \\def, Pseq([4, 5, 6])),\
//		Pbind( \\xyz, Pseq([7, 8, 9]))\
//	], 3);\
//	\
//stream = pattern.asEventStream(Event.new);\
//10.do(\{  stream.next.postln; \});\
//)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 Making Sound using an Event Stream\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 \
The following example uses a Pbind event stream to generate sound events. \
The events generated by the stream are made the current Environment via the 
\f0\b use
\f1\b0  message.\
Then the valueEnvir message is used to get the instrument's argument values from the current Environment.\
Which instrument to play is also a pattern bound to the Symbol \\instr.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf4 //(\
//var a, b, c, pattern, stream;\
//\
//a = \{ arg freq, amp, pan;\
//	Pan2.ar(SinOsc.ar(freq), pan, amp);\
//\};\
//b =  \{ arg amp, pan, freq;\
//	Pan2.ar(RLPF.ar(Saw.ar(freq), freq * 6, 0.1), pan, amp);\
//\};\
//c =  \{ arg pan, freq, amp;\
//	Pan2.ar(Resonz.ar(GrayNoise.ar, freq * 4, 0.04), pan, amp * 8);\
//\};\
//\
//pattern = Pbind(\
//	\\freq, Pseq([100, 150, 200, 225, 250, 275, 300, 350, 400], inf),\
//	\\amp, 0.1,\
//	\\pan, Pfunc(\{ 1.0.rand2 \}),\
//	\\instr, Prand([ Pseq([a],3),  Pseq([b],3),  Pseq([c],3) ], inf)\
//);\
//\
//stream = pattern.asEventStream(Event.new);\
//\
//Synth.scope(\{\
//	var out;\
//	out = OverlapTexture.ar(\{\
//		var event;\
//		event = stream.next;\
//		event.use(\{\
//			~instr.valueEnvir;\
//		\});\
//	\}, 1, 0.2, 2, 2);\
//	CombN.ar(out, 0.2, 0.2, 3, 1, out);\
//\}, 0.04);\
//)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs24 \cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 UGens as Event values.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 The following example creates unit generators instead of scalar values for\
the values bound to the arguments. This shows that you can use patterns\
to dynamically build your patch. Score data is not limited to scalar values.\
This example can generate 36 different patches: 3 instruments * 3 freqs\
* 2 amps * 2 pans\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 \
\cf4 //
\fs18 \cf4 (\
//var a, b, c, pattern, stream;\
//\
//a = \{ arg freq, amp, pan;\
//	Pan2.ar(SinOsc.ar(freq), pan, amp);\
//\};\
//b =  \{ arg amp, pan, freq;\
//	Pan2.ar(RLPF.ar(Saw.ar(freq), freq * 6, 0.1), pan, amp);\
//\};\
//c =  \{ arg pan, freq, amp;\
//	Pan2.ar(Resonz.ar(GrayNoise.ar, freq * 4, 0.04), pan, amp * 8);\
//\};\
//\
//pattern = Pbind(\
//	\\freq, \
//		Pfunc(\{\
//			// randomly choose a sweep, a vibrato, or an arpeggio\
//			[\
//				\{ XLine.kr(exprand(40, 2000), exprand(40, 2000), 2.2) \},\
//				\{ \
//					var f;\
//					f = 2000.0.rand;\
//					SinOsc.kr(20.0.linrand, 0, f * 0.5.linrand, f) \
//				\},\
//				\{ \
//					Sequencer.kr(\
//						`([ [0, 4, 7, 12], [12, 11, 10, 9] ].choose), \
//						Impulse.kr(8), \
//						1, \
//						48 + 36.rand\
//					).midicps \
//				\}\
//			].choose.value;\
//		\}),\
//	\\amp, Pfunc(\{  \
//			[\
//				\{ SinOsc.kr(20.0.rand, 0, 0.1, 0.1) \},\
//				\{ XLine.kr(exprand(0.002, 0.2), exprand(0.002, 0.2), 2.2) \} \
//			].choose.value;\
//		\}),\
//	\\pan, Pfunc(\{  \
//			[\
//				\{ Line.kr(1.0.rand2, 1.0.rand2, 2.2)  \},\
//				\{ SinOsc.kr(4.0.rand) \}\
//			].choose.value;\
//		\}),\
//	\\instr, Prand([ a, b, c ], inf)\
//);\
//\
//stream = pattern.asEventStream(Event.new);\
//\
//Synth.play(\{\
//	var out;\
//	out = OverlapTexture.ar(\{\
//		var event;\
//		event = stream.next;\
//		event.use(\{\
//			~instr.valueEnvir;\
//		\});\
//	\}, 2, 0.1, 2, 2);\
//	CombN.ar(out, 0.2, 0.2, 1, 0.7, out);\
//\});\
//)\
}