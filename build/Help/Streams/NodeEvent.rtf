{\rtf1\mac\ansicpg10000\cocoartf824\cocoasubrtf110
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 NodeEvents\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \
Event maintains a dictionary of event types in order to allow Patterns to function in different ways.\
This help file discusses the event types \\Group and \\Synth, which we call NodeEvents.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural
NodeEvents really duplicate the functionality of Group and Synth, but they follow the naming conventions\
of patterns (integers are used for addActions, integer nodeID's are used for targets).  NodeEvents can be \
used directly in patterns, but are equally useful as stand alone controls.\

\f2 				
\f1 \cf0 \
The following example creates  a group with nodeID = 2 and plays a synth within it.  \
\cf0 \

\f2 	g = (type: \\Group, id: 2);\
	g.play;\
	a = (type: \\Synth, group: 2)\
	a.play;\
	g.release;\
	g.stop;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\f1 \cf0 	
\f0\b Caution
\f1\b0 : the play method returns a time value (Event-delta), so an expression of the form\
		a = (type: \\Group, id: 1).play\
	will assign the default duration of 1 to the variable a, not the group event!\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural
\cf0 \

\f0\b\fs28 methods\
\
play				
\f1\b0 starts synth or group, returns this.delta\

\f0\b stop	
\f1\b0 			sets gate to 0 or directly frees the node\

\f0\b pause				
\f1\b0 disables the node\

\f0\b resume				
\f1\b0 reenables the node\

\f0\b set( key, value)		
\f1\b0 sets control identified by key to value\

\f0\b map(key, busID)		
\f1\b0 maps control to control bus\

\f0\b before(nodeID)		
\f1\b0 moves to immediately before nodeID
\f0\b \
after(\cf0 nodeID\cf0 )\
headOf(\cf0 nodeID\cf0 )\
tailOf(\cf0 nodeID\cf0 )\
\
split				
\f1\b0 returns an array of events, one for each synth or group specified\
					by the receiver
\f2 \

\fs24 \

\f1 With the exception of ~server, ~latency, and ~instrument any key in the event can have an array as a \
value and the standard rules of multi-channel expansion will be followed.  \
\
Here is a simple example of its use:\
(\
	g = (type: \\Group, id: [2,3,4,5,6], group: 0, addAction: 1);  // define a multiple Group event\
	g.play;										          // play it\
\
	b = (type:\\Synth, freq: [500,510], group: [2,3]);           // make a Synth event\
	b.play;\
	\
	b.set(\\freq,[1000,1200])\
\
	g.release\
\
	b.play;		\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural
\cf0 	h = g.split;                                                 // split it into individual groups\
	c = b.split;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural
\cf0 	c[0].set(\\freq,700);\
	c[1].set(\\freq,400);\
	\
	h[0].release;\
	h[1].release;\
	\
	g.stop;\
)\
\
}