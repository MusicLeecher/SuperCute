{\rtf1\mac\ansicpg10000\cocoartf824\cocoasubrtf100
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fswiss\fcharset77 Helvetica-BoldOblique;
\f3\fswiss\fcharset77 Helvetica-Oblique;\f4\fnil\fcharset77 Monaco;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red191\green0\blue0;\red191\green0\blue0;
\red0\green0\blue0;\red0\green0\blue191;\red96\green96\blue96;\red96\green96\blue96;\red0\green115\blue0;
}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 Stream
\f1\b0 \cf2 \

\f0\b\fs24 \cf0 \
superclass: AbstractFunction\
\

\f1\b0 Stream is an abstract class that is not used directly.  The following attempts to document some\
aspects of the use of Streams for music generation.\

\f0\b \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs30 \cf0 Overview\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 \
A Stream represents a sequence of values that are obtained incrementally by repeated\

\f0\b next 
\f1\b0 messages.  A Stream can be restarted with a 
\f0\b reset 
\f1\b0 message. (Not all streams \
actually implement reset semantics.)\
\
The class Object defines 
\f0\b next
\f1\b0  to return the object itself.  Thus every object can be viewed\
as a stream and most simply stream themselves.  \
\

\f0\b Stream 
\f1\b0 is the base class for classes that define streams.\
\
In SuperCollider, Streams are primarily used for handling text and for generating music.\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\i\b\fs28 \cf0 Two Stream classes: FuncStream and Routine
\f1\i0\b0\fs30 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs24 \cf0 \
\
\

\f0\b FuncStream(nextFunction, resetFunction)\

\f1\b0 \
A Function defines a stream consisting of the Function itself, a FuncStream defines a stream\
that consists of 
\f3\i evaluations 
\f1\i0 of
\f3\i  
\f1\i0 its nextFunction.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f4\fs18 \cf3 	// Example 1: a Function vs. a FuncStream
\f1\fs24 \cf0 \
	
\f4\fs18 (	\
		f = \{ 33.rand \};\
		x = \cf2 FuncStream\cf0 (f);\
		10.do(\{ [f.next, x.next].postln \});\
	)\
	\
	\cf3 // Example 2: the reset function\cf0 \
	(	\
	\
		f = \{ 33.rand \};\
		x = \cf2 FuncStream\cf0 (f, \{\cf2 thisThread\cf0 .randSeed_(345)\});\
		x.reset;\
		10.do(\{ [f.next, x.next].postln \});\
		x.reset;\
		10.do(\{ [f.next, x.next].postln \});\
	)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \

\f0\b Routine(nextFunction, stacksize)\

\f1\b0 \
In a FuncStream, the nextFunction runs through to completion for each element of the stream.\
In a Routine, the nextFunction returns values with 
\f0\b yield
\f1\b0  and resumes execution (when it receives\
a 
\f0\b next 
\f1\b0  message) at the expression folowing the yield.  This allows a sequence of expressions in\
the function definition to represent a sequence of distinct events, like a musical score.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f4\fs18 \cf3 \
	// example\cf0 \
	(\
		x = \cf2 Routine\cf0 (\{ \
					1.yield;\
					2.yield;\
					3.yield; \
			\});\
			4.do(\{ x.next.postln \});\
	)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
Once the nextFunction completes execution, the Routine simply yields nil repeatedly.\
Control structures (such as 
\f0\b do
\f1\b0  or 
\f0\b while
\f1\b0 ) can be used within the nextFunction in a manner analogous\
to repeat marks in a score\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f4\fs18 \cf3 	// example
\f1\fs24 \cf0 \
	
\f4\fs18 (\
			x = \cf2 Routine\cf0 (\{ \
				4.do(\{\
					[1,2,3,4].do(\{ \cf2 arg\cf0  i; i.yield; \});\
				\})\
			\});\
			17.do(\{ x.next.postln \});\
	)
\f1\fs24 \
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\i\b\fs30 \cf0 Playing streams
\f0\i0\fs24 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 Because streams respond like functions to the value message, \
they can be used as a scheduling task. \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f4\fs18 \cf4 	// compare:\
	// a function, returning 0.5\cf5 \
	(\
	\cf6 SystemClock\cf5 .sched(0.0, \
		\{ \cf7 "***"\cf5 .postln; 0.5 \}\
	);\
	)\
	\
	\cf3 // a stream, returning 0.5 and 0.1\cf5 \
	(\
	\cf6 SystemClock\cf5 .sched(0.0, \
		\cf6 Routine\cf5 (\{ loop \{ \
			 \cf7 "***"\cf5 .postln; 0.5.yield; \
			 \cf7 "_*_"\cf5 .postln; 0.1.yield; \
		\} \})\
	);\
	)\
	\
	\cf4 // this is the reason why 'wait' works the same (for numbers) like 'yield' \cf5 \
	(\
	\cf6 SystemClock\cf5 .sched(0.0, \
		\cf6 Routine\cf5 (\{ loop \{ \
			 \cf7 "***"\cf5 .postln; 0.5.wait; \
			 \cf7 "_*_"\cf5 .postln; 0.1.wait; \
		\} \})\
	);\
	)\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 \

\f1\b0 Streams that return 
\f0\b numbers
\f1\b0  can be played directly with the 
\f0\b play
\f1\b0  message:\
\
	\
	
\f0\b play(clock, quant)
\f1\b0 \
		
\f0\b clock
\f1\b0 :		a Clock, TempoClock by default\
		
\f0\b quant
\f1\b0 :		either a number
\f0\b  n
\f1\b0  (quantize to 
\f0\b n 
\f1\b0 beats)\
					or an array
\f0\b  [n, m]
\f1\b0  (quantize to 
\f0\b n
\f1\b0  beats, with offset 
\f0\b m
\f1\b0 )\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f4\fs18 \cf4 	// play at the next beat, with offset 0.4\cf5 \
	\cf6 (\
	Routine\cf5 (\{ loop \{ \
			 \cf7 "***"\cf5 .postln; 0.5.wait; \
			 \cf7 "_*_"\cf5 .postln; 0.1.wait; \
	\} \}).play(quant:[1, 0.4]);\
	)\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 Streams that return 
\f0\b Events
\f1\b0  need to be wrapped in an 
\f0\b EventStreamPlayer
\f1\b0 . \
The Event's 
\f0\b delta
\f1\b0  (can also be set by 
\f0\b dur
\f1\b0 ) is used as a scheduling beats value:\

\f0\b \
	
\f4\b0\fs18 \cf3 // play at the next beat, with offset 0.4\cf0 \
	\cf2 (\
	Routine\cf0 (\{ loop \{ \
			 \cf8 "///"\cf0 .postln; (delta:0.5).yield; \
			 \cf8 "_/_"\cf0 .postln; (delta: 0.1).wait; \
	\} \}).asEventStreamPlayer.play;\
	)
\f0\b\fs24 \

\f1\b0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\i\fs30 \cf0 Iteration
\f0\i0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 \
	\
	
\f0\b do (function)\
		
\f1\b0 iterate until a nil is encountered
\f0\b \
		beware:
\f1\b0  applying do to an endless stream will lock up the interpreter!
\f0\b \
\

\f1\b0 	Where 
\f0\b do 
\f1\b0 effectively 'plays' a stream by iterating all of its contects,  the \
	following messages create a stream by filtering another stream in some way.\
\
	
\f0\b collect (function)\
		
\f1\b0 iterate indefinitely
\f0\b \
\
	reject (function)\
		
\f1\b0 return only those elements for which function.value(element) is false
\f0\b \
\
	select (function)\
		
\f1\b0 return only those elements for which function.value(element) is true
\f0\b \

\f1\b0 \
	
\f0\b dot(function, stream)\
		
\f1\b0 return 
\f0\b function.value(this.next, stream.next)
\f1\b0  for each element
\f0\b \

\f1\b0 \
	
\f0\b interlace(function, stream)\
		
\f1\b0 iterate all of stream for each element of this.  Combine the values using function.
\f0\b \
	\
	appendStream(stream)
\fs28 \

\fs24 		
\f1\b0 append stream after this
\f0\b  
\f1\b0 returns nil. The same like 
\f0\b ++
\fs28 \

\fs24 	
\f1\b0 \
	
\f0\b embedInStream(inval)\
		
\f1\b0 iterate all of this from within whatever Stream definition it is called.
\f0\b \
	
\f1\b0 \

\f0\b 	trace(key, printStream, prefix)
\f1\b0 \
		print out the results of a stream while returning the original values\
		\
		
\f0\b key
\f1\b0 : 			when streaming events, post only this key.\
		
\f0\b printStream
\f1\b0 : 	printOn this stream (default: Post)\
		
\f0\b prefix
\f1\b0 :		string added to the printout to separate different streams
\f0\b \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs28 \cf0 \
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\i\b\fs32 \cf0 Composite Streams
\f0\i0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs28 \cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs26 \cf0 Routines can be embedded in each other, using 
\f0\b embedInStream
\f1\b0 :
\f0\b\fs28 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f4\b0\fs18 \cf3 	// example\cf0 \
	(\
	x = \cf2 Routine\cf0 (\{ \
				2.do(\{\
					[1,2,3,4].do(\{ \cf2 arg\cf0  i; i.yield; \});\
				\})\
			\});\
	y = \cf2 Routine\cf0 (\{\
			100.yield;\
			30.yield;\
			x.embedInStream;\
			440.yield;\
			1910.yield\
	\});\
	17.do(\{ y.next.postln \});\
	)\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 Routines can be 
\f0\b concatenated
\f1\b0  just like Streams:
\f4\fs18 \
\
	(\
	x = \cf2 Routine\cf0 (\{ \
				2.do(\{\
					[1,2,3,4].do(\{ \cf2 arg\cf0  i; i.yield; \});\
				\})\
			\});\
	y = \cf2 Routine\cf0 (\{\
			100.yield;\
			30.yield;\
	\});\
	z = x ++ y;\
	17.do(\{ z.next.postln \});\
	)\
\

\f1\fs24 Routines can be combined with the 
\f0\b composition
\f1\b0  operator 
\f0\b <>
\f1\b0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f4\fs18 \cf0 \
	(\
	x = \cf2 Routine\cf0 (\{ \cf2 arg\cf0  inval;\
				2.do(\{\
					\
					[1,2,3,4].do(\{ \cf2 arg\cf0  i; \
						if(inval.isNil) \{ \cf2 nil\cf0 .alwaysYield \};\
						inval = (i * inval).yield; \
					\});\
				\})\
			\});\
			\
	y = \cf2 Routine\cf0 (\{\
			100.yield;\
			30.yield;\
			4.do \{ 1.0.rand.yield \};\
	\});\
	\
	z = x <> y;\
	17.do(\{ z.value.postln \}); \cf3 // call .value here, as this is a function.\cf0 \
	)
\f0\b\fs30 \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 Composite Streams can be defined as combinations of Streams using the unary and binary \
messages.
\f0\b\fs30 \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\i \cf0 Unary messages
\f0\i0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 \
Streams support most of the unary messages  defined in AbstractFunction:\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f4\fs18 \cf0 (\
	a = \cf2 Routine\cf0 (\{ 20.do(\{ 33.rand.yield \}) \});\
	b = \cf2 Routine\cf0 (\{ [-100,00,300,400].do(\{ \cf2 arg\cf0  v; v.yield\}) \});\
\
	c = b.neg; \cf3 // define a composite stream		\cf0 \
	\
	\cf3 // enumerate and perform all of the unary messages	:	\cf0 \
	[ \
		\cf9 \\neg\cf0 , \cf9 \\reciprocal\cf0 , \cf9 \\bitNot\cf0 , \cf9 \\abs\cf0 , \cf9 \\asFloat\cf0 , \cf9 \\asInteger\cf0 , \cf9 \\ceil\cf0 , \
		\cf9 \\floor\cf0 , \cf9 \\frac\cf0 , \cf9 \\sign\cf0 , \cf9 \\squared\cf0 , \cf9 \\cubed\cf0 , \cf9 \\sqrt\cf0 , \cf9 \\exp\cf0 , \cf9 \\midicps\cf0 , \
		\cf9 \\cpsmidi\cf0 , \cf9 \\midiratio\cf0 , \cf9 \\ratiomidi\cf0 , \cf9 \\ampdb\cf0 , \cf9 \\dbamp\cf0 , \cf9 \\octcps\cf0 , \
		\cf9 \\cpsoct\cf0 , \cf9 \\log\cf0 , \cf9 \\log2\cf0 , \cf9 \\log10\cf0 , \cf9 \\sin\cf0 , \cf9 \\cos\cf0 , \cf9 \\tan\cf0 , \cf9 \\asin\cf0 , \cf9 \\acos\cf0 , \cf9 \\atan\cf0 , \
		\cf9 \\sinh\cf0 , \cf9 \\cosh\cf0 , \cf9 \\tanh\cf0 , \cf9 \\rand\cf0 , \cf9 \\rand2\cf0 , \cf9 \\linrand\cf0 , \cf9 \\bilinrand\cf0 , \cf9 \\sum3rand\cf0 , \
		\cf9 \\distort\cf0 , \cf9 \\softclip\cf0 , \cf9 \\coin\cf0 , \cf9 \\even\cf0 , \cf9 \\odd\cf0 , \cf9 \\isPositive\cf0 , \cf9 \\isNegative\cf0 ,\
		\cf9 \\isStrictlyPositive\cf0 \
	]\
	.do(\{ \cf2 arg\cf0  msg;\
			postf(\cf8 "\\n msg: % \\n"\cf0 , msg);\
			b.reset.perform(msg).do(\{\cf2 arg\cf0  v; v.post; \cf8 " "\cf0 .post;\}) \
	\}); \
	nil;\
	\
)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\i\b\fs30 \cf0 Binary messages
\f0\i0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 \
Streams support the following binary messages  defined in AbstractFunction:\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f4\fs18 \cf0 \
\
(\
	a = \cf2 Routine\cf0 (\{ 20.do(\{ 33.rand.yield \}) \});\
	b = \cf2 Routine\cf0 (\{ [-100,00,300,400].do(\{ \cf2 arg\cf0  v; v.yield\}) \});\
	[\
	\cf9 '+'\cf0  , \cf9 '-'\cf0  , \cf9 '*'\cf0 , \cf9 '/'\cf0 , \cf9 \\div\cf0 , \cf9 '%'\cf0 , \cf9 '**'\cf0 , \cf9 \\min\cf0 , \cf9 \\max\cf0 , \cf9 '<'\cf0 , \cf9 '<='\cf0 , \cf9 '>'\cf0 , \cf9 '>='\cf0 , \cf9 '&'\cf0 , \cf9 '|'\cf0 , \
	\cf9 \\bitXor\cf0 , \cf9 \\lcm\cf0 , \cf9 \\gcd\cf0 , \cf9 \\round\cf0 , \cf9 \\trunc\cf0 , \cf9 \\atan2\cf0 , \
	\cf9 \\hypot\cf0 , \cf9 '>>'\cf0 , \cf9 '+>>'\cf0 , \cf9 \\ring1\cf0 , \cf9 \\ring2\cf0 , \cf9 \\ring3\cf0 , \cf9 \\ring4\cf0 , \
	\cf9 \\difsqr\cf0 , \cf9 \\sumsqr\cf0 , \cf9 \\sqrdif\cf0 , \cf9 \\absdif\cf0 , \cf9 \\amclip\cf0 ,\
	\cf9 \\scaleneg\cf0 , \cf9 \\clip2\cf0 , \cf9 \\excess\cf0 , \cf9 '<!'\cf0 , \cf9 \\rrand\cf0 , \cf9 \\exprand\cf0 \
	]\
		.do(\{ \cf2 arg\cf0  msg;\
			postf(\cf8 "\\n msg: % \\n"\cf0 , msg);\
			b.reset.perform(msg).do(\{ \cf2 arg\cf0  v; v.post; \cf8 " "\cf0 .post; \}) \
		\}); \
		\cf2 nil\cf0 ;\
)
\f1\fs24 \
 \
\
	}