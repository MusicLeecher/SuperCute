{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fnil\fcharset77 Futura-Medium;\f1\fswiss\fcharset77 Helvetica-Bold;\f2\fnil\fcharset77 Monaco;
\f3\fswiss\fcharset77 Helvetica;\f4\fnil\fcharset77 LucidaGrande;}
{\colortbl;\red255\green255\blue255;\red163\green146\blue90;\red0\green0\blue0;\red191\green0\blue0;
\red0\green0\blue191;\red0\green0\blue191;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs40 \cf0 ProxySpace 		
\f1\b\fs24 an environment of references on a server 
\f2\b0\fs18 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b\fs24 \cf0 superclass: EnvironmentRedirect \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs18 \cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs24 \cf0 Generally a proxy is a placeholder for something, which in this case \
is something playing on a server that writes to a limited number of busses.\
(this can be for example a synth or an event stream)\
\
\
When accessed, ProxySpace returns a [
\f1\b NodeProxy
\f3\b0 ]. \
\
The rate is determined in a lazy way from the first object put into this environment. \
Once it is created it can only be set to a function that returns the same rate and a number \
of channels equal to the intial one or smaller. see [
\f1\b the_lazy_proxy]
\f4\b0 \

\f3 \
if the ugen function's number of channels is smaller, the offset in 'put' can be used to offset the ugens\
if the number of channels is larger, the outputs will wrap around and mix accordingly.\
\
note that the two expressions are equivalent: \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 ~out = something; 
\f3\fs24   \

\f2\fs18 currentEnvironment.put(\\out, something);\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs24 \cf0 \
a proxyspace can be created when its server is not running and played later.\
\
see also: [
\f1\b NodeProxy
\f3\b0 ][
\f1\b jitlib_efficiency
\f3\b0 ]\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf2 \
				\
				
\f3\fs24 \cf0 \
Note:\
The following examples can be executed line by line, usually in any order. \
code that should be evaluated together is set in parentheses.
\f2\fs18 \
\cf2 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs26 \cf0 \ul \ulc0 class methods
\f2\fs18 \ulnone \
\
\
	
\f1\b\fs26 *new(server, name, clock)
\f2\b0\fs18 \
		\
		
\f1\b\fs24 server
\f3\b0 : 	a Server object. note that on remote computers the clock must be in sync\
		
\f1\b name
\f3\b0 : 	a symbol. if a name is given, the proxy space is 
\f1\b stored
\f3\b0  in ProxySpace.all under this name.\
		
\f1\b clock
\f3\b0 : 	for event-based or beat-sync playing use a TempoClock.
\f2\fs18 \
		\
	
\f1\b\fs26 *push(server, name, clock)
\f2\b0\fs18 \
				
\f1\b\fs24 changed behaviour!
\f2\b0\fs18 \
				
\f3\fs24 replace the currentEnvironment with a new ProxySpace and 
\f1\b clear
\f3\b0  the current one, if\
				it is a ProxySpace (avoid piling up proxy spaces in performance)\
				
\f1\b \
				
\f3\b0 In order to move to another ProxySpace while keeping the current,\
				use 
\f1\b pop 
\f3\b0 and then 
\f1\b push
\f3\b0  an new one.\
	
\f2\fs18 	\
	
\f1\b\fs26 *pop
\f2\b0\fs18 \
				
\f3\fs24 restore the previous currentEnvironment
\f0 \
			\
	\
	\

\f3\fs26 \ul instance methods\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \ulnone 	
\f0\fs24 \
	\
	
\f1\b play(key)
\f2\b0\fs18 \
				
\f3\fs24 returns a group that plays the NodeProxy at that key. \
				default key: \\out
\f0 \
	\
	
\f1\b record(key, path, headerFormat, sampleFormat)\
	
\f2\b0\fs18 	\
				
\f3\fs24 returns a RecNodeProxy that records the NodeProxy at that key
\fs26 \
	\
	
\f1\b\fs24 ar(key, numChannels, offset)\
	kr(key, numChannels, offset)
\f2\b0\fs18 \
		\
				
\f3\fs24 returns a NodeProxy output that plays the NodeProxy at that key,\
				to be used within a function  used as input to a node proxy
\f0 \
	\
	
\f1\b wakeUp
\f0\b0 	
\f3\fs26 \
				
\fs24 when the proxyspace is created without a running server this method can be used\
				to run it (internally this is done by 
\f1\b play(key) 
\f3\b0 as well.\
	
\f0 	\
		\
	
\f1\b fadeTime_
\f3\b0 	set the fadetime of all proxies as well as the default fade time\
	\
	
\f1\b free
\f3\b0 			free all proxies (i.e. free also the groups)\
	\
	
\f1\b release
\f3\b0 		release all proxies (i.e. keep the groups running)\
	\
	
\f1\b clear
\f3\b0 		clear the node proxy and remove it from the environment. this frees all buses.\
	\
	
\f1\b *clearAll
\f3\b0 		clear all registered spaces\
	\
	
\f2\fs18 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs24 \cf0 \ul "garbage collecting":\ulnone \
	
\f2\fs18 \
	
\f1\b\fs24 clean(exclude)
\f3\b0 \
				free and remove all proxies that are not needed in order to play the \
				ones passed in with 'exclude'. if none are passed in, all proxies\
				that are monitoring (with the .play message) are kept as well as their parents etc. \
				\
	
\f1\b reduce(to)
\f3\b0 \
				free all proxies that are not needed in order to play the \
				ones passed in with 'to'. if none are passed in, all proxies\
				that are monitored (with the play message) are kept as well as their parents etc.\
				
\f2\fs18 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs26 \cf0 ____________________________________________________
\f2\fs18 \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 \
\cf4 // examples\cf3 \
\
(\cf0 \
s = \cf5 Server\cf0 .local;\
s.boot;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf5 p = ProxySpace\cf0 .push(s);\
)\
\
~out.play;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 ~out = \{ \cf6 SinOsc\cf3 .ar([400, 407] * 0.9, 0, 0.2) \};\
\
~out = \{ \cf6 SinOsc\cf3 .ar([400, 437] * 0.9, 0, 0.2) * \cf6 LFPulse\cf3 .kr([1, 1.3]) \};\
\
\cf0 ~out = \{ \cf5 SinOsc\cf0 .ar([400, 437] * 0.9, 0, 0.2) * ~x.kr(2) \};\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 \
\cf0 ~x = \{\'ca\cf5 LFPulse\cf0 .kr([1, 1.3] * MouseX.kr(1, 30, 1)) \};\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 ~out = \{ \cf5 SinOsc\cf0 .ar([400, 437] * Lag.kr(0.1 + ~x.kr(2), 0.3), 0, 0.2) * ~x.kr(2) \};\
\
p.fadeTime = 5;\
\
~out = \{ \cf5 SinOsc\cf0 .ar([400, 437] * 1.1, 0, 0.2) * ~x.kr(2) \};\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
\cf3 p.end(8); \cf4 // end all in 8 sec.\cf3 \
\cf0 \
\cf3 \
p.clear.pop; \cf4 // remove all, move out.\cf3 \
\cf0 \
\
\
\
for more examples see: [\ul proxyspace_examples\ulnone ]  [\ul jitlib_basic_concepts_01\ulnone ]
\f3\fs24 	
\f2\fs18 \
\
\
\
}