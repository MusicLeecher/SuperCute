{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fnil\fcharset77 Futura-Medium;\f1\fswiss\fcharset77 Helvetica-Bold;\f2\fnil\fcharset77 Monaco;
\f3\fswiss\fcharset77 Helvetica;}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue191;\red0\green115\blue0;
\red96\green96\blue96;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs36 \cf0 NodeProxy		
\f1\b\fs24 a reference on a server 
\fs36 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs18 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b\fs24 \cf0 superclass: BusPlug
\fs26 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs18 \cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs24 \cf0 Generally a proxy is a placeholder for something, which in this case \
is something playing on a server that writes to a limited number of busses.\
\
(this can be for example a synth or an event stream). The rate and number\
of channels is determined either when the instance is created (.control/.audio) \
or by lazy initialisation from the first source.[
\f1\b the_lazy_proxy
\f3\b0 ]\
These objects  can be replaced, mapped and patched and used for calculation. \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b \cf0 ProxySpace
\f3\b0  returns instances of NodeProxy. all the examples below apply to ProxySpace accordingly:\
\
a = NodeProxy(s) 	is equivalent to  ~a;\
a.source = ...		is equivalent to  ~a = ...\
a[3] = ...			is equivalent to  ~a[3] = ...\
\
see also: [
\f1\b jitlib_efficiency
\f3\b0 ]\
\
\
\
\
note that NodeProxy plays on a \ul private bus\ulnone . \
if you want to hear the output, use p.
\f1\b play
\f3\b0  and p.
\f1\b stop
\f3\b0 .\
free only the inner players:		 	p.
\f1\b free
\f3\b0  \
for free inner players \ul and\ulnone  stop listen:	p.
\f1\b end
\f3\b0 \
entirely removing all inner settings:   	p.
\f1\b clear
\f3\b0 \
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs26 \cf0 \ul \ulc0 instance creation
\fs24 \ulnone \
\
	
\f1\b *new(server)\
	*audio(server, numChannels)\
	*control(server, numChannels)
\f3\b0 \

\f1\b \
\
\

\f3\b0\fs26 \ul reading from the bus
\f1\b\fs24 \ul \
\ulnone \
\
	play(index, numChannels, group, multi)\
		
\f3\b0 play output on specified bus index (default: public busses)\
		this works like a monitor.\
		if multi is set to true it can create multiple monitors 
\f1\b \
	stop(fadeTime)\
		
\f3\b0 stop to play out public channels (private channels keep playing as others might listen still)\
		this stop the monitoring. to stop the objects playing, use 
\f1\b free, release\
		fadeTime: 
\f3\b0 decay time for this action
\f1\b \
	\
	end(fadeTime)\
		
\f3\b0 releases the synths and stops playback\
		
\f1\b fadeTime: 
\f3\b0 decay time for this action\
		\
		
\f1\b \
	ar(numChannels)\
	kr(numChannels)\
	\
		
\f3\b0 return a link to my output, which is limited by [numChannels]\
		causes an uninitialized proxy to create a matching bus.\
	\
	normally ar defaults to stereo, kr to mono. this can be set in the classvars:\
	
\f1\b defaultNumAudio, defaultNumControl
\f3\b0 \
	\

\fs26 \ul \
supported inputs
\f2\fs18 \ulnone \
			\
	NodeProxy					played by reading from\
	Function					interpreted as UGenFunc\
	SimpleNumber				used to write to bus continously\
	Bus						reads from that bus\
	SynthDef					plays a synth from the def\
	Symbol					plays a synth from the def with this name\
	Pattern					played as event pattern\
	Stream					played as event stream\
	nil						removes all objects\
	Pdef						played like a stream\
	Task						played, no output assigned\
	Tdef						played like Task\
	AbstractPlayer			started in a separate bus, mapped to this bus\
	Instr					converted to player and started\
	\
	Associations: \
	(\\filter -> func)			filter previous input\
	(\\set -> event pattern)		set controls
\f3\fs24 \
	\
	
\f1\b \ul \

\f3\b0\fs26 \ul setting the source:
\f1\b\fs24 \ul \
\ulnone \
\
	source_(anObject)\
		
\f3\b0 play a new synth through me, release old one.\
		anObject can be one of the supported inputs (see above)\
			[only if the used synthdef (applies also to patterns) has the right number of channels\
			and an out argument, this can be used to do filtering. \
			if you supply a gate, the nodeProxy will assume doneAction 2 and fade out].\
		
\f1\b \
	add(anObject, channelOffset, extraArgs)\
		
\f3\b0 play a new synth, add it to the present ones\
	\
	
\f1\b removeAt(index)\
		
\f3\b0 remove the synth at index i and its player definition\
	\
	
\f1\b removeLast\
		
\f3\b0 remove the last synth and its player definition
\f1\b \
	\
	put(index, anObject, channelOffset, extraArgs)\
		
\f3\b0 set the source by index. \
			
\f1\b index
\f3\b0 :	\
						where the object should be placed in the internal  order. \
						if 
\f1\b -1
\f3\b0 , all objects are freed\
			
\f1\b anObject
\f3\b0 :	 \
						can be a Function, an Instr, any valid UGen input\
						a pattern can be used if it returns an EventStream.\
			
\f1\b channelOffset
\f3\b0 : 	\
						using a multichannel setup it can be useful to set this.\
						when the objects numChannels is smaller than the proxy \
						\
			
\f1\b extraArgs
\f3\b0 : 	extra arguments that can be sent with the object directly (not cached)\
			\

\f1\b 	put 
\f3\b0 can be used as array indexing: 
\f1\b a[0]
\f3\b0  = \{ SinOsc.ar \}\
	one can put an object at any index, only the order of indices is relevant.\
	if the index equals an existing index, the object at this index is replaced.\
	using multiple index expands into multiple objects: 
\f1\b a[0..3] 
\f3\b0 = ... or 
\f1\b a[[0, 4, 6]]
\f3\b0  = [ .., ..., ..]
\f1\b \
	\
	pause\
		
\f3\b0 pause all objects and set proxy to paused\
	\
	
\f1\b resume\
		
\f3\b0 if paused, start all objects \

\f1\b \
\
\
	\
	\

\f3\b0\fs26 \ul group-like behaviour:
\f1\b\fs24 \ulnone \
\
	set(key, val, ...)\
		
\f3\b0 I behave like my nodeMap: see [NodeMap]\
		set, setn, unset, unmap\
		\
	
\f1\b map(key(s), proxy,  ... )
\f3\b0 \
		map the arguments in keys to the subsequent channels of a 
\f1\b control proxy
\f3\b0 \
		(keys can be a symbol or a number)\
		if the proxy has 
\f1\b multiple channels
\f3\b0 , subsequent channels of the control, \
		if present, are mapped (mapn)\
			note that you should not map to more channels than the control has.\
		\
	
\f1\b setn(key, list, ...)
\f3\b0  \
		set ranges of controls\
	\
	
\f1\b run(flag)
\f3\b0 \
		pause/unpause all synths in the group\
		\
	
\f1\b \
\

\f3\b0\fs26 \ul extended group-like behaviour:
\f1\b\fs24 \ul \
\ulnone 	\
	xset(key, val, ...)\
		
\f3\b0 set with crossfade into new setting\
		\
	x
\f1\b map(keys, proxy)
\f3\b0 \
		map with crossfade into new setting\
	\
	
\f1\b xsetn()\
		
\f3\b0 untested\
	\
	
\f1\b lag(key, val, ...)	
\f3\b0 \
		set the lag values of these args (identical to setRates)\
		to remove these settings, use: 
\f1\b lag(\\key1, nil, key2, nil, ...)
\f3\b0 \
	\
	
\f1\b setRates(key, rate1, ...)
\f3\b0 \
		set the default rate (\\tr, \\ir, numerical) for synthDef arg\
		rate of 
\f1\b nil
\f3\b0  removes setting\
\
\
\

\fs26 \ul bus-like behaviour:
\f1\b\fs24 \ul \

\f3\b0 \ulnone \
	
\f1\b line(value, dur)\
		
\f3\b0 set my bus to the new value in dur time linearly\
	x
\f1\b line(value, dur)\
		
\f3\b0 set my bus to the new value in dur time exponentially\
	
\f1\b gate(value, dur)\
		
\f3\b0 gate my bus to the level value for dur time\
		\
	// do not work properly yet !\
	
\f1\b lineAt(key, value, dur)\
		
\f3\b0 set the control value to the new value in dur time linearly\
	x
\f1\b lineAt(key, value, dur)\
		
\f3\b0 set control value to the new value in dur time exponentially\
	
\f1\b gateAt(key, value, dur)\
		
\f3\b0 gate my control to the level value for dur time.\
		if the control was not set before, stay at the new value
\f1\b \

\f3\b0 \
\

\f1\b \
\
	\

\f3\b0\fs26 \ul sending synths to server
\f1\b\fs24 \ul \

\f3\b0 \ulnone 	(normally the source_() message does the sending already, but it can be used for spawning)
\f1\b \
	\
	wakeUp \
			
\f3\b0 until the proxy is not used by any output ( either .play or .ar/.kr )\
			it is not running on the server. you can wake it up to force it playing.\
			normally this is not needed.
\f1\b \
	\
	send(argList, index, freeLast)\
		
\f3\b0 send a new synth without releasing the old one.\
		the argument list is applied to the synth only.\
		freeLast: if to free the last synth at that index\
		if index is nil, sends all\
		\
	
\f1\b sendAll(argList, freeLast)\
		
\f3\b0 send all synths without releasing the old one.\
		the argument list is applied to all synths.\
		freeLast: if to free present synths
\f1\b \
	\
	
\f3\b0 \
			
\f1\b \

\f3\b0\fs26 \ul release and cleaning up:
\f1\b\fs24 \ul \
\ulnone \
	free(fadeTime)\
		
\f3\b0 release all my running synths and the group\
		
\f1\b fadeTime: 
\f3\b0 decay time for this action
\f1\b \
	\
	release(fadeTime)\
		
\f3\b0 release running synths\
		
\f1\b fadeTime: 
\f3\b0 decay time for this action\
	\
	
\f1\b clear(fadeTime)\
		
\f3\b0 reset everything to nil, neutralizes rate/numChannels\
		if a fadeTime is given, first fade out, then clear.
\f1\b \
	\
\

\f3\b0\fs26 \ul setting properties:
\f1\b\fs24 \ulnone \
	\
	fadeTime_(time)\
		
\f3\b0 set the attack/release time \
	\
	
\f1\b clock_(aClock)
\f3\b0 \
		use a tempo clock for scheduling beat accurate\
	
\f1\b \

\f3\b0 	\

\fs26 \ul misc:
\f1\b\fs24 \ul \

\f3\b0 \ulnone \
	
\f1\b record(path, headerFormat, sampleFormat)\
		
\f3\b0 record output to file (returns a [RecNodeProxy] that you can use for control)\
		returns a [RecNodeProxy]\
	\
	
\f1\b *defaultNumAudio_(n)\
		
\f3\b0 set the default channel number for audio busses\
	
\f1\b \
	*defaultNumControl_(n)\
		
\f3\b0 set the default channel number for control busses\
		\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs26 \cf0 _________________________________________________________\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs26 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b\fs24 \cf0 for more examples see [ProxySpace]
\f3\b0 	
\f2\fs18 \
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // examples\cf0 \
s = \cf3 Server\cf0 .local;\
s.boot;\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b\fs24 \cf0 using node proxy with ugen functions
\f2\b0\fs18 \
\
\
a = \cf3 NodeProxy\cf0 .audio(s, 2);\
a.play; \cf2 // play to hardware output, return a group with synths\cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // setting the source\cf0 \
a.source = \{ \cf3 SinOsc\cf0 .ar([350, 351.3], 0, 0.2) \};\
\
\cf2 // the proxy has two channels now:\cf0 \
a.numChannels.postln;\
a.source = \{ \cf3 SinOsc\cf0 .ar([390, 286] * 1.2, 0, 0.2) \};\
\
\cf2 // exeeding channels wrap:\cf0 \
a.source = \{ \cf3 SinOsc\cf0 .ar([390, 286, 400, 420, 300] * 1.2, 0, 0.2) \};\
\
\cf2 // other inputs\cf0 \
a.source = \{ \cf3 WhiteNoise\cf0 .ar([0.01,0.01]) \};\
a.source = 0;\
a.source = \cf4 \\default\cf0 ; \cf2 // synthDef on server\cf0 \
a.source = \cf3 SynthDef\cf0 (\cf5 "w"\cf0 , \{ \cf3 arg\cf0  out=0; \cf3 Out\cf0 .ar(out,\cf3 SinOsc\cf0 .ar([\cf3 Rand\cf0 (430, 600), 600], 0, 0.2)) \});\
a.source = \cf3 nil\cf0 ; \cf2 //  removes any object\cf0 \
\
\cf2 // feedback\cf0 \
a.source = \{ \cf3 SinOsc\cf0 .ar(a.ar * 7000 * \cf3 LFNoise1\cf0 .kr(1, 0.3, 0.6) + 200, 0, 0.1) \};\
a.source = \{ \cf3 SinOsc\cf0 .ar(a.ar * 6000 * \cf3 MouseX\cf0 .kr(0, 2) + [100, 104], 0, 0.1) \};\
\
\cf2 // fadeTime\cf0 \
a.fadeTime = 2.0;\
a.source = \{ \cf3 SinOsc\cf0 .ar([390, 286] * \cf3 ExpRand\cf0 (1, 3), 0, 0.2) \};\
\
\
\cf2 // adding nodes\cf0 \
a.add(\{ \cf3 SinOsc\cf0 .ar([50, 390]*1.25, 0, 0.1) \});\
a.add(\{ \cf3 BrownNoise\cf0 .ar([0.02,0.02]) \});\
\
\cf2 // setting nodes at indices:\cf0 \
a[0] = \{ \cf3 SinOsc\cf0 .ar( 700 * \cf3 LFNoise1\cf0 .kr(1, 0.3, 0.6) + 200, 0, 0.1) \};\
a[1] = \{ \cf3 LFPulse\cf0 .kr(3, 0.3) * \cf3 SinOsc\cf0 .ar(500, 0, 0.1) \};\
a[2] = \{ \cf3 LFPulse\cf0 .kr(3.5, 0.3) * \cf3 SinOsc\cf0 .ar(600, 0, 0.1) \};\
a[3] = \{ \cf3 SinOsc\cf0 .ar([1,1.25] * 840, 0, 0.1) \};\
\
\cf2 // filtering: the first argument is the previous bus content. more args can be used as usual.\cf0 \
a[3] = \cf4 \\filter\cf0  -> \{ \cf3 arg\cf0  in; in * \cf3 SinOsc\cf0 .ar(\cf3 Rand\cf0 (100,1000)) \};\
a[2] = \cf4 \\filter\cf0  -> \{ \cf3 arg\cf0  in; in * \cf3 MouseY\cf0 .kr(0,1) \};\
a[8] = \cf4 \\filter\cf0  -> \{ \cf3 arg\cf0  in; in * \cf3 MouseX\cf0 .kr(0,1) \};\
a[4] = \cf4 \\filter\cf0  -> \{ \cf3 arg\cf0  in; in * \cf3 SinOsc\cf0 .ar(\cf3 ExpRand\cf0 (1,5)).max(0) \};\
\
\
\
\cf2 // setting controls\cf0 \
a.fadeTime = 2.0;\
a.source = \{ \cf3 arg\cf0  f=400; \cf3 SinOsc\cf0 .ar(f * [1,1.2] * rrand(0.9, 1.1), 0, 0.1) \};\
a.set(\cf4 \\f\cf0 , rrand(900, 300));\
a.set(\cf4 \\f\cf0 , rrand(1500, 700));\
a.xset(\cf4 \\f\cf0 , rrand(1500, 700)); \cf2 // crossfaded setting\cf0 \
a.source = \{ \cf3 arg\cf0  f=400; \cf3 RLPF\cf0 .ar(\cf3 Pulse\cf0 .ar(f * [1,1.02] * 0.05, 0.5, 0.2), f * 0.58, 0.2) \};\
\
\cf2 // control lags\cf0 \
a.fadeTime = 0.01;\
a.lag(\cf4 \\f\cf0 , 0.5); \cf2 // the objects are built again internally and sent to the server.\cf0 \
a.set(\cf4 \\f\cf0 , rrand(1500, 700));\
a.lag(\cf4 \\f\cf0 , \cf3 nil\cf0 );\
a.set(\cf4 \\f\cf0 , rrand(1500, 700));\
a.fadeTime = 1.0;\
\
\cf2 // mapping controls to other node proxies\cf0 \
\
c = \cf3 NodeProxy\cf0 .control(s, 2);\
c.source = \{ \cf3 SinOsc\cf0 .kr([10,20] * 0.1, 0, 150, 1300) \};\
a.map(\cf4 \\f\cf0 , c);\
a[0] = \{ \cf3 arg\cf0  f=400; \cf3 RHPF\cf0 .ar(\cf3 Pulse\cf0 .ar(f * [1,1.2] * 0.05, 0.5, 0.2), f * 0.58, 0.2) \};\
c.source = \{ \cf3 SinOsc\cf0 .kr([10,16] * 0.02, 0, 50, 700) \};\
c.source = \{ \cf3 Line\cf0 .kr(300, 1500, 10) + \cf3 SinOsc\cf0 .kr(20 * [1,2], 0, 100) \};\
a[1] = \{ \cf3 arg\cf0  f; \cf3 LFPar\cf0 .ar(f % \cf3 MouseX\cf0 .kr(1, 40, 1) * 4 + 360, 0, 0.2) \};\
\
\cf2 // map multiple channels of one proxy to multiple controls of another\cf0 \
\cf2 // recently changed behaviour!\cf0 \
\
a.source = \{ \cf3 arg\cf0  f=#[400, 400]; \cf3 LPF\cf0 .ar(\cf3 Pulse\cf0 .ar(f[0] * [0.4,1], 0.2, 0.2), f[1] * 3) \};\
a.map(\cf4 \\f\cf0 , c); \cf2 // multichannel proxy c is mapped to multichannel control of a\cf0 \
a.source = \{ \cf3 arg\cf0  f=#[400, 400]; \cf3 LPF\cf0 .ar(\cf3 Pulse\cf0 .ar(f, 0.2, 0.2), f[1]) \};\
a.source = \{ \cf3 arg\cf0  f=#[400, 400]; \cf3 Formant\cf0 .ar(140, f * 1.5, 100, 0.1)  \};\
c.source = \{ \cf3 SinOsc\cf0 .kr([\cf3 Line\cf0 .kr(1, 30, 10), 1], 0, [100, 700], [300, 700]) \};\
c.source = 400;\
\
\
c.fadeTime = 5.5;\
c.source = \{ \cf3 LFNoise0\cf0 .kr([2.3, 1.0], [100, 700], [300, 1700]) \};\
c.source = \{ \cf3 SinOsc\cf0 .kr([2.3, 1.0], 0, [100, 700], [300, 1700]) \};\
c.source = 400;\
\
\
\cf2 // behave like a sc2 plug\cf0 \
c.gate(1400, 0.1);\
c.gate(1000, 0.1);\
c.line(1000, 1);\
\
\cf2 // direct access\cf0 \
a.lineAt(\cf4 \\f\cf0 , 300, 2);\
a.xlineAt(\cf4 \\f\cf0 , 600, 0.3);\
a.gateAt(\cf4 \\f\cf0 , 1600, 0.3);\
\
\
\cf2 // changing nodeMaps\cf0 \
a.unmap(\cf4 \\f\cf0 );\
n = a.nodeMap.copy;\
n.set(\cf4 \\f\cf0 , 700);\
a.fadeToMap(n);\
n = a.nodeMap.copy;\
n.set(\cf4 \\f\cf0 , 400);\
a.fadeTime = 1.0;\
a.fadeToMap(n, [\cf4 \\f\cf0 ]); \cf2 // linear interpolation to new map: experimental\cf0 \
a.map(\cf4 \\f\cf0 , c); \cf2 // restore mapping\cf0 \
\
\
\cf2 // sending envelopes (up to 8 levels)\cf0 \
w = \cf3 Env\cf0 .new(\cf3 Array\cf0 .rand(3, 400, 1000),\cf3 Array\cf0 .rand(2, 0.3, 0.001), -4);\
c.env(w);\
c.env(w);\
w = \cf3 Env\cf0 .new(\cf3 Array\cf0 .rand(8, 400, 1000),\cf3 Array\cf0 .rand(7, 0.03, 0.1));\
c.env(w);\
c.env(w);\
\
\cf2 // stop synthesis, then wake up proxies:\cf0 \
\
a.stop; \cf2 // stop the monitor\cf0 \
a.play; \cf2 // start the monitor\cf0 \
a.end;	\cf2 // release the synths and stop the monitor\cf0 \
c.free;  \cf2 // free the control proxy c\cf0 \
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul channel offset/object index
\f2\fs18 \ulnone \
\
a = \cf3 NodeProxy\cf0 .audio(s,2);\
a.play;\
a[0] = \{ \cf3 Ringz\cf0 .ar(\cf3 Impulse\cf0 .ar(5, 0, 0.1), 1260) \};\
a.put(1, \{ \cf3 Ringz\cf0 .ar(\cf3 Impulse\cf0 .ar(5.3, 0, 0.1), 420) \}, 1);\
a.put(0, \{ \cf3 Ringz\cf0 .ar(\cf3 Dust\cf0 .ar([1,1]*15.3,  0.1), 720) \}, 1);\
a.put(1, \{ \cf3 Ringz\cf0 .ar(\cf3 Impulse\cf0 .ar(5.3, 0, 0.1), 420) \}, 1);\
a.end;\
\
\
\

\f0\fs24 \ul beat accurate playing\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \ulnone \
\
a = \cf3 NodeProxy\cf0 .audio(s,2);\
a.play;\
\
a.clock = \cf3 TempoClock\cf0 (2.0).permanent_(\cf3 true\cf0 ); \cf2 // round to every 2.0 seconds\cf0 \
a.source = \{ \cf3 Ringz\cf0 .ar(\cf3 Impulse\cf0 .ar(0.5, 0, 0.3), 3000, 0.01) \};\
a[1] = \{ \cf3 Ringz\cf0 .ar(\cf3 Impulse\cf0 .ar([0.5, 1], 0, 0.3), 1000, 0.01) \};\
a[2] = \{ \cf3 Ringz\cf0 .ar(\cf3 Impulse\cf0 .ar([3, 5]/2, 0, 0.3), 8000, 0.01) \};\
a[3] = \{ \cf3 Ringz\cf0 .ar(\cf3 Impulse\cf0 .ar([3, 5]*16, 0, 0.3), 5000, 0.01) * \cf3 LFPulse\cf0 .kr(0.5, 0, 0.05) \};\
\
a.removeLast;\
a.removeAt(2);\
\
a.clear;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul using patterns - event streams
\f2\fs18 \ulnone \
\
\
\
(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // must have 'out' or 'i_out' argument to work properly\cf0 \
\cf3 SynthDef\cf0 (\cf5 "who"\cf0 , \{ \cf3 arg\cf0  freq, gate=1, out=0, ffreq=800, amp=0.1; \
	\cf3 var\cf0  env;\
	env = \cf3 Env\cf0 .asr(0.01, amp, 0.5);\
	\cf3 Out\cf0 .ar(out, \cf3 Pan2\cf0 .ar(\
		\cf3 Formant\cf0 .ar(freq, ffreq, 300, \cf3 EnvGen\cf0 .kr(env, gate, doneAction:2)), \cf3 Rand\cf0 (-1.0, 1.0))\
	)\
\}).store;\
\
)\
\
\
(\
s.boot;\
a = \cf3 NodeProxy\cf0 .audio(s, 2);\
a.fadeTime = 2;\
b = \cf3 NodeProxy\cf0 .audio(s,2);\
b.fadeTime = 3;\
)\
\
a.play; \cf2 // monitor output\cf0 \
\
\cf2 // play the pattern silently in b\cf0 \
b.source = \cf3 Pbind\cf0 (\cf4 \\instrument\cf0 , \cf4 \\who\cf0 , \cf4 \\freq\cf0 , 500, \cf4 \\ffreq\cf0 , 700, \cf4 \\legato\cf0 , 0.02);\
\
\cf2 // play b out through a:\cf0 \
a.source = b;\
\
\cf2 // filter b with ring modulation:\cf0 \
a.source = \{  b.ar  * \cf3 SinOsc\cf0 .ar(\cf3 SinOsc\cf0 .kr(0.2, 300, 330))  \}; \cf2 // filter the input of the pattern\cf0 \
a.source = \{  b.ar * \cf3 LFCub\cf0 .ar([2, 8], add: -0.5)  \}; \cf2 // filter the input of the pattern\cf0 \
\
a.source = b;\
\
\cf2 // map b to another proxy\cf0 \
c = \cf3 NodeProxy\cf0 .control(s, 1).fadeTime_(1);\
c.source = \{ \cf3 SinOsc\cf0 .kr(2, 0, 400, 700) \};\
\
\
\cf2 // now one can simply embed a control node proxy into an event pattern.\cf0 \
\cf2 // (this works not for \\degree, \\midinote, etc.)\cf0 \
\cf2 // embedding in other patterns it will still return itself.\cf0 \
\
\
b.source = \cf3 Pbind\cf0 (\cf4 \\instrument\cf0 , \cf4 \\who\cf0 , \cf4 \\freq\cf0 , 500, \cf4 \\ffreq\cf0 , c, \cf4 \\legato\cf0 , 0.02);\
\
c.source = \{ \cf3 SinOsc\cf0 .kr(\cf3 SinOsc\cf0 .kr(0.2, 0, 10, 10), 0, 400, 700) \};\
\
c.source = \{ \cf3 LFNoise1\cf0 .kr(5, 1300, 1500) \};\
c.source = \{ \cf3 MouseX\cf0 .kr(100, 5500, 1) \};\
\
(\
b.source = \cf3 Pbind\cf0 (\
			\cf4 \\instrument\cf0 , \cf4 \\who\cf0 , \
			\cf4 \\freq\cf0 , \cf3 Pseq\cf0 ([600, 350, 300],\cf3 inf\cf0 ),\
			\cf4 \\legato\cf0 , 0.1,\
			\cf4 \\ffreq\cf0 , \cf3 Pseq\cf0 ([c, 100, c, 100, 300, 600], \cf3 inf\cf0 ), \cf2 // use proxy in a pattern\cf0 \
			\cf4 \\dur\cf0 , \cf3 Pseq\cf0 ([1, 0.5, 0.75, 0.25] * 0.4, \cf3 inf\cf0 ),\
			\cf4 \\amp\cf0 , \cf3 Pseq\cf0 ([0.2, 0.2, 0.1, 0.1, 0.2], \cf3 inf\cf0 )\
		);\
)\
\
 \
\
b[2] = \cf3 Pbind\cf0 (\cf4 \\instrument\cf0 , \cf4 \\who\cf0 , \cf4 \\freq\cf0 , 620, \cf4 \\ffreq\cf0 , \cf3 Prand\cf0 ([500,c],\cf3 inf\cf0 ), \cf4 \\legato\cf0 , 0.1, \cf4 \\dur\cf0 , 0.1);\
b[3] = \cf3 Pbind\cf0 (\cf4 \\instrument\cf0 , \cf4 \\who\cf0 , \cf4 \\ffreq\cf0 , 5000, \cf4 \\freq\cf0 , \cf3 Pseq\cf0 ([720, 800],\cf3 inf\cf0 ), \cf4 \\legato\cf0 , 0.1, \cf4 \\dur\cf0 , 0.1, \cf4 \\amp\cf0 , 0.01);\
b[4] = \cf3 Pbind\cf0 (\cf4 \\instrument\cf0 , \cf4 \\who\cf0 , \cf4 \\freq\cf0 , \cf3 Pseq\cf0 ([700, 400],\cf3 inf\cf0 ), \cf4 \\legato\cf0 , 0.1, \cf4 \\ffreq\cf0 , 200);\
b[1] = \{ \cf3 WhiteNoise\cf0 .ar([0.01,0.01]) \}; \
b[4] = \{ \cf3 arg\cf0  ffreq=800; \cf3 Resonz\cf0 .ar(\cf3 WhiteNoise\cf0 .ar([1,1]), ffreq, 0.05) \}; \
\
\
b.map(\cf4 \\ffreq\cf0 , c); \cf2 // map the control to the proxy\cf0 \
b.removeLast;\
b.removeLast;\
a.source = \{  b.ar * \cf3 WhiteNoise\cf0 .ar(0.1, 1)  \}; \
a.source = \{  b.ar * \cf3 WhiteNoise\cf0 .ar(0.1, 1) + (b.ar * \cf3 SinOsc\cf0 .ar(\cf3 SinOsc\cf0 .kr(0.01, 0, 50, 330)))  \}; \
\
c.source = \{ \cf3 XLine\cf0 .kr(1900, 10, 10) \};\
\
a.clear; b.clear; c.clear; \cf2 // clear all, free bus\cf0 \
\
 \
\
\
\
\
}