{\rtf1\mac\ansicpg10000\cocoartf824\cocoasubrtf100
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fnil\fcharset77 Georgia-Bold;\f2\fnil\fcharset77 Monaco;
\f3\fswiss\fcharset77 Helvetica;\f4\fswiss\fcharset77 Helvetica-Oblique;}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue191;\red0\green115\blue0;
}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs30 \cf0 proxyspace - basic concepts  			
\f1\fs72 3
\f2\b0\fs18 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs24 \cf0 \
\
internal structure of the node proxy, node order and the parameter context\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs24 \cf0 a) slots\
b) fadeTime\
b) play/stop, send/release, pause/resume, clear\
c) the parameter context\
\
\
A NodeProxy has two internal contexts in which the objects are inserted:\
The group, which is on the server, and the nodeMap, which is a client side\
parameter context. As the group can contain an order of synths, there is\
a client side representation, in which the source objects are stored (see [\ul Order\ulnone ]).
\f2\fs18 \
\
\

\f3\fs24 previous: [\ul jitlib_basic_concepts_02\ulnone ] 	next: [\ul jitlib_basic_concepts_04\ulnone ] 
\f0\b \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs18 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // make new space\cf0 \
p = \cf3 ProxySpace\cf0 .push(s.boot);\
~z.play; ~y.ar; \cf2 // explicitly initialize proxies\cf0 \
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 a) NodeProxy slots:
\f2\b0\fs18 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs24 \cf0 One node proxy can hold several objects in an execution order. The index can be any positive integer.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf2 \
// the initial slot (0) is used when assigning directly.\
// ~y is still unused, we will add it later.\cf0 \
\
~z = (~y * pi).sin * 0.1 * \{ \cf3 LFSaw\cf0 .kr(\cf3 LFNoise1\cf0 .kr(0.1 ! 3).sum * -18).max(0.2) \};\
\
\cf2 // other slot numbers are accessed by positive integers:\cf0 \
\
~y[1] = \{\'ca\cf3 Saw\cf0 .ar([400, 401.3], 0.4) \};\cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 ~y[0] = \{\'ca\cf3 Saw\cf0 .ar([300, 301], 0.4) \}; \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // to remove one of them, nil is used:\cf0 \
\
~y[0] = \cf3 nil\cf0 ;\
\
\cf2 // what is to be found at index 1?\cf0 \
~y[1] \cf2 // a playing interface\cf0 \
~y[1].source.postcs \cf2 // the function that was put in.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 ~y.source; \cf2 // this returns objects in the slots.\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs24 \cf0 multiple assignment
\f2\fs18 \cf2 \
\
// the function is assigned to th slots from 1 to 4 \cf0 \
~z[1..4] = \{ \cf3 SinOsc\cf0 .ar(exprand(300, 600), 0, \cf3 LFTri\cf0 .kr(\{exprand(1, 3)\} ! 3).sum.max(0)) * 0.1 \};\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // the function is assigned to the slots 1, 2 and 3 (subsequent)\cf0 \
~z[1..] = [ \{\cf3 SinOsc\cf0 .ar(440) * 0.1 \}, \{ \cf3 SinOsc\cf0 .ar(870) * 0.08 \}, \{ \cf3 SinOsc\cf0 .ar(770) * 0.04 \}];\
\
\cf2 // if no slot is given, all other slots are emptied\cf0 \
~z = \{\'ca\cf3 OnePole\cf0 .ar(\cf3 Saw\cf0 .ar([400, 401.3], 0.3), 0.95) \};\
\
~z.end;\
~y.end;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 \
\
\
b) fade time:\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs18 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // setting the fadeTime will allow cross fades.\cf0 \
\cf2 // in case of an audio rate proxy the fade is pseudo-gaussian\cf0 \
\cf2 // in case of a control rate proxy it is linear.\cf0 \
\
~z.play;\
\
~z.fadeTime = 5.0; \cf2 // 5 seconds\cf0 \
~z = \{ max(\cf3 SinOsc\cf0 .ar([300, 301]), \cf3 Saw\cf0 .ar([304, 304.3])) * 0.1 \};\
~z = \{ max(\cf3 SinOsc\cf0 .ar(\cf3 ExpRand\cf0 (300, 600)), \cf3 Saw\cf0 .ar([304, 304.3])) * 0.1  \};\
\
\cf2 // the fadeTime can be set effectively at any time\cf0 \
~z.fadeTime = 0.2;\
~z = \{ max(\cf3 SinOsc\cf0 .ar(\cf3 ExpRand\cf0 (3, 160)), \cf3 Saw\cf0 .ar([304, 304.3])) * 0.1 \};\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs24 \cf0 \
note that the fadeTime is also used for the operations xset and xmap.(see below)
\f2\fs18 \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 \
c) play/stop, send/free, pause/resume\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\b0 \cf0 \
there are a couple of messages a NodeProxy understands that are related to play, stop etc.\
Here is what they do.
\f0\b \
\
play/stop\
	
\f3\b0 \
	this pair of messages is related to the monitoring function of the proxy.\
	play starts monitoring, stop ends the monitoring.\
	
\f4\i if the proxy group is playing
\f3\i0  (this can be tested with .isPlaying), play will not\
	affect the proxie's internal behaviour in any way. Only if it is not playing (e.g because\
	one has freed the group by cmd-period) it starts the synths/objects in the proxy.\
	Stop never affects the internal state of the proxy.\
	\
	
\f2\fs18 \cf2 // first hit cmd-period.\cf0 \
	~z =  \{ max(\cf3 SinOsc\cf0 .ar(\cf3 ExpRand\cf0 (3, 160)), \cf3 Saw\cf0 .ar([304, 304.3])) * 0.1 \};\
	~z.play;	\cf2 // monitor the proxy\cf0 \
	~z.stop; \cf2 // note that now the proxy is still playing, but only in private\cf0 \
	~z.isPlaying; \cf2 // is the group playing? yes.\cf0 \
	~z.monitor.isPlaying; \cf2 // is the monitor playing? no.\cf0 \
	\
	
\f3\fs24 You can pass a vol argument to play to adjust the monitor volume without\
	affecting the proxy internal bus volume.\
	
\f2\fs18 \
	~z.play(vol:0.3);\
	\cf2 // while playing you can set the volume also:\cf0 \
	~z.vol = 0.8;\
	\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 send / release
\f2\b0\fs18 \
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs24 \cf0 	this pair of messages controls the synths within the proxy. It does not\
	affect the monitoring (see above). send starts a new synth, release releases the synth.\
	
\f0\b send
\f3\b0  by default releases the last synth. if the synth frees itself (doneAction 2) 
\f0\b spawn
\f3\b0  can be used.
\f2\fs18 \
	\
	\cf2 // first hit cmd-period.\cf0 \
	~z.play; \cf2 // monitor. this starts also the synth, if the group wasn't playing.\cf0 \
	\
	~z = \{ \cf3 SinOsc\cf0 .ar(\cf3 ExpRand\cf0 (20, 660) ! 2) * \cf3 Saw\cf0 .ar(\cf3 ExpRand\cf0 (200, 960) ! 2) * 0.1 \};\
	\
	~z.release; \cf2 // release the synth. the current fadeTime is used for fade out\cf0 \
	\
	~z.send; \cf2 // send a new synth. the current fadeTime is used for fade in\cf0 \
	\
	~z.send; \cf2 // send another synth, release the old\cf0 \
	\
	~z.release;\
\
	~z.stop;\
	\
	~z.play; \cf2 // monitor. as the group was still playing, this does _not_ start the proxy.\cf0 \
	\
	
\f3\fs24 in order to free the synths and the group together,  
\f0\b free
\f3\b0  is used:
\f2\fs18 \
	\
	~z.free; \cf2 // this does also not affect the monitoring.\cf0 \
	~z.play; \cf2 // monitor. as the group was not playing, this starts the proxy.\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 \
	\
	
\f3\fs24 \cf0 in order to free the synths and the group, stop playback, 
\f0\b end
\f3\b0  is used.\
	
\f2\fs18 \
	~z.end(3); \cf2 // end in 3 sec\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs24 \cf0 	in order to rebuild the synthdef on the server, use 
\f0\b rebuild
\f3\b0 .\
	this can make sense when the synthdef has a statistic architecture (but of course this is far less efficient than 
\f4\i send
\f3\i0 )
\f2\fs18 \cf2 \
	\
	(\
	\cf0 ~z = \{ \
		sum(\
		\cf3 	SinOsc\cf0 .ar(Rand(300,400) + (\{exprand(1, 1.3)\} ! rrand(1, 9)))\
			* \cf3 LFCub\cf0 .ar(\{exprand(30, 900)\} ! rrand(1, 9))\
			* LFSaw.kr(\{exprand(1.0, 8.0)\} ! rrand(1, 9)).max(0)\
			* 0.1\
		)\
	\};\
	)\
	\cf2 \
	\cf0 ~z.play;\
	~z.rebuild;\
	~z.send;	\cf2 // send just creates a new synth\cf0 \
	~z.rebuild; \cf2 // rebuild the synthdef\cf0 \
	~z.end;\cf2 \
	\cf0 \
	\
	
\f3\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 \
pause / resume
\f3\b0 \
	when paused, a node proxy still stays active, but every synth that is started is paused until\
	the proxy is resumed again.\
\
	
\f2\fs18 ~z.play;\
	\
	~z.pause; \cf2 // pause the synth.\cf0 \
	\
	~z = \{ \cf3 SinOsc\cf0 .ar(\{\cf3 ExpRand\cf0 (300, 660)\} ! 2) * 0.1 \}; 	\cf2 // you can add a new function, \cf0 \
												\cf2 // which is paused.\cf0 \
	\
	~z.resume; \cf2 // resume playing.\
	\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs24 \cf0 	Note that pause/resume causes clicks with audio rate proxies, which do not \
	happen when pauseing control rate proxies.
\f2\fs18 \
												\
\
	
\f3\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 clear
\f3\b0 	\
\
	clear removes all synths, the group, the monitor and releases the bus number.\
\
	
\f2\fs18 ~z.clear;\
	~z.bus; 		\cf2 // no bus\cf0 \
	~z.isNeutral; \cf2 // not initialized.
\f3\fs24 \cf0 \
	\
	note that when other processes use the nodeproxy these are not notified. So clearing has to \
	be done with regard to this.\
\
\
\
\
\
\
\
\
\

\f0\b d) The parameter context\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\b0 \cf0 \
\
what happens to function arguments?\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 	~y.play;\
	~y = \{ \cf3 arg\cf0  freq=500; \cf3 SinOsc\cf0 .ar(freq * [1, 1.1]) * 0.1 \};
\f3\fs24 \
	\
now the argument 'freq' is a control in the synth (just like in SynthDef) which you can change by the '
\f0\b set
\f3\b0 ' message.\
\

\f2\fs18 	~y.set(\cf4 \\freq\cf0 , 440);\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs24 \cf0 	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 	\cf2 // unlike in synths, this context is kept and applied to every new synth:\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 	~y = \{ \cf3 arg\cf0  freq=500; \cf3 Formant\cf0 .ar(50, freq * [1, 1.1], 70) * 0.1 \};\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 xset
\f3\b0  is a variant of set, to crossfade the change using the current fadeTime:\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 	~y.fadeTime = 3;\
	~y.xset(\cf4 \\freq\cf0 , 600);
\f3\fs24 \
	\

\f2\fs18 	\cf2 // the same context is applied to all slots:\cf0 \
\
	~y[2] = \{ \cf3 arg\cf0  freq=500; \cf3 SinOsc\cf0 .ar(freq * [1, 1.1]) * LFPulse.kr(Rand(1, 3)) * 0.1 \};\
	~y.xset(\cf4 \\freq\cf0 , 300);\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs24 \cf0 \
	\
the parameter context also can keep bus mappings. a control can be mapped to any 
\f4\i control proxy
\f3\i0 :\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 	~c = \{ \cf3 MouseX\cf0 .kr(300, 800, 1) \};\
	~y.map(\cf4 \\freq\cf0 , ~c);
\f3\fs24 \
	\

\f2\fs18 	\cf2 // also here the context is kept:\cf0 \
\
	~y = \{ \cf3 arg\cf0  freq=500; \cf3 Formant\cf0 .ar(4, freq * [1, 1.1], 70) * 0.1 \};\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 \
\
xmap 
\f3\b0 is a variant of map, to crossfade the change using the current fadeTime:\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 	\
	~y.set(\cf4 \\freq\cf0 , 440);\
	~y.xmap(\cf4 \\freq\cf0 , ~c);\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs24 \cf0 \
\
to remove a setting or a mapping, use 
\f0\b unmap / unset
\f3\b0 . \
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 	~y.unmap;\
	\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs24 \cf0 	\
a multichannel control can be mapped to a multichannel proxy using 
\f0\b mapn
\f3\b0 :\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 	~c2 =  \{ [\cf3 MouseX\cf0 .kr(300, 800, 1), \cf3 MouseY\cf0 .kr(300, 800, 1)] \};\
	~y = \{ \cf3 arg\cf0  freq=#[440, 550]; \cf3 SinOsc\cf0 .ar(freq) * \cf3 SinOsc\cf0 .ar(freq + 3) * 0.05 \};\
	~y.mapn(\cf4 \\freq\cf0 , ~c2);
\f3\fs24 \
\
\
the parameter context can be examined:\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs18 \cf0 	~y.nodeMap;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs18 \cf2 	// apart from the parameters explicitly set, \
	// it contains the bus index and the fadeTime\
	\
	// for more information, see [\cf2 \ul \ulc2 NodeMap\ulnone ]\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs18 \cf0 p.clear(8); \cf2 // clear the whole proxy space, in 8 secs.\cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\b0 \cf0 previous: [\ul jitlib_basic_concepts_02\ulnone ] 	next: [\ul jitlib_basic_concepts_04\ulnone ] 
\f0\b \
\
}