{\rtf1\mac\ansicpg10000\cocoartf824\cocoasubrtf230
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fnil\fcharset77 Georgia-Bold;\f2\fnil\fcharset77 Monaco;
\f3\fswiss\fcharset77 Helvetica;}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green115\blue0;\red191\green0\blue0;
\red0\green0\blue0;\red0\green0\blue191;\red0\green0\blue191;\red96\green96\blue96;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs30 \cf0 proxy space - basic concepts  		
\f1\fs72 2
\f2\b0\fs18 \
\
\

\f3\fs24 external structure of the node proxy, referencing in proxyspace and environments.\
\
previous: [\ul jitlib_basic_concepts_01\ulnone ]		next: [\ul jitlib_basic_concepts_03\ulnone ] \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs24 \cf0 a) 	normal environment lookup\
b) 	proxyspace as an environment\
c) 	using the proxyspace to change processes on the fly\
d) 	when are the node proxies initialized?\
e) 	moving out of the proxy space\
f ) 	using ProxySpace together with other Environments
\f2\fs18 \
\
\
\
\
\

\f0\b\fs24 a) normal environment lookup
\f2\b0\fs18 \
\
\
\
currentEnvironment.postln; \cf2 // anEnvironment (if not, you haven't left it from last helppage..)\cf0 \
\
~a; \cf2 // access the environment: there is nothing stored: nil\cf0 \
~a = 9; \cf2 // store something\cf0 \
~a; 	\cf2 // now 9 is stored\cf0 \
~a + 100; \cf2 // calculate with it\cf0 \
\
currentEnvironment.postln; \cf2 // the value is stored in the environment\cf0 \
\
~b + ~a; \cf2 // cause an error: ~y is nil.\cf0 \
~b = -90; \cf2 // set ~y\cf0 \
\
~b + ~a; \cf2 // this works.\cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // note that you can always access environments (or ProxySpaces) from outside as well:\cf0 \
\
x = currentEnvironment;\
x[\cf3 \\a\cf0 ] + x[\cf3 \\b\cf0 ] \cf2 // equivalent to ~b + ~a\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 // or, if "know" is true,\cf5 \
x.know = \cf6 true\cf5 ;\
x.a + x.b;\
\
\cf0 \
\
\
\
	further readings: [\ul Environment\ulnone ]\
\
\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 b) proxyspace as an environment
\f2\b0\fs18 \
\
\

\f3\fs24 one can replace the current environment with a special type of environment, a proxy space\
this environment represents processes that play audio on a server.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \
\
p = \cf7 ProxySpace\cf0 .new(s); \cf2 // create a new environment, store it in variable p for now.\cf0 \
p.push;				\cf2 // push it, so i becomes the current environment.\cf0 \
currentEnvironment.postln; \
currentEnvironment === p; \cf2 // this is identical.\cf0 \
\
~x;		 \cf2 // accessing creates a NodeProxy (uninitialized) automatically.\cf0 \
~x + ~y; 	\cf2 // this works immediately, because the lookup does not return nil, \cf0 \
	    \cf2 // but a placeholder (proxy) instead\cf0 \
\
p.postln; \cf2 // now there is two placeholders in the environment.\cf0 \
\
\
\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 c) using the proxyspace to change processes on the fly
\f2\b0\fs18 \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 //  boot the server\cf0 \
s.boot;\
\
\
\cf2 // as soon as a sound function (or any compatible input) is assigned to a proxy\cf0 \
\cf2 // this sound plays on its own private bus (so it is not audible yet.)\cf0 \
(\
~x = \{\
	\
	\cf7 RLPF\cf0 .ar(\cf7 Impulse\cf0 .ar(4) * 20, [850, 950], 0.2)\
	\
\}\
)\
\
\cf2 // the proxy has been initialized by its first assignment.\cf0 \
\cf2 // it plays at audio rate (because we have assigned an audio rate ugen function)\cf0 \
\cf2 // and it has two channels (because the function has stereo output)\cf0 \
\
~x.index; \cf2 // what bus index is it? this posts the index to the postwindow \
		// before it was .ir(nil), now it is initialized to .ar(2)\cf0 \
~x.bus \cf2 // what bus is it?\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
\
~x.play; \cf2 // now listen to it. a monitor is created (see [\cf2 \ul \ulc2 Monitor\ulnone ]) that plays \
		// the signal onto a public bus. This is independent of the proxy itself.\
		// for further info see: [\ul jitlib_basic_concepts_03\ulnone ] (part c)\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // the sound function can be changed at any time:\cf0 \
(\
~x = \{\
		\cf7 RLPF\cf0 .ar(\cf7 Impulse\cf0 .ar([5, 7]) * 5, [1450, 1234], 0.2)\
\}\
)\
\
\cf2 // You can tune a sound function to your liking very easily\cf0 \
\cf2 // by replacing it with little (or big) variations:\cf0 \
\
		\cf2 // filter freqs higher:\cf0 \
~x = \{	\cf7 RLPF\cf0 .ar(\cf7 Impulse\cf0 .ar([5, 7]) * 5, [1800, 2000], 0.2) \}\
		\
		\cf2 // same pulse ratio (5/8), different pulse tempo:\cf0 \
~x = \{	\cf7 RLPF\cf0 .ar(\cf7 Impulse\cf0 .ar([5, 8] * 3.2) * 5, [1800, 2000], 0.2) \}\
\
		\cf2 // different filter:\cf0 \
~x = \{	\cf7 Ringz\cf0 .ar(\cf7 Impulse\cf0 .ar([5, 8] * 3.2), [1800, 2000], 0.05) \}\
\
\cf2 // and if you set the proxy's fadeTime, you can create little \cf0 \
\cf2 // textures by hand: \cf0 \
\
~x.fadeTime = 3; \
		\cf2 // different filter freqs every time:\cf0 \
~x = \{	\cf7 Ringz\cf0 .ar(\cf7 Impulse\cf0 .ar([5, 8] * rrand(0.5, 1.5)) * 0.5, (\{ exprand(200, 4000) \} ! 2), 0.05) \}\
\
\
\
\cf2 // here is another proxy:\cf0 \
~y = \{ \cf7 Pan2\cf0 .ar(\cf7 Dust\cf0 .ar(20), 0) \};\
\
~y.bus; \cf2 // it has two channels, just as the ~x., but it plays on another (private) bus.\cf0 \
\
\cf2 // note that ~y is not audible directly,\
// but it can be used in any other proxy:\cf0 \
(\
~x = \{\
	\
	\cf7 RLPF\cf0 .ar(~y.ar * 8,  [1450, 1234], 0.2)\
\}\
)\
\
\cf2 // when the proxy changes, the result changes dynamically:\cf0 \
\
~y = \{\'ca\cf7 Impulse\cf0 .ar(\cf7 MouseX\cf0 .kr(2, 18, 1)) * [1, 1] \};\
\
~y = \{\'ca\cf7 PinkNoise\cf0 .ar(\cf7 MouseX\cf0 .kr(0, 0.2) * [1, 1]) \};\
\
~y = \{\'ca\cf7 Impulse\cf0 .ar([\cf7 MouseX\cf0 .kr(2, 18, 1), \cf7 MouseY\cf0 .kr(2, 18, 1)]) \};\
\
\
\
\cf2 // stop listening. the proxies run in the background.\cf0 \
\
~x.stop;\
\
~y.bus; \cf2 // ~y is playing on another bus.\cf0 \
~x.bus; \cf2 // than ~x\cf0 \
\
\cf2 // we can also listen to ~y directly:\cf0 \
~y.play;\
\
\cf2 // to remove an input, nil can be used:\cf0 \
\
~y = \cf7 nil\cf0 ;\
\
\cf2 // stop listening\cf0 \
~y.stop;\
\
\
	
\f3\fs24 further readings: [\ul proxyspace_examples\ulnone ] [\ul Bus\ulnone ] [\ul AbstractFunction\ulnone ] [\ul UGens\ulnone ]
\f2\fs18 \
\
\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 d) when are the node proxies initialized?
\f2\b0\fs18 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs24 \cf0 bus initialization of a node proxy happens as soon as it is used for the first time.\
later inputs are adjusted to this bus, as far as it is possible.
\f2\fs18 \
\
\
~z2 = \{ \cf7 LFNoise0\cf0 .kr([1, 2, 3, 4]) \}; \cf2 // a four channel control rate proxy\cf0 \
~z2.bus.postln;\
\
~z100 = 0.5; \cf2 // a constant value causes a single channel control rate proxy.\cf0 \
~z100.bus.postln;\
\
~z34.ar(3) 		\cf2 // the first access allocates the bus\cf0 \
~z34.bus.postln;	 \cf2 // a 3 channel audio proxy\cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // these initializations can be removed by using clear:\cf0 \
~z34.clear;\
~z34.bus.postln;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs24 \cf0 This initialisation happens whenever the proxy is first used. Later, the proxy can\
be accessed with other rate/numChannels combinations as needed (rates are converted,\
numChannels are extended by wrapping).\
\
Note that this might cause ambiguous initialisation in which case the proxy should\
be always initialized first. A typical problem is demonstrated here:
\f2\fs18 \
\
~u.play(0, 2); 	\cf2 // initialize 2 audio channels (default). 0 is the output bus number.\
				// if the proxy is not inititialized, play defaults to 2 channels.\
				// here it is explicitly given only to make it more clear.\cf0 \
~u = \{ \cf7 PinkNoise\cf0 .ar(0.2) \}; \cf2 // use only one\cf0 \
~u.numChannels; \cf2 // 2 channels\cf0 \
~u.clear;\
\

\f3\fs24 if evaluated the other way round, only one channel is used:
\f2\fs18 \
\
~u = \{ \cf7 PinkNoise\cf0 .ar(0.2) \}; \cf2 // initialize 1 audio channel\cf0 \
~u.play(0, 2); 	\cf2 // play 2 channels: the 1 channel is expanded into 2.\
				// numChannels of .play defaults to the proxy's numChannels.\
				// here it is explicitly given, so to expand the channels\cf0 \
~u.numChannels; \cf2 // 1 channel\cf0 \
~u.clear;\cf2 \
\

\f3\fs24 \cf0 Thus it can be useful to explicitly initialize proxies that use variable type inputs:
\f2\fs18 \cf2 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 ~b.kr(8); ~c.ar; \cf2 // explicit initialisation\cf0 \
p.postln;		\cf2 // post the whole proxy space\cf0 \
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 e) moving out of the proxy space:
\f2\b0\fs18 \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // play the audio:\cf0 \
~x.play;\
\
~x = \{ \cf7 PinkNoise\cf0 .ar(0.5) \};\
\
\cf2 // p is the proxy space:\cf0 \
p.postln;\
\
\cf2 // to end all processes in p, use end:\cf0 \
p.end(2) \cf2 // 2 seconds fade out.\cf0 \
\
\cf2 // to remove all bus objects and free them from the bus allocato, use clear:\cf0 \
p.clear;\
\
currentEnvironment.postln;\
\
\cf2 // restore original environment:\cf0 \
\
p.pop;\
\
currentEnvironment.postln;\
\
~a + ~b; \cf2 // the old values are still here.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 p === currentEnvironment; \cf2 // this is not the case anymore.\cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // remove the content, so the garbage collector can release their memory.\cf0 \
p.clear;\
\
\cf2 // note that if you use this kind of accessing scheme, the objects are not garbage collected\cf0 \
\cf2 // until the keys are set to nil. This is a common mistake when using normal environments.\cf0 \
\
\cf2 // clear all in the normal environment:\cf0 \
\
currentEnvironment.clear;\
\
\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 f) using ProxySpace together with other Environments
\f3\b0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs24 \cf0 using proxy space as an access scheme for node proxies can get in the way of the\
normal use of environments as pseudo variables. Here is some ways to cope with this.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf2 \
// if you want to keep using the current environment as usual, you can restrict the\cf0 \
\cf2 // scope of proxyspace to one document (note: this is mac-only currently)\cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf7 EnvirDocument\cf0 (p, \cf8 "proxyspace"\cf0 ); 	\cf2 // to test this, check for currentEnvironment here \cf0 \
							\cf2 // and in the envir document.\cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // you can also access the proxy space indirectly:\cf0 \
p[\cf3 \\x\cf0 ].play;\
p[\cf3 \\x\cf0 ] = \{ \cf7 SinOsc\cf0 .ar(450, 0, 0.1) \};\
\
\cf2 // or: when the proxyspace is pushed, you can use a normal environment indirectly:\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 p.push;\
d = ();\
d[\cf3 \\buffer1\cf0 ] = \cf7 Buffer\cf0 .alloc(s, 1024);\
d.use \{ ~buffer1.postln; ~zz = 81; \}; \cf2 // for more than one access to the environment, use use\cf0 \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // to access the inner environment of proxy space directly, \
// without creating new proxies, use .envir:\cf0 \
\
p.envir.postln;\
p.envir[\cf3 \\x\cf0 ].postln;\
\
\cf2 // this can be useful for lookup, when you want to know if a certain proxy exists already.\cf0 \
\cf2 // direct access would create that proxy, which would not make sense in that case.\cf0 \
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs24 \cf0 previous: [\ul jitlib_basic_concepts_01\ulnone ]		next: [\ul jitlib_basic_concepts_03\ulnone ] 
\f2\fs18 \
\
}