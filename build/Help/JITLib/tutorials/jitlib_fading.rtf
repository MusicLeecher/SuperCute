{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red191\green0\blue0;\red0\green0\blue0;
\red0\green0\blue191;\red96\green96\blue96;\red0\green115\blue0;\red191\green0\blue0;\red0\green115\blue0;
\red96\green96\blue96;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs26 \cf0 \
Fade envelope generation and crossfading
\f1\b0\fs24 \
\
\
NodeProxy (ProxySynthDef) looks for inner envelopes in your definition function\
to find out whether 
\f0\b a fade envelope is needed or not
\f1\b0 . In case there is no other inner\
possibility of freeing the synth, either \
\
a) 	a fade envelope is created (audio / control rate output)\
\
b) 	the synth is freed directly with no fading (scalar output or doneAction 1)\
\
c) 	if you provide a gate arg and a doneAction 2 to your ugenGraph function, this is supposed\
	to be a fade envelope for the synth\
\
d) 	if a synthdef name is used, case c) is supposed\
\
... so in most cases, there is not much to worry about, just these two points ar important,\
if one wants to use a self releasing synth or a different out ugen:\
\
e) 	own responsibility:\
	if the function creates a ugengraph that can be freed by trigger or other things, it \
	waits for this action instead of the node proxy freeing the synth. \
\
f) 	own out channel with 'out' arg: the control ugen with the name 'out' is set to the output channel\
	number of the proxy.
\f2\fs18 \
\
p = \cf2 ProxySpace\cf0 .push(s.boot);\
\
~out.play;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 // note that you can use this functionality also when using ProxySynthDef directly:\
\cf4 \
d = \cf5 ProxySynthDef\cf4 (\cf6 "test"\cf4 , \{ \cf5 arg\cf4  freq=440; \cf5 SinOsc\cf4 .ar(freq) \}).send(s);\
s.sendMsg(\cf6 "/s_new"\cf4 , \cf6 "test"\cf4 , 1980, 1, 1, \cf7 \\freq\cf4 , 340);\
s.sendMsg(\cf6 "/n_set"\cf4 , 1980, \cf7 \\freq\cf4 , 240);\
s.sendMsg(\cf6 "/n_set"\cf4 , 1980, \cf7 \\fadeTime\cf4 , 4);\
s.sendMsg(\cf6 "/n_set"\cf4 , 1980, \cf7 \\gate\cf4 , 0);\
\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs26 \cf0 a) automatic fade envelope generation
\f2\b0\fs18 \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf8 // no inner envelope and audio / control rate output\cf0 \
(\
~out = \{ \cf2 PinkNoise\cf0 .ar([1,1]*0.1) \};\
)\
\
(\
~kout = \{ \cf2 PinkNoise\cf0 .kr([1,1]*0.1) \};\
)\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs26 \cf0 b) automatic free instead of crossfade\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs18 \cf0 \
\cf8 // inner envelope that cannot free the synth, the synth is freed when a new \cf0 \
\cf8 // function is assigned.\cf0 \
(\
~out = \{ \cf2 arg\cf0  t_trig; \cf2 EnvGen\cf0 .kr(\cf2 Env\cf0 .asr, t_trig) * \cf2 PinkNoise\cf0 .ar([1,1]) \};\
)\
~out.group.set(\cf9 \\t_trig\cf0 , 1);\
\
(\
~out = \{ \cf2 arg\cf0  t_trig; \cf2 EnvGen\cf0 .kr(\cf2 Env\cf0 .asr, t_trig) * \cf2 SinOsc\cf0 .ar([1,1]*400) \};\
)\
~out.group.set(\cf9 \\t_trig\cf0 , 1);\
\
\
\cf8 // for a scalar output also no fade env is created, but the synth is freed (without fading)\cf0 \
(\
~out = \{ \cf2 Out\cf0 .ar(0, \cf2 SinOsc\cf0 .ar(\cf2 Rand\cf0 (440,550),0,0.2)) \};\
)\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs26 \cf0 c) custom fade envelope
\f2\b0\fs18 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf8 // when a gate arg is provided, and the env can free the synth, this envelope\cf0 \
\cf8 // is supposed to be the fade envelope for the synth: no extra fade env is created.\cf0 \
(\
~out = \{ \cf2 arg\cf0  gate=1; \cf2 EnvGen\cf0 .kr(\cf2 Env\cf0 .asr, gate, doneAction:2) * 0.2 * \cf2 SinOsc\cf0 .ar([1,1]*\cf2 Rand\cf0 (440,550)) \};\
)\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs26 \cf0 d) SynthDef name assignment
\f2\b0\fs18 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf8 // if a symbol is used as input, the defname of a def on the server is supposed\cf0 \
\cf8 // to represent a SynthDef that has a gate, an out input and can free itself.\cf0 \
(\
~out = \cf9 \\default\cf0 ;\
)\
\
\cf8 // this is the minimal requirement arguments for such a use (similar to Pbind)\cf0 \
(\
\cf2 SynthDef\cf0 (\cf10 "test"\cf0 , \{ \cf2 arg\cf0  gate=1, out;\
	\cf2 Out\cf0 .ar(out, \cf2 Formant\cf0 .ar(300, 200, 10) * \cf2 EnvGen\cf0 .kr(\cf2 Env\cf0 .asr, gate, doneAction:2))\
\}).send(s);\
)\
\
\cf8 // you can also provide a fadeTime arg, whic is set by the proxy:\cf0 \
(\
\cf2 SynthDef\cf0 (\cf10 "test"\cf0 , \{ \cf2 arg\cf0  gate=1, out, fadeTime=1;\
	\cf2 Out\cf0 .ar(out, \
		\cf2 Formant\cf0 .ar(Rand(20,40), 600, 10, 0.2) \
		* \cf2 EnvGen\cf0 .kr(\cf2 Env\cf0 .asr(fadeTime,1,fadeTime), gate, doneAction:2)\
	)\
\}).send(s);\
)\
\
~out = \\test;\
~out.fadeTime = 3;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 note that the 
\f0\b number of channels
\f1\b0  is your own responsibility when using symbols, \
as a symbol carries no channel information!\
(in all other cases the number of channels is wrapped or expanded to fit the proxy)
\f2\fs18 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf8 // if the synthdef has a fixed duration envelope, there is a FAILURE /n_set Node not found message.\cf0 \
\cf8 // with no further significance\cf0 \
(\cf2 \
Sy\cf0 n\cf2 thDef\cf0 (\cf10 "test"\cf0 , \{ \cf2 arg\cf0  gate=1, out;\
	\cf2 Out\cf0 .ar(out, \
		\cf2 Formant\cf0 .ar(\cf2 Rand\cf0 (20,40), 600, 10, 0.6) \
		* \cf2 EnvGen\cf0 .kr(\cf2 Env\cf0 .perc, gate, doneAction:2)\
	)\
\}).send(s);\
)\
\
~out = \\test;\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs26 \cf0 e) own free responsibility
\f2\b0\fs18 \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf8 //inner envelope that can free the synth, no extra fade env is created:\cf0 \
(\
~out = \{ \cf2 arg\cf0  t_trig; \cf2 EnvGen\cf0 .kr(\cf2 Env\cf0 .asr, t_trig, doneAction:2) * \cf2 PinkNoise\cf0 .ar([1,1]) \};\
)\
~out.group.set(\cf9 \\t_trig\cf0 , 1); \cf8 //end it\cf0 \
\
~out.send; \cf8 //start a new synth\cf0 \
~out.group.set(\cf9 \\t_trig\cf0 , 1); \cf8 //end it again\cf0 \
\
\
\cf8 // if there is a ugen that can free the synth, no extra fade env is created either,\cf0 \
\cf8 // but it supposes the synth frees itself, so if a new function is assigned it does\cf0 \
\cf8 // not get freed.\cf0 \
(\
~out = \{  \cf2 arg t_trig\cf0 ;\
	\cf2 FreeSelf\cf0 .kr(\cf2 t_trig\cf0 );\
	\cf2 PinkNoise\cf0 .ar([1,1]*0.3);\
\};\
)\
~out.group.set(\cf9 \\t_trig\cf0 , 1);\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs26 \cf0 f) own output responsibility
\f2\b0\fs18 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf8 // the arg name 'out' can be used to output through the right channel.\cf0 \
\cf8 // of course with this one can get problems due to a wrong number of channels\cf0 \
\cf8 // or deliberate hacks.\cf0 \
\
\cf8 //left speaker\cf0 \
(\
~out = \{ \cf2 arg\cf0  out;\
	\cf2 OffsetOut\cf0 .ar(out, \cf2 Impulse\cf0 .ar(10,0,0.1))\
\}\
)\
\
\cf8 //both speakers\cf0 \
(\
~out = \{ \cf2 arg\cf0  out;\
	\cf2 OffsetOut\cf0 .ar(out, \cf2 Impulse\cf0 .ar([10, 10],0,0.1))\
\}\
)\
\
\cf8 //this plays out into another adjacent bus: this is a possible source of confusion. \cf0 \
(\
~out = \{ \cf2 arg\cf0  out;\
	\cf2 OffsetOut\cf0 .ar(out, \cf2 Impulse\cf0 .ar([10, 10, 10],0,0.1))\
\}\
)\
\
\
\
\
\
\
}