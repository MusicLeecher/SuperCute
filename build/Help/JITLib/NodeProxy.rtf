{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fnil\fcharset77 Monaco;\f2\fswiss\fcharset77 Helvetica;
}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue191;\red0\green115\blue0;
\red96\green96\blue96;\red0\green0\blue0;\red191\green0\blue0;\red0\green0\blue191;\red0\green115\blue0;
}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 NodeProxy\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs18 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs26 \cf0 superclass: AbstractFunction\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs18 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs26 \cf0 Generally a proxy is a placeholder for something, which in this case \
is something playing on a server that writes to a limited number of busses.\
(this can be for example a synth or an event stream)\
\
These objects  can be replaced, mapped and patched and used for calculation. \
See ProxySpace for more examples.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs26 \cf0 \
	
\f0\b NodeProxy.new(server)\
	NodeProxy.audio(server, numChannels)\
	NodeProxy.control(server, numChannels)\
\
___________________________________________________\
\
	source_(anObject)\
		
\f2\b0 play a new synth through me, release old one.\
		anObject can be a Function, an Instr, any valid UGen input\
		a pattern can be used if it returns an EventStream.\
			[only if the used synthdef (in the pattern) has the right number of channels\
			and an out argument, this can be used to do filtering].\
		
\f0\b \
	add(anObject, channelOffset)\
		
\f2\b0 play a new synth, add it to the present ones\
		anObject can be a Function, an Instr, any valid UGen input
\f0\b \
	\
	\
	set(key, val, ...)\
		
\f2\b0 I behave like my nodeMap: see [NodeMap]\
		set, setn, unset, unmap\
		\
	
\f0\b map(keys, proxy)
\f2\b0 \
		map the arguments in keys to the subsequent channels of a control proxy\
		(keys can be a symbol, a number, or an array)\
		\
	
\f0\b run(flag)
\f2\b0 \
		pause/unpause all synths in the group
\f0\b \
	\
	play(index, numChannels)\
		
\f2\b0 play output on specified bus index (default: public busses)
\f0\b \
	\
	ar(numChannels)\
	kr(numChannels)\
	\
		
\f2\b0 return a link to my output, which is limited by [NumChannels]\
	\
	_____________________
\f0\b \
	\
	\
	send(argList)\
		
\f2\b0 send a new synth without releasing the old one.\
		the argument list is applied to the synth only.
\f0\b \
	\
	put(anObject, channelOffset, sendFlag, freeAllFlag, completionFunc, latency)\
		
\f2\b0 set the source:\
			channelOffset: 	using a multichannel setup it can be useful to set this.\
							when the objects numChannels is smaller than the proxy \
			sendFlag: 	send it or not -  default:false\
			freeAllFlag: 	replace current synth or not - default:true\
						if false, add the new synthDef to the present ones\
			completionFunc: is evaluated as soon as synth is running\
			latency: 		nil: wait for '/done' message (doesn't work when sending several at once)\
						a number is the time to wait for the loading.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 	\
	free\
		
\f2\b0 free all my running synths and the group
\f0\b \
	\
	release\
		
\f2\b0 fade out my running synths\
	\
	
\f0\b clear\
		
\f2\b0 reset everything to nil
\f0\b \
	\
	\
	\
	record(path, headerFormat, sampleFormat)\
		
\f2\b0 record output to file (returns a RecNodeProxy that you can use for stopping)\
		
\f0\b \
	fadeTime_(time)\
		
\f2\b0 set the attack/release time\
	\
	
\f0\b clock_(aClock)
\f2\b0 \
		use a clock for scheduling beat accurate\
	\
	
\f0\b freeSelf_(true/false)
\f2\b0 \
		switch it to false if a nodeproxy should be used to spawn\
		single synths that have their own envelope (see ProxySpace example)\
_________________________________________________________	\
		
\f1\fs18 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 //examples\
\cf0 s = Server.local;\
s.boot;\
\
a = \cf3 NodeProxy.audio\cf0 (s, 2);\
\
x = a.play; \cf2 //play to hardware output, return a group with synths\
\cf0 a.source = \{ \cf3 SinOsc\cf0 .ar([350, 390], 0, 0.1) \};\
a.source = \{ \cf3 SinOsc\cf0 .ar([390, 290]*1.5, 0, 0.1) \};\
a.source = \{ \cf3 WhiteNoise\cf0 .ar([0.01,0.01]) \};\
a.source = 0;\
\
\
\cf2 //feedback\
\cf0 a.source = \{ \cf3 SinOsc\cf0 .ar(a.ar*7000*\cf3 LFNoise1\cf0 .kr(1, 1, 1) + 200, 0, 0.1) \};\
\
\cf2 //adding nodes\
\cf0 a.add(\{ \cf3 SinOsc\cf0 .ar([350, 390]*1.25, 0, 0.1) \});\
a.add(\{ \cf3 BrownNoise\cf0 .ar([0.1,0.1]) \});\
\
\
a.fadeTime = 2.0;\
a.lags = [0.5]; //for now the lags can be set like this\
a.source = \{ \cf3 arg\cf0  f=400; \cf3 SinOsc\cf0 .ar(f*[1,1.2]*rrand(0.9, 1.1), 0, 0.1) \};\
a.set(\cf4 \\f\cf0 , rrand(1500,700));\
a.source = \{ \cf3 arg\cf0  f=400; \cf3 LPF\cf0 .ar(\cf3 Pulse\cf0 .ar(f*[1,1.2], 0.5, 0.1), f*2) \};\
\
\
\cf2 //mapping to busses\
\cf0 c = \cf3 NodeProxy.control\cf0 (s,2);\
c.source = \{ \cf3 SinOsc\cf0 .kr([10,20], 0, 100, 300) \};\
a.map(\cf4 \\f\cf0 , c);\
a.source = \{ \cf3 arg\cf0  f=400; \cf3 LPF\cf0 .ar(\cf3 Pulse\cf0 .ar(f*[0.4,1], 0.2, 0.1), f*3) \};\
c.source = \{ \cf3 Line\cf0 .kr(300, 500, 10) + \cf3 SinOsc\cf0 .kr(20*[1,2], 0, 10) \};\
\
\cf2 //map to multiple channels\
\cf0 a.source = \{ \cf3 arg\cf0  f=400, f2=400; \cf3 LPF\cf0 .ar(\cf3 Pulse\cf0 .ar(f*[0.4,1], 0.2, 0.1), f2) \};\
a.map([\cf4 \\f\cf0 ,\cf4 \\f2\cf0 ], c); //same as a.map([\cf4 0\cf0 ,\cf4 1\cf0 ], c); \
c.source = \{ \cf3 SinOsc\cf0 .kr([2.3,1], 0, [100, 700], [300, 700]) \};\
a.source = \{ \cf3 arg\cf0  f=400, f2=400; \cf3 LPF\cf0 .ar(\cf3 Pulse\cf0 .ar([f,f2], 0.2, 0.1), f2) \};\
c.source = \{ \cf3 LFNoise0\cf0 .kr([2.3,1], [100, 700], [300, 1700]) \};\
\cf2 \
//behave like a sc2 plug\
\cf0 c.gate(1400, 0.1);\
c.gate(1000, 0.1);\
c.line(1000, 1);\cf2 \
\
//stop synthesis, then wake up proxies:\
\cf0 \
x = a.play;\
a.release;\
a.free;\
x.free;\
c.free;\
\
 \
 \
\cf2 //beat accurate playing\
\cf0 a.clock = \cf3 QuantClock\cf0 (2.0); \cf2 //round to every 2.0 seconds\
\cf0 a.source = \{ \cf3 Ringz\cf0 .ar(\cf3 Impulse\cf0 .ar(0.5, 0, 0.3), 3000, 0.01) \};\
a.add(\{ \cf3 Ringz\cf0 .ar(\cf3 Impulse\cf0 .ar([0.5, 1], 0, 0.3), 1000, 0.01) \});\
a.add(\{ \cf3 Ringz\cf0 .ar(\cf3 Impulse\cf0 .ar([3, 5]/2, 0, 0.3), 8000, 0.01) \});\
\
\
\
\
\
\cf2 //using patterns - event streams (doesn't work yet)\
\cf0 \
\cf3 SynthDef\cf0 (\cf5 "par"\cf0 , \{ \cf3 arg\cf0  freq, out=0, sustain=0.1; \cf2 //must have 'outIndex' argument to work properly\
\cf0 	\cf3 Out\cf0 .ar(out, Pan2.ar(\cf3 LFCub\cf0 .ar(freq,0,\cf3 Line\cf0 .kr(0.1,0,sustain, doneAction:2)), Rand(-1.0,1.0)))\
\}).load(s);\
\
a = \cf3 NodeProxy.audio\cf0 (s, 2);\
a.fadeTime = 2;\
a.play;\
b = \cf3 NodeProxy\cf0 .audio(s,2);\
b.source = \cf3 Pbind\cf0 (\cf4 \\instrument\cf0 , \cf4 \\par\cf0 , \cf4 \\freq\cf0 , 600, \\player, \cf3 NoteDurPlayer.new\cf0 );\
\cf6 \
\cf7 //play b out through a:\cf6 \
a.source = b;\
\
\cf7 //filter b with ring modulation:\cf6 \
a.source = \{  b.ar * \cf8 SinOsc\cf6 .ar(\cf8 SinOsc\cf6 .kr(0.2, 300, 330))  \}; \cf7 //filter the input of the pattern\cf6 \
a.source = b;\
\
\cf7 //map b to another proxy\cf6 \
c = \cf8 NodeProxy\cf6 .control(s,1);\
c.source = \{ \cf8 SinOsc\cf6 .kr(2, 0, 400, 700) \};\
b.map(\cf9 \\freq\cf6 , c);\
c.source = \{ \cf8 SinOsc\cf6 .kr(\cf8 SinOsc\cf6 .kr(0.2, 0, 10, 10), 0, 400, 700) \};\
\
\cf0 \
(\
b.source = \cf3 Pbind\cf0 (\
\cf4 			\\instrument\cf0 , \cf4 \\par\cf0 , \
			\cf4 \\freq\cf0 , Pseq([600, 400],inf), \
			\cf4 \\doneAction\cf0 , 2, \
			\cf4 \\dur\cf0 , 0.4,  \
			\\player, \cf3 NoteDurPlayer.new\
		\cf0 );\
)\
\
\cf7 //remove the mapping\cf6 \
b.unmap(\cf9 \\freq\cf6 );\cf0 \
\
b.add(\cf3 Pbind\cf0 (\cf4 \\instrument\cf0 , \cf4 \\par\cf0 , \cf4 \\freq\cf0 , 620, \\player, \cf3 NoteDurPlayer.new\cf0 ));\
b.add(\cf3 Pbind\cf0 (\cf4 \\instrument\cf0 , \cf4 \\par\cf0 , \cf4 \\freq\cf0 , Pseq([700, 400],inf), \\player, \cf3 NoteDurPlayer.new\cf0 ));\
\
\
a.source = \{  b.ar * \cf3 WhiteNoise.ar(0.1, 1)\cf0   \}; \
a.source = \{  b.ar * \cf3 WhiteNoise.ar(0.1, 1) + (b.ar * SinOsc\cf0 .ar(\cf3 SinOsc\cf0 .kr(0.01, 0, 50, 330)))  \}; \
\
\
b.source = \{ Pan2.ar(\cf3 SinOsc\cf0 .ar(600,0,0.1), LFNoise1.kr(1)) \};\cf3 \
\cf0 b.source = \cf3 Pbind\cf0 (\cf4 \\instrument\cf0 , \cf4 \\par\cf0 , \cf4 \\freq\cf0 , 600, \\player, \cf3 NoteDurPlayer.new\cf0 );\cf3 \
\
\
\
\
\
\
\
\
_\cf0 _\cf3 __\cf0 _\cf3 ___\cf0 __\cf3 __\cf0 _____\cf3 ___\cf0 __\cf3 __\cf0 ___\cf3 _\cf0 _\
\
presently, NodeProxy can be used implicitly using the following shortcut:\
\
\
\{ \cf3 SinOsc\cf0 .ar([350, 390], 0, 0.1) \}.play(\cf4 \\out\cf0 ); \cf2 //play the function on a private bus\
\cf4 \\out\cf0 .play;	\cf2 //play it out the hardware bus\
\cf0 \
\{ \cf3 SinOsc\cf0 .ar([350, 390]+20, 0, 0.1) \}.play(\cf4 \\out\cf0 ); \cf2 //replace the synth playing in \\out\
\cf0 \
}