{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fnil\fcharset77 Monaco;\f2\fswiss\fcharset77 Helvetica;
}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue191;\red0\green115\blue0;
\red0\green0\blue0;\red191\green0\blue0;\red96\green96\blue96;\red0\green0\blue191;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 NodeProxy\

\f1\b0\fs18 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs26 \cf0 superclass: AbstractFunction\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs18 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 Generally a proxy is a placeholder for something, which in this case \
is something playing on a server that writes to a limited number of busses.\
(this can be for example a synth or an event stream)\
\
These objects  can be replaced, mapped and patched and used for calculation. \
See ProxySpace for more examples.\
\
note that NodeProxy plays on a \ul private\ulnone  bus. if you want to hear the output,\
use p.
\f0\b play
\f2\b0  and p.
\f0\b stop
\f1\b0\fs16 \
\

\f2\fs24 \
	
\f0\b NodeProxy.new(server)\
	NodeProxy.audio(server, numChannels)\
	NodeProxy.control(server, numChannels)\
\
___________________________________________________\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \ul reading from the outbus\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \ulnone \
	play(index, numChannels)\
		
\f2\b0 play output on specified bus index (default: public busses)\
		this works like a monitor.
\f0\b \
	stop\
		
\f2\b0 stop to play out public channels (private channels keep playing)\
		this stop the monitoring\
		
\f0\b \
	ar(numChannels)\
	kr(numChannels)\
	\
		
\f2\b0 return a link to my output, which is limited by [numChannels]\
		causes an uninitialized proxy to create a matching bus.\
		presently ar defaults to stereo, kr to mono.\
	
\f0\b \ul \
setting the source:\
\ulnone \
	source_(anObject)\
		
\f2\b0 play a new synth through me, release old one.\
		anObject can be a Function, a SynthDef, an Instr, any valid UGen input\
		a pattern can be used if it returns an EventStream.\
			[only if the used synthdef (applies also to patterns) has the right number of channels\
			and an out argument, this can be used to do filtering. \
			if you supply a gate, the nodeProxy will assume doneAction 2 and fade out].\
		
\f0\b \
	add(anObject, channelOffset)\
		
\f2\b0 play a new synth, add it to the present ones\
	\
	
\f0\b removeAt(index)\
		
\f2\b0 remove the synth at index i and its player definition\
	\
	
\f0\b removeLast\
		
\f2\b0 remove the last synth and its player definition
\f0\b \
	\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \ul group-like behaviour:\ulnone \
\
	set(key, val, ...)\
		
\f2\b0 I behave like my nodeMap: see [NodeMap]\
		set, setn, unset, unmap\
		\
	
\f0\b map(keys, proxy)
\f2\b0 \
		map the arguments in keys to the subsequent channels of a control proxy\
		(keys can be a symbol, a number, or an array)\
		\
	
\f0\b setn()
\f2\b0  \
		not tested \
	\
	
\f0\b run(flag)
\f2\b0 \
		pause/unpause all synths in the group\
		\
	
\f0\b pause\
		
\f2\b0 pause all synths in the group\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \ul extended group-like behaviour:\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \ulnone 	\
	xset(key, val, ...)\
		
\f2\b0 set with crossfade into new setting\
		\
	x
\f0\b map(keys, proxy)
\f2\b0 \
		map with crossfade into new setting\
	\
	
\f0\b xsetn()\
		
\f2\b0 untested\
		
\f0\b \

\f2\b0 \
	_____________________
\f0\b \
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \ul sending synths to server\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0 \cf0 \ulnone (normally the source_ message does the sending already)
\f0\b \
	\
	wakeUp \
			
\f2\b0 until the proxy is not used by any output ( either .play or .ar/.kr )\
			it is not running on the server. you can wake it up to force it playing.\
			normally this is not needed.
\f0\b \
	\
	send(argList)\
		
\f2\b0 send a new synth without releasing the old one.\
		the argument list is applied to the synth only.\
		\
	
\f0\b sendAll(argList)\
		
\f2\b0 send all synths without releasing the old one.\
		the argument list is applied to all synths.
\f0\b \
	\
	put(anObject, channelOffset, sendFlag, freeAllFlag, completionFunc)\
		
\f2\b0 set the source. \
			anObject:	 can be a Function, an Instr, any valid UGen input\
						a pattern can be used if it returns an EventStream.\
			channelOffset: 	using a multichannel setup it can be useful to set this.\
							when the objects numChannels is smaller than the proxy \
			sendFlag: 	send it or not -  default:false\
			freeAllFlag: 	replace current synth or not - default:true\
						if false, add the new synth to the ones playing\
			completionFunc: is evaluated as soon as synth is sent, after the SynthDef is loaded\
			\

\f0\b 	
\f2\b0 \
			
\f0\b \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \ul release and cleaning up:\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \ulnone \
	free\
		
\f2\b0 free all my running synths and the group
\f0\b \
	\
	release\
		
\f2\b0 fade out my running synths\
	\
	
\f0\b clear\
		
\f2\b0 reset everything to nil, neutralizes rate/numChannels
\f0\b \
	\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \ul setting properties:\ulnone \
	\
	fadeTime_(time)\
		
\f2\b0 set the attack/release time \
	\
	
\f0\b clock_(aClock)
\f2\b0 \
		use a tempo clock for scheduling beat accurate\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 	still undocumented/experimental: lags, prepends\

\f2\b0 	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 \ul misc:\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0 \cf0 \ulnone \
	
\f0\b record(path, headerFormat, sampleFormat)\
		
\f2\b0 record output to file (returns a [RecNodeProxy] that you can use for stopping)\
		returns a [RecNodeProxy]\
		\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs26 \cf0 _________________________________________________________	\
		
\f1\fs18 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 //examples\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 s = Server.local;\
s.boot;\
\
a = \cf3 NodeProxy.audio\cf0 (s, 2);\
\
a.play; \cf2 //play to hardware output, return a group with synths\
\cf0 a.source = \{ \cf3 SinOsc\cf0 .ar([350, 390], 0, 0.1) \};\
a.source = \{ \cf3 SinOsc\cf0 .ar([390, 290] * 1.5, 0, 0.1) \};\
a.source = \{ \cf3 WhiteNoise\cf0 .ar([0.01,0.01]) \};\
a.source = 0;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 //feedback\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 a.source = \{ \cf3 SinOsc\cf0 .ar(a.ar * 7000 * \cf3 LFNoise1\cf0 .kr(1, 1, 1) + 200, 0, 0.1) \};\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 //adding nodes\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 a.add(\{ \cf3 SinOsc\cf0 .ar([350, 390]*1.25, 0, 0.1) \});\
a.add(\{ \cf3 BrownNoise\cf0 .ar([0.1,0.1]) \});\
\
\
a.fadeTime = 2.0;\
a.lags = [0.5]; \cf2 //for now the lags can be set like this\cf0 \
a.source = \{ \cf3 arg\cf0  f=400; \cf3 SinOsc\cf0 .ar(f * [1,1.2] * rrand(0.9, 1.1), 0, 0.1) \};\
a.set(\cf4 \\f\cf0 , rrand(1500, 700));\
a.set(\cf4 \\f\cf0 , rrand(1500, 700));\
a.xset(\cf4 \\f\cf0 , rrand(1500, 700)); \cf2 //crossfaded setting\cf0 \
a.source = \{ \cf3 arg\cf0  f=400; \cf3 LPF\cf0 .ar(\cf3 Pulse\cf0 .ar(f * [1,1.2], 0.5, 0.1), f * 2) \};\
a.lags = #[]; \cf2 //lags get updated after the source is set again:\cf0 \
a.source = \{ \cf3 arg\cf0  f=400; \cf3 LPF\cf0 .ar(\cf3 Pulse\cf0 .ar(f * [1,1.2], 0.5, 0.1), f ) \};\
a.set(\cf4 \\f\cf0 , rrand(1500, 700));\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 //mapping to busses\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 c = \cf3 NodeProxy.control\cf0 (s, 2);\
c.source = \{ \cf3 SinOsc\cf0 .kr([10,20] * 2, 0, 50, 300) \};\
a.map(\cf4 \\f\cf0 , c);\
c.source = \{ \cf3 SinOsc\cf0 .kr([10,20] * 0.02, 0, 50, 300) \};\
a.source = \{ \cf3 arg\cf0  f=400; \cf3 LPF\cf0 .ar(\cf3 Pulse\cf0 .ar(f * [0.4,1], 0.2, 0.3), f * 2) \};\
c.source = \{ \cf3 Line\cf0 .kr(300, 500, 10) + \cf3 SinOsc\cf0 .kr(20 * [1,2], 0, 10) \};\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 //map to multiple channels\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 a.source = \{ \cf3 arg\cf0  f=400, f2=400; \cf3 LPF\cf0 .ar(\cf3 Pulse\cf0 .ar(f * [0.4,1], 0.2, 0.3), f2) \};\
a.map([\cf4 \\f\cf0 ,\cf4 \\f2\cf0 ], c); \cf2 //same as a.map([0,1], c); \
\cf0 a.source = \{ \cf3 arg\cf0  f=400, f2=400; \cf3 LPF\cf0 .ar(\cf3 Pulse\cf0 .ar([f, f2], 0.2, 0.3), f2) \};\
c.source = \{ \cf3 SinOsc\cf0 .kr([10, 1], 0, [100, 700], [300, 700]) \};\
\
\
\
c.fadeTime = 2.5;\
c.source = \{ \cf3 LFNoise0\cf0 .kr([2.3, 1.0], [100, 700], [300, 1700]) \};\
c.source = \{ \cf3 SinOsc\cf0 .kr([2.3, 1.0], 0, [100, 700], [300, 1700]) \};\
c.source = 500;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 \
\
//behave like a sc2 plug\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 c.gate(1400, 0.1);\
c.gate(1000, 0.1);\
c.line(1000, 1);\cf2 \
\
//send an envelope: still to fix.\
\cf0 c.env(Env.perc(0.003, 0.9, 1000));\
w = Env.new(Array.rand(5, 400, 1000),Array.rand(4, 0.3, 0.001));\
c.env(w);\cf2 \
\
//stop synthesis, then wake up proxies:\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf5 \
a.stop; \cf6 //stop the monitor\cf5 \
a.play; \cf6 //start the monitor\cf5 \
a.release; \cf6 //release the synths\cf5 \
a.free;	\cf6 //free the synths\cf5 \
x.free;\
c.free;\
\
 \
 \
\cf6 //beat accurate playing\cf5 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 a.play;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 a.clock = \cf3 TempoClock\cf0 (2.0); \cf2 //round to every 2.0 seconds\
\cf0 a.source = \{ \cf3 Ringz\cf0 .ar(\cf3 Impulse\cf0 .ar(0.5, 0, 0.3), 3000, 0.01) \};\
a.add(\{ \cf3 Ringz\cf0 .ar(\cf3 Impulse\cf0 .ar([0.5, 1], 0, 0.3), 1000, 0.01) \});\
a.add(\{ \cf3 Ringz\cf0 .ar(\cf3 Impulse\cf0 .ar([3, 5]/2, 0, 0.3), 8000, 0.01) \});\
a.source = \{ \cf3 Ringz\cf0 .ar(\cf3 Impulse\cf0 .ar(4, 0, 0.3), 3000, 0.01) \};\
\
a.removeLast;\
a.removeAt(0);\
\
a.clear;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 //using patterns - event streams\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 (\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 SynthDef\cf0 (\cf7 "par"\cf0 , \{ \cf3 arg\cf0  freq, out=0, sustain=0.1; \cf2 //must have 'outIndex' argument to work properly\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 	\cf3 Out\cf0 .ar(out, Pan2.ar(\
		\cf3 LFCub\cf0 .ar(freq, 0, \cf3 Line\cf0 .kr(0.2, 0, sustain, doneAction:2)), Rand(-1.0, 1.0))\
	)\
\}).send(s);\
)\
\
(\cf5 \
a = \cf8 NodeProxy\cf5 .audio(s, 2);\
a.fadeTime = 2;\
a.play; \cf6 //monitor output\cf5 \
b = \cf8 NodeProxy\cf5 .audio(s,2);\
\
\cf0 e = \cf3 Event\cf0 .default;\
e.use(\{ ~player = \cf3 NoteDurPlayer\cf0 .new \}); \cf2 //use a player for self releasing nodes\cf0 \
)\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 //play the pattern silently in b\cf0 \
b.source = \cf3 Pbind\cf0 (\cf4 \\instrument\cf0 , \cf4 \\par\cf0 , \cf4 \\freq\cf0 , 600);\
\
\cf2 //play b out through a:\cf0 \
a.source = b;\
\
\cf2 //filter b with ring modulation:\cf0 \
a.source = \{  b.ar * \cf3 SinOsc\cf0 .ar(\cf3 SinOsc\cf0 .kr(0.2, 300, 330))  \}; \cf2 //filter the input of the pattern\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 a.source = \{  b.ar * \cf3 SinOsc\cf0 .ar([10, \cf3 40]\cf0 )  \}; \cf2 //filter the input of the pattern\cf0 \
\
a.source = b;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 //map b to another proxy\cf0 \
c = \cf3 NodeProxy\cf0 .control(s, 1);\
c.source = \{ \cf3 SinOsc\cf0 .kr(2, 0, 400, 700) \};\
b.map(\cf4 \\freq\cf0 , c);\
c.source = \{ \cf3 SinOsc\cf0 .kr(\cf3 SinOsc\cf0 .kr(0.2, 0, 10, 10), 0, 400, 700) \};\
\
a.source = b;\
c.source = \{ \cf3 LFNoise1\cf0 .kr(0.1, 100, 300) \};\
\
\cf2 //remove the mapping\cf0 \
b.unmap(\cf4 \\freq\cf0 );\
\
(\
b.source = \cf3 Pbind\cf0 (\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 			\\instrument\cf0 , \cf4 \\par\cf0 , \
			\cf4 \\freq\cf0 , Pseq([600, 400],inf), \
			\cf4 \\doneAction\cf0 , 2, \
			\cf4 \\dur\cf0 , 0.25\cf3 \
		\cf0 );\
)\
\
\
\
b.add(\cf3 Pbind\cf0 (\cf4 \\instrument\cf0 , \cf4 \\par\cf0 , \cf4 \\freq\cf0 , 620));\
b.add(\cf3 Pbind\cf0 (\cf4 \\instrument\cf0 , \cf4 \\par\cf0 , \cf4 \\freq\cf0 , \cf3 Pseq\cf0 ([700, 400],\cf3 inf\cf0 )));\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 //b.add(\{ WhiteNoise.ar([0.01,0.01]) \}); some error here\cf0 \
\
a.source = \{  b.ar * \cf3 WhiteNoise.ar(0.1, 1)\cf0   \}; \
a.source = \{  b.ar * \cf3 WhiteNoise.ar(0.1, 1) + (b.ar * SinOsc\cf0 .ar(\cf3 SinOsc\cf0 .kr(0.01, 0, 50, 330)))  \}; \
\cf3 \
\
\
\
\
\
_\cf0 _\cf3 __\cf0 _\cf3 ___\cf0 __\cf3 __\cf0 _____\cf3 ___\cf0 __\cf3 __\cf0 ___\cf3 _\cf0 _\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 Ndef
\f1\b0\fs18 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs26 \cf0 superclass: NodeProxy
\f1\b0\fs18 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 Ndef\cf0 (\\out, \{ \cf3 SinOsc\cf0 .ar([350, 390], 0, 0.1) \});\
\cf3 Ndef\cf0 (\\out).play;\
\cf3 Ndef\cf0 (\\out, \{ \cf3 SinOsc\cf0 .ar([350, 390]*1.2, 0, 0.1) \});\
\
\
\cf3 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs26 \cf0 a referencial shortcut in the '
\f0\b refdef
\f2\b0 ' scheme:\
\
get the object (or empty default) 	
\f0\b Ndef(\\name)
\f2\b0 \
put something into the proxy		
\f0\b Ndef(\\name, thing)
\f2\b0 \

\f0\b \
\
\
(see also Pdef, Tdef, under construction and experimental)\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs18 \cf3 \
\
\
\
}