{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fnil\fcharset77 Futura-Medium;\f1\fswiss\fcharset77 Helvetica-Bold;\f2\fnil\fcharset77 Monaco;
\f3\fswiss\fcharset77 Helvetica;}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue191;\red0\green115\blue0;
\red96\green96\blue96;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs36 \cf0 NodeProxy
\f1\b \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs18 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul superclass: AbstractFunction
\f1\b\fs26 \ulnone \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs18 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 Generally a proxy is a placeholder for something, which in this case \
is something playing on a server that writes to a limited number of busses.\
(this can be for example a synth or an event stream)
\f3 \
\

\f0 These objects  can be replaced, mapped and patched and used for calculation. 
\f3 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs22 \cf0 note that NodeProxy plays on a private bus. if you want to hear the output,\
use p.play and p.stop.\

\f2\fs16 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs22 \cf0 \ul bugs\ulnone : when setting the same node proxy to new values quickly,\
the server process doesn't keep up. this will change when async \
messages have a message id.
\f2\fs16 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs24 \cf0 \
	
\f0 NodeProxy.new(server)\
	NodeProxy.audio(server, numChannels)\
	NodeProxy.control(server, numChannels)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b \cf0 \
___________________________________________________\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b0 \cf0 \ul reading from the outbus
\f1\b \ul \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \ulnone \
	play(index, numChannels)\
		
\f3\b0 play output on specified bus index (default: public busses)\
		this works like a monitor.
\f1\b \
	stop\
		
\f3\b0 stop to play out public channels (private channels keep playing)\
		this stop the monitoring. to stop the objects playing, use 
\f1\b free
\f3\b0 \
		
\f1\b \
	ar(numChannels)\
	kr(numChannels)\
	\
		
\f3\b0 return a link to my output, which is limited by [numChannels]\
		causes an uninitialized proxy to create a matching bus.\
		presently ar defaults to stereo, kr to mono.\
	
\f1\b \ul \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b0 \cf0 \ul setting the source:
\f1\b \ul \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \ulnone \
	source_(anObject)\
		
\f3\b0 play a new synth through me, release old one.\
		anObject can be a Function, a SynthDef, an Instr, any valid UGen input\
		a pattern can be used if it returns an EventStream.\
			[only if the used synthdef (applies also to patterns) has the right number of channels\
			and an out argument, this can be used to do filtering. \
			if you supply a gate, the nodeProxy will assume doneAction 2 and fade out].\
		
\f1\b \
	add(anObject, channelOffset)\
		
\f3\b0 play a new synth, add it to the present ones\
	\
	
\f1\b removeAt(index)\
		
\f3\b0 remove the synth at index i and its player definition\
	\
	
\f1\b removeLast\
		
\f3\b0 remove the last synth and its player definition
\f1\b \
	\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b0 \cf0 \ul group-like behaviour:
\f1\b \ulnone \
\
	set(key, val, ...)\
		
\f3\b0 I behave like my nodeMap: see [NodeMap]\
		set, setn, unset, unmap\
		\
	
\f1\b map(key(s), proxy,  ... )
\f3\b0 \
		map the arguments in keys to the subsequent channels of a control proxy\
		(keys can be a symbol, a number, or an array)\
		\
	
\f1\b setn()
\f3\b0  \
		not tested \
	\
	
\f1\b run(flag)
\f3\b0 \
		pause/unpause all synths in the group\
		\
	
\f1\b pause\
		
\f3\b0 pause all synths in the group\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b0 \cf0 \ul extended group-like behaviour:
\f1\b \ul \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \ulnone 	\
	xset(key, val, ...)\
		
\f3\b0 set with crossfade into new setting\
		\
	x
\f1\b map(keys, proxy)
\f3\b0 \
		map with crossfade into new setting\
	\
	
\f1\b xsetn()\
		
\f3\b0 untested\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0 \cf0 \ul bus-like behaviour:
\f1\b \ul \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\b0 \cf0 \ulnone \
	
\f1\b line(value, dur)\
		
\f3\b0 set my bus to the new value in dur time linearly\
	x
\f1\b line(value, dur)\
		
\f3\b0 set my bus to the new value in dur time exponentially\
	
\f1\b gate(value, dur)\
		
\f3\b0 gate my bus to the level value for dur time\
		\
	\
	
\f1\b lineAt(key, value, dur)\
		
\f3\b0 set the control value to the new value in dur time linearly\
	x
\f1\b lineAt(key, value, dur)\
		
\f3\b0 set control value to the new value in dur time exponentially\
	
\f1\b gateAt(key, value, dur)\
		
\f3\b0 gate my control to the level value for dur time.\
		if the control was not set before, stay at the new value
\f1\b \

\f3\b0 \
	_____________________
\f1\b \
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b0 \cf0 \ul sending synths to server
\f1\b \ul \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\b0 \cf0 \ulnone (normally the source_ message does the sending already)
\f1\b \
	\
	wakeUp \
			
\f3\b0 until the proxy is not used by any output ( either .play or .ar/.kr )\
			it is not running on the server. you can wake it up to force it playing.\
			normally this is not needed.
\f1\b \
	\
	send(argList, index)\
		
\f3\b0 send a new synth without releasing the old one.\
		the argument list is applied to the synth only.\
		\
	
\f1\b sendAll(argList)\
		
\f3\b0 send all synths without releasing the old one.\
		the argument list is applied to all synths.
\f1\b \
	\
	put(anObject, channelOffset, sendFlag, freeAllFlag)\
		
\f3\b0 set the source. \
			anObject:	 can be a Function, an Instr, any valid UGen input\
						a pattern can be used if it returns an EventStream.\
			channelOffset: 	using a multichannel setup it can be useful to set this.\
							when the objects numChannels is smaller than the proxy \
			sendFlag: 	send it or not -  default:false\
			freeAllFlag: 	replace current synth or not - default:true\
						if false, add the new synth to the ones playing\
			\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b \cf0 	
\f3\b0 \
			
\f1\b \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b0 \cf0 \ul release and cleaning up\ulnone :
\f1\b \ul \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \ulnone \
	free\
		
\f3\b0 free all my running synths and the group
\f1\b \
	\
	release\
		
\f3\b0 fade out my running synths\
	\
	
\f1\b clear\
		
\f3\b0 reset everything to nil, neutralizes rate/numChannels
\f1\b \
	\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b0 \cf0 \ul setting properties\ulnone :
\f1\b \
	\
	fadeTime_(time)\
		
\f3\b0 set the attack/release time \
	\
	
\f1\b clock_(aClock)
\f3\b0 \
		use a tempo clock for scheduling beat accurate\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b \cf0 	still experimental: lags, prepends\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\b0 \cf0 	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0 \cf0 \ul misc\ulnone :
\f1\b \ul \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\b0 \cf0 \ulnone \
	
\f1\b record(path, headerFormat, sampleFormat)\
		
\f3\b0 record output to file (returns a [RecNodeProxy] that you can use for control)\
		returns a [RecNodeProxy]\
	\
	
\f1\b *defaultNumAudio_(n)\
		
\f3\b0 set the default channel number for audio busses\
	
\f1\b \
	*defaultNumControl_(n)\
		
\f3\b0 set the default channel number for control busses\
		\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs26 \cf0 _________________________________________________________\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs26 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 for more examples see [ProxySpace]
\f3 	
\f2\fs18 \
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 //examples\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 s = Server.local;\
s.boot;\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul using node proxy with ugen functions
\f2\fs18 \ulnone \
\
\
a = \cf3 NodeProxy.audio\cf0 (s, 2);\
a.play; \cf2 //play to hardware output, return a group with synths\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 //setting the source\cf0 \
a.source = \{ \cf3 SinOsc\cf0 .ar([350, 351.3], 0, 0.1) \};\
a.source = \{ \cf3 SinOsc\cf0 .ar([390, 286] * 1.2, 0, 0.1) \};\
a.source = \{ \cf3 WhiteNoise\cf0 .ar([0.01,0.01]) \};\
a.source = 0;\
\
\cf2 //feedback\cf0 \
a.source = \{ \cf3 SinOsc\cf0 .ar(a.ar * 7000 * \cf3 LFNoise1\cf0 .kr(1, 0.3, 0.6) + 200, 0, 0.1) \};\
a.source = \{ \cf3 SinOsc\cf0 .ar(a.ar * 6000 * \cf3 MouseX.kr(0, 2)\cf0  + [100, 104], 0, 0.1) \};\
\
\
\cf2 //adding nodes\cf0 \
a.add(\{ \cf3 SinOsc\cf0 .ar([350, 390]*1.25, 0, 0.1) \});\
a.add(\{ \cf3 BrownNoise\cf0 .ar([0.02,0.02]) \});\
\
\
\cf2 //setting controls\cf0 \
a.fadeTime = 2.0;\
a.source = \{ \cf3 arg\cf0  f=400; \cf3 SinOsc\cf0 .ar(f * [1,1.2] * rrand(0.9, 1.1), 0, 0.1) \};\
a.set(\cf4 \\f\cf0 , rrand(900, 300));\
a.set(\cf4 \\f\cf0 , rrand(1500, 700));\
a.xset(\cf4 \\f\cf0 , rrand(1500, 700)); \cf2 //crossfaded setting\cf0 \
a.source = \{ \cf3 arg\cf0  f=400; \cf3 RLPF\cf0 .ar(\cf3 Pulse\cf0 .ar(f * [1,1.2] * 0.05, 0.5, 0.2), f * 0.58, 0.2) \};\
\
\cf2 //control lags\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 a.fadeTime = 0.01;\
a.lags = [0.5]; \cf2 //for now argument lags can be set like this\cf0 \
a.set(\cf4 \\f\cf0 , rrand(1500, 700));\
a.lags = #[];\
a.set(\cf4 \\f\cf0 , rrand(1500, 700));\
a.fadeTime = 1.0;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 //mapping controls to other node proxies\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 c = \cf3 NodeProxy.control\cf0 (s, 2);\
c.source = \{ \cf3 SinOsc\cf0 .kr([10,20] * 0.1, 0, 150, 1300) \};\
a.map(\cf4 \\f\cf0 , c);\
a.source = \{ \cf3 arg\cf0  f=400; \cf3 RHPF\cf0 .ar(\cf3 Pulse\cf0 .ar(f * [1,1.2] * 0.05, 0.5, 0.2), f * 0.58, 0.2) \};\
c.source = \{ \cf3 SinOsc\cf0 .kr([10,16] * 0.02, 0, 50, 700) \};\
c.source = \{ \cf3 Line\cf0 .kr(300, 1500, 10) + \cf3 SinOsc\cf0 .kr(20 * [1,2], 0, 100) \};\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 //map to multiple node proxies\cf0 \
a.source = \{ \cf3 arg\cf0  f=400, f2=400; \cf3 LPF\cf0 .ar(\cf3 Pulse\cf0 .ar(f * [0.4,1], 0.2, 0.2), f2 * 3) \};\
a.map([\cf4 \\f\cf0 ,\cf4 \\f2\cf0 ], c); \cf2 //same as a.map([0,1], c); \cf0 \
a.source = \{ \cf3 arg\cf0  f=400, f2=400; \cf3 LPF\cf0 .ar(\cf3 Pulse\cf0 .ar([f, f2], 0.2, 0.2), f2) \};\
a.source = \{ \cf3 arg\cf0  f=400, f2=400; \cf3 Formant\cf0 .ar(140, [f, f2]*1.5, 100, 0.1)  \};\
c.source = \{ \cf3 SinOsc\cf0 .kr([\cf3 Line\cf0 .kr(1, 30, 10), 1], 0, [100, 700], [300, 700]) \};\
c.source = 400;\
\
\
c.fadeTime = 5.5;\
c.source = \{ \cf3 LFNoise0\cf0 .kr([2.3, 1.0], [100, 700], [300, 1700]) \};\
c.source = \{ \cf3 SinOsc\cf0 .kr([2.3, 1.0], 0, [100, 700], [300, 1700]) \};\
c.source = 400;\
\cf2 \
\
//behave like a sc2 plug\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 c.gate(1400, 0.1);\
c.gate(1000, 0.1);\
c.line(1000, 1);\cf2 \
\
\
//sending envelopes\cf0 \
w = Env.new(Array.rand(3, 400, 1000),Array.rand(2, 0.3, 0.001), -4);\
c.env(w);\
c.env(w);\
w = Env.new(Array.rand(8, 400, 1000),Array.rand(7, 0.03, 0.1));\
c.env(w);\cf2 \
\
//stop synthesis, then wake up proxies:\
\cf0 \
a.stop; \cf2 //stop the monitor\cf0 \
a.play; \cf2 //start the monitor\cf0 \
a.release; \cf2 //release the synths\cf0 \
a.free;	\cf2 //free the synths\cf0 \
x.free;\
c.free;\
a.stop;\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 //prepend args: similarly to lags, this might change.\
//note that you have to take care for the prependargs, as some ugens\
//don't accept certain inputs. the prepend args overwrite the args one\
//by one, the rest is controls. this scheme will probably change\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 a.clear; \cf2 //make sure there is no other functions in there\cf0 \
a.play;\
a.fadeTime = 1;\
a.prepend = [`[[300, 600, 344], \cf3 nil\cf0 , \cf3 nil\cf0 ]];\
a.source = \{ arg specs; Klang.ar(specs) * 0.1 \};\
\
a.prepend = [`[[100, 700, 344], nil, nil]];\
a.prepend = [`[[400, 710, 324], nil, nil]];\
a.prepend = [`[[400, 710, 324]*0.7, nil, nil]];\
a.clearPrepend;\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul channel offset
\f2\fs18 \ulnone \
\
a = \cf3 NodeProxy\cf0 .audio(s,2);\
a.play;\
a.add(\{ \cf3 Ringz\cf0 .ar(\cf3 Impulse\cf0 .ar(5, 0, 0.1), 360) \}, 0);\
a.add(\{ \cf3 Ringz\cf0 .ar(\cf3 Impulse\cf0 .ar(5.3, 0, 0.1), 320) \}, 1);\
a.add(\{ \cf3 Ringz\cf0 .ar(\cf3 Dust\cf0 .ar([1,1]*15.3,  0.01), 720) \}, 0);\
a.release;\
\

\f0\fs24 \ul beat accurate playing\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \ulnone \
\
a = \cf3 NodeProxy\cf0 .audio(s,2);\
a.play;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 a.clock = \cf3 TempoClock\cf0 (1.0); \cf2 //round to every 2.0 seconds\
\cf0 a.source = \{ \cf3 Ringz\cf0 .ar(\cf3 Impulse\cf0 .ar(0.5, 0, 0.3), 3000, 0.01) \};\
a.add(\{ \cf3 Ringz\cf0 .ar(\cf3 Impulse\cf0 .ar([0.5, 1], 0, 0.3), 1000, 0.01) \});\
a.add(\{ \cf3 Ringz\cf0 .ar(\cf3 Impulse\cf0 .ar([3, 5]/2, 0, 0.3), 8000, 0.01) \});\
a.source = \{ \cf3 Ringz\cf0 .ar(\cf3 Impulse\cf0 .ar(4, 0, 0.3), 3000, 0.01) \};\
\
a.removeLast;\
a.removeAt(0);\
\
a.clear;\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul using patterns - event streams
\f2\fs18 \cf2 \ulnone \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
\
\
(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 //must have 'out'or 'i_out' argument to work properly\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 SynthDef\cf0 (\cf5 "who"\cf0 , \{ \cf3 arg\cf0  freq, gate=1, out=0, ffreq=800; \
	var env;\
	env = Env.asr(0.01, 0.1, 0.5);\
	\cf3 Out\cf0 .ar(out, Pan2.ar(\
		\cf3 Formant\cf0 .ar(freq, ffreq, 300, \cf3 EnvGen.kr(\cf0 env, gate, doneAction:2)), Rand(-1.0, 1.0))\
	)\
\}).load(s);\
)\
\
(\
a = \cf3 NodeProxy\cf0 .audio(s, 2);\
a.fadeTime = 2;\
a.play; \cf2 //monitor output\cf0 \
b = \cf3 NodeProxy\cf0 .audio(s,2);\
)\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 //play the pattern silently in b\cf0 \
b.source = \cf3 Pbind\cf0 (\cf4 \\instrument\cf0 , \cf4 \\\cf5 who\cf0 , \cf4 \\freq\cf0 , 600, \\legato, 0.2);\
\
\cf2 //play b out through a:\cf0 \
a.source = b;\
\
\cf2 //filter b with ring modulation:\cf0 \
a.source = \{  b.ar  * \cf3 SinOsc\cf0 .ar(\cf3 SinOsc\cf0 .kr(0.2, 300, 330))  \}; \cf2 //filter the input of the pattern\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 a.source = \{  b.ar * \cf3 LFCub\cf0 .ar([2, \cf3 8]\cf0 )  \}; \cf2 //filter the input of the pattern\cf0 \
\
a.source = b;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 //map b to another proxy\cf0 \
c = \cf3 NodeProxy\cf0 .control(s, 1).fadeTime_(1);\
c.source = \{ \cf3 SinOsc\cf0 .kr(2, 0, 400, 700) \};\
b.map(\cf4 \\ffreq\cf0 , c);\
c.source = \{ \cf3 SinOsc\cf0 .kr(\cf3 SinOsc\cf0 .kr(0.2, 0, 10, 10), 0, 400, 700) \};\
\
c.source = \{ \cf3 LFNoise1\cf0 .kr(5, 1300, 1500) \};\
c.source = \{ \cf3 MouseX.kr(\cf0 100, 5500, 'exponential') \};\
\
(\
b.source = \cf3 Pbind\cf0 (\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 			\\instrument\cf0 , \cf4 \\who\cf0 , \
			\cf4 \\freq\cf0 , Pseq([600, 390],inf),\
			\\legato, 0.1,\
			\cf4 \\dur\cf0 , 0.25\cf3 \
		\cf0 );\
)\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 //remove the mapping\cf0 \
b.unmap(\cf4 \\ffreq\cf0 );\
\
\
b.add(\cf3 Pbind\cf0 (\cf4 \\instrument\cf0 , \cf4 \\who\cf0 , \cf4 \\freq\cf0 , 620, \\legato, 0.1));\
b.add(\cf3 Pbind\cf0 (\cf4 \\instrument\cf0 , \cf4 \\who\cf0 , \cf4 \\freq\cf0 , \cf3 Pseq\cf0 ([700, 400],\cf3 inf\cf0 ), \\legato, 0.1));\
b.add(\{ \cf3 WhiteNoise\cf0 .ar([0.01,0.01]) \}); \
b.add(\{ \cf3 arg\cf0  ffreq=800; \cf3 Resonz\cf0 .ar(\cf3 WhiteNoise\cf0 .ar([1,1]), ffreq, 0.05) \}); \
\
\
b.map(\cf4 \\ffreq\cf0 , c); \cf2 //xmap doesn't work yet\cf0 \
b.removeLast;\
b.removeLast;\
a.source = \{  b.ar * \cf3 WhiteNoise.ar(0.1, 1)\cf0   \}; \
a.source = \{  b.ar * \cf3 WhiteNoise.ar(0.1, 1) + (b.ar * SinOsc\cf0 .ar(\cf3 SinOsc\cf0 .kr(0.01, 0, 50, 330)))  \}; \
\
c.source = \{ \cf3 Line.kr(1900, 10, 10)\cf0  \};\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 \
\
\
\
\
\
}