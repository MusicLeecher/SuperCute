{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fnil\fcharset77 Monaco;\f2\fswiss\fcharset77 Helvetica;
}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue191;\red0\green115\blue0;
\red96\green96\blue96;\red0\green0\blue0;\red0\green0\blue191;\red0\green115\blue0;\red191\green0\blue0;
}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 NodeProxy\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs18 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs26 \cf0 superclass: AbstractFunction\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs18 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs26 \cf0 Generally a proxy is a placeholder for something, which in this case \
is something playing on a server that writes to a limited number of busses.\
(this can be for example a synth or an event stream)\
\
These objects  can be replaced, mapped and patched and used for calculation. \
See ProxySpace for more examples.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs26 \cf0 \
	
\f0\b NodeProxy.new(server)\
	NodeProxy.audio(server, numChannels)\
	NodeProxy.control(server, numChannels)\
\
___________________________________________________\
\
\ul setting the source:\
\ulnone \
	source_(anObject)\
		
\f2\b0 play a new synth through me, release old one.\
		anObject can be a Function, an Instr, any valid UGen input\
		a pattern can be used if it returns an EventStream.\
			[only if the used synthdef (in the pattern) has the right number of channels\
			and an out argument, this can be used to do filtering].\
		
\f0\b \
	add(anObject, channelOffset)\
		
\f2\b0 play a new synth, add it to the present ones\
		anObject can be a Function, an Instr, any valid UGen input\
	\
	
\f0\b removeAt(index)\
		
\f2\b0 remove the synth at index i and its player definition\
	\
	
\f0\b removeAt(index)\
		
\f2\b0 remove the last synth and its player definition
\f0\b \
	\
	\
\ul group-like behaviour:\ulnone \
\
	set(key, val, ...)\
		
\f2\b0 I behave like my nodeMap: see [NodeMap]\
		set, setn, unset, unmap\
		\
	
\f0\b map(keys, proxy)
\f2\b0 \
		map the arguments in keys to the subsequent channels of a control proxy\
		(keys can be a symbol, a number, or an array)\
		\
	
\f0\b run(flag)
\f2\b0 \
		pause/unpause all synths in the group\
		\
	
\f0\b pause\
		
\f2\b0 pause all synths in the group\

\f0\b \
\
\ul reading from bus\
\ulnone \
	play(index, numChannels)\
		
\f2\b0 play output on specified bus index (default: public busses)
\f0\b \
	\
	ar(numChannels)\
	kr(numChannels)\
	\
		
\f2\b0 return a link to my output, which is limited by [numChannels]\
	\
	_____________________
\f0\b \
	\
\ul sending synths to server\

\f2\b0 \ulnone (normally the source_ message does the sending already)
\f0\b \
\
	send(argList)\
		
\f2\b0 send a new synth without releasing the old one.\
		the argument list is applied to the synth only.\
		\
	
\f0\b sendAll(argList)\
		
\f2\b0 send all synths without releasing the old one.\
		the argument list is applied to all synths.
\f0\b \
	\
	put(anObject, channelOffset, sendFlag, freeAllFlag, completionFunc, latency)\
		
\f2\b0 set the source:\
			channelOffset: 	using a multichannel setup it can be useful to set this.\
							when the objects numChannels is smaller than the proxy \
			sendFlag: 	send it or not -  default:false\
			freeAllFlag: 	replace current synth or not - default:true\
						if false, add the new synthDef to the present ones\
			completionFunc: is evaluated as soon as synth is running\
			latency: 		nil: wait for '/done' message (doesn't work when sending several at once)\
						a number is the time to wait for the loading.\

\f0\b \
\ul release and cleaning up:\
\ulnone \
	free\
		
\f2\b0 free all my running synths and the group
\f0\b \
	\
	release\
		
\f2\b0 fade out my running synths\
	\
	
\f0\b clear\
		
\f2\b0 reset everything to nil
\f0\b \
	\
\
\ul setting properties:\ulnone \
	\
	fadeTime_(time)\
		
\f2\b0 set the attack/release time\
	\
	
\f0\b clock_(aClock)
\f2\b0 \
		use a tempoclock for scheduling beat accurate\
	\
	
\f0\b freeSelf_(true/false)
\f2\b0 \
		switch it to false if a nodeproxy should be used to spawn\
		single synths that have their own envelope (see ProxySpace example)\
	\

\f0\b 	still undocumented/experimental: lags, prepends\

\f2\b0 	\

\f0\b \ul misc:\

\f2\b0 \ulnone \
	
\f0\b record(path, headerFormat, sampleFormat)\
		
\f2\b0 record output to file (returns a RecNodeProxy that you can use for stopping)\
		\
_________________________________________________________	\
		
\f1\fs18 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 //examples\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 s = Server.local;\
s.boot;\
\
a = \cf3 NodeProxy.audio\cf0 (s, 2);\
\
x = a.play; \cf2 //play to hardware output, return a group with synths\
\cf0 a.source = \{ \cf3 SinOsc\cf0 .ar([350, 390], 0, 0.1) \};\
a.source = \{ \cf3 SinOsc\cf0 .ar([390, 290]*1.5, 0, 0.1) \};\
a.source = \{ \cf3 WhiteNoise\cf0 .ar([0.01,0.01]) \};\
a.source = 0;\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 //feedback\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 a.source = \{ \cf3 SinOsc\cf0 .ar(a.ar*7000*\cf3 LFNoise1\cf0 .kr(1, 1, 1) + 200, 0, 0.1) \};\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 //adding nodes\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 a.add(\{ \cf3 SinOsc\cf0 .ar([350, 390]*1.25, 0, 0.1) \});\
a.add(\{ \cf3 BrownNoise\cf0 .ar([0.1,0.1]) \});\
\
\
a.fadeTime = 2.0;\
a.lags = [0.5]; \cf2 //for now the lags can be set like this\cf0 \
a.source = \{ \cf3 arg\cf0  f=400; \cf3 SinOsc\cf0 .ar(f*[1,1.2]*rrand(0.9, 1.1), 0, 0.1) \};\
a.set(\cf4 \\f\cf0 , rrand(1500,700));\
a.set(\cf4 \\f\cf0 , rrand(1500,700));\
a.xset(\cf4 \\f\cf0 , rrand(1500,700)); \cf2 //crossfaded setting\cf0 \
a.source = \{ \cf3 arg\cf0  f=400; \cf3 LPF\cf0 .ar(\cf3 Pulse\cf0 .ar(f*[1,1.2], 0.5, 0.1), f*2) \};\
a.lags = #[];\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 //mapping to busses\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 c = \cf3 NodeProxy.control\cf0 (s, 2);\
c.source = \{ \cf3 SinOsc\cf0 .kr([10,20]*2, 0, 50, 300) \};\
a.map(\cf4 \\f\cf0 , c);\
a.source = \{ \cf3 arg\cf0  f=400; \cf3 LPF\cf0 .ar(\cf3 Pulse\cf0 .ar(f*[0.4,1], 0.2, 0.1), f*2) \};\
c.source = \{ \cf3 Line\cf0 .kr(300, 500, 10) + \cf3 SinOsc\cf0 .kr(20*[1,2], 0, 10) \};\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 //map to multiple channels\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 a.source = \{ \cf3 arg\cf0  f=400, f2=400; \cf3 LPF\cf0 .ar(\cf3 Pulse\cf0 .ar(f*[0.4,1], 0.2, 0.1), f2) \};\
a.map([\cf4 \\f\cf0 ,\cf4 \\f2\cf0 ], c); \cf2 //same as a.map([0,1], c); \
\cf0 a.source = \{ \cf3 arg\cf0  f=400, f2=400; \cf3 LPF\cf0 .ar(\cf3 Pulse\cf0 .ar([f,f2], 0.2, 0.1), f2) \};\
c.source = \{ \cf3 SinOsc\cf0 .kr([10, 1], 0, [100, 700], [300, 700]) \};\
\
\
\
c.fadeTime = 2.5;\
c.source = \{ \cf3 LFNoise0\cf0 .kr([2.3,1], [100, 700], [300, 1700]) \};\
c.source = \{ \cf3 SinOsc\cf0 .kr([2.3,1], 0, [100, 700], [300, 1700]) \};\
c.source = 500;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 \
\
//behave like a sc2 plug\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 c.gate(1400, 0.1);\
c.gate(1000, 0.1);\
c.line(1000, 1);\cf2 \
\
//send an envelope: still to fix.\
\cf0 c.env(Env.perc(0.003, 0.9, 1000));\
w = Env.new(Array.rand(5,400,1000),Array.rand(4,0.3,0.001));\
c.env(w);\cf2 \
\
//stop synthesis, then wake up proxies:\
\cf0 \
x = a.play;\
a.release;\
a.free;\
x.free;\
c.free;\
\
 \
 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 //beat accurate playing\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 x = a.play;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 a.clock = \cf3 TempoClock\cf0 (2.0); \cf2 //round to every 2.0 seconds\
\cf0 a.source = \{ \cf3 Ringz\cf0 .ar(\cf3 Impulse\cf0 .ar(0.5, 0, 0.3), 3000, 0.01) \};\
a.add(\{ \cf3 Ringz\cf0 .ar(\cf3 Impulse\cf0 .ar([0.5, 1], 0, 0.3), 1000, 0.01) \});\
a.add(\{ \cf3 Ringz\cf0 .ar(\cf3 Impulse\cf0 .ar([3, 5]/2, 0, 0.3), 8000, 0.01) \});\
a.source = \{ \cf3 Ringz\cf0 .ar(\cf3 Impulse\cf0 .ar(4, 0, 0.3), 3000, 0.01) \};\
\
\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 //using patterns - event streams\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 (\
\cf3 SynthDef\cf0 (\cf5 "par"\cf0 , \{ \cf3 arg\cf0  freq, out=0, sustain=0.1; \cf2 //must have 'outIndex' argument to work properly\
\cf0 	\cf3 Out\cf0 .ar(out, Pan2.ar(\cf3 LFCub\cf0 .ar(freq,0,\cf3 Line\cf0 .kr(0.1,0,sustain, doneAction:2)), Rand(-1.0,1.0)))\
\}).send(s);\
)\
\
(\
a = \cf3 NodeProxy.audio\cf0 (s, 2);\
a.fadeTime = 2;\
a.play;\
b = \cf3 NodeProxy\cf0 .audio(s,2);\
\
e = \cf3 Event\cf0 .default;\
e.use(\{ ~player = \cf3 NoteDurPlayer\cf0 .new \}); \cf2 //use a player for self releasing nodes\cf0 \
)\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 //play the pattern silently in b\cf0 \
b.source = \cf3 Pbind\cf0 (e, \cf4 \\instrument\cf0 , \cf4 \\par\cf0 , \cf4 \\freq\cf0 , 600);\
\
\cf2 //play b out through a:\cf0 \
a.source = b;\
\
\cf2 //filter b with ring modulation:\cf0 \
a.source = \{  b.ar * \cf3 SinOsc\cf0 .ar(\cf3 SinOsc\cf0 .kr(0.2, 300, 330))  \}; \cf2 //filter the input of the pattern\cf0 \
a.source = b;\
\
\cf2 //map b to another proxy\cf0 \
c = \cf3 NodeProxy\cf0 .control(s,1);\
c.source = \{ \cf3 SinOsc\cf0 .kr(2, 0, 400, 700) \};\
b.map(\cf4 \\freq\cf0 , c);\
c.source = \{ \cf3 SinOsc\cf0 .kr(\cf3 SinOsc\cf0 .kr(0.2, 0, 10, 10), 0, 400, 700) \};\
\
a.source = b;\
c.source = \{ LFNoise1.kr(0.1, 100, 300) \};\
\cf2 \
//remove the mapping\cf0 \
b.unmap(\cf4 \\freq\cf0 );\
\
(\
b.source = \cf3 Pbind\cf0 (e,\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 			\\instrument\cf0 , \cf4 \\par\cf0 , \
			\cf4 \\freq\cf0 , Pseq([600, 400],inf), \
			\cf4 \\doneAction\cf0 , 2, \
			\cf4 \\dur\cf0 , 0.25\cf3 \
		\cf0 );\
)\
\
\
\
b.add(\cf3 Pbind\cf0 (e, \cf4 \\instrument\cf0 , \cf4 \\par\cf0 , \cf4 \\freq\cf0 , 620));\cf6 \
b.add(\cf7 Pbind\cf6 (e, \cf8 \\instrument\cf6 , \cf8 \\par\cf6 , \cf8 \\freq\cf6 , \cf7 Pseq\cf6 ([700, 400],\cf7 inf\cf6 )));\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf9 //b.add(\{ WhiteNoise.ar([0.01,0.01]) \}); some error here\cf0 \
\
a.source = \{  b.ar * \cf3 WhiteNoise.ar(0.1, 1)\cf0   \}; \
a.source = \{  b.ar * \cf3 WhiteNoise.ar(0.1, 1) + (b.ar * SinOsc\cf0 .ar(\cf3 SinOsc\cf0 .kr(0.01, 0, 50, 330)))  \}; \
\cf3 \
\
\
\
\
\
_\cf0 _\cf3 __\cf0 _\cf3 ___\cf0 __\cf3 __\cf0 _____\cf3 ___\cf0 __\cf3 __\cf0 ___\cf3 _\cf0 _\
\
NodeProxy can be used implicitly using the following shortcut:\
\
\
\{ \cf3 SinOsc\cf0 .ar([350, 390], 0, 0.1) \}.send(\cf4 \\out\cf0 ); \cf2 //play the function on a private bus\
\cf6 x = \cf8 \\out\cf6 .play;	\cf9 //play it out the hardware bus\cf6 \
\cf0 \
\{ \cf3 SinOsc\cf0 .ar([350, 390]+20, 0, 0.1) \}.send(\cf4 \\out\cf0 ); \cf2 //replace the synth playing in \\out\
\cf0 \
}