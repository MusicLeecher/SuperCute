{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fnil\fcharset77 Futura-Medium;\f1\fswiss\fcharset77 Helvetica-Bold;\f2\fnil\fcharset77 Monaco;
\f3\fswiss\fcharset77 Helvetica;}
{\colortbl;\red255\green255\blue255;\red163\green146\blue90;\red191\green0\blue0;\red0\green0\blue191;
\red0\green115\blue0;\red96\green96\blue96;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs36 \cf0 NodeProxy		
\f1\b\fs24 a reference on a server 
\fs36 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs18 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b\fs24 \cf0 superclass: BusPlug
\fs26 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs18 \cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs24 \cf0 Generally a proxy is a placeholder for something, which in this case \
is something playing on a server that writes to a limited number of busses.\
\
\
(this can be for example a synth or an event stream). The rate and number\
of channels is determined either when the instance is created (.control/.audio) \
or by lazy initialisation from the first source.[
\f1\b the_lazy_proxy
\f3\b0 ]\
These objects  can be replaced, mapped and patched and used for calculation. \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b \cf0 ProxySpace
\f3\b0  returns instances of NodeProxy. all the examples below apply to ProxySpace accordingly:\
\
a = NodeProxy(s) 	is equivalent to  ~a;\
a.source = ...		is equivalent to  ~a = ...\
a[3] = ...			is equivalent to  ~a[3] = ...\
\
see also: [
\f1\b jitlib_efficiency
\f3\b0 ]\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf2 \'a5\'a5\'a5\'a5\cf0 this is experimental and things change.\cf2 \'a5\'a5\'a5\'a5
\f3\fs24 \cf0 \
\
\
note that NodeProxy plays on a \ul private bus\ulnone . if you want to hear the output,\
use p.play and p.stop.\
\
bugs: when setting the same node proxy to new values quickly,\
the server process doesn't keep up. this will change when async \
messages have a message id.\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs26 \cf0 \ul instance creation
\fs24 \ulnone \
\
	
\f1\b *new(server)\
	*audio(server, numChannels)\
	*control(server, numChannels)
\f3\b0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b \cf0 \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\b0\fs26 \cf0 \ul reading from the bus
\f1\b\fs24 \ul \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \ulnone \
\
	play(index, numChannels, group, multi)\
		
\f3\b0 play output on specified bus index (default: public busses)\
		this works like a monitor.\
		if multi is set to true it can create multiple monitors 
\f1\b \
	stop\
		
\f3\b0 stop to play out public channels (private channels keep playing as others might listen still)\
		this stop the monitoring. to stop the objects playing, use 
\f1\b free, release\
	\
	releaseAndStop\
		
\f3\b0 releases the synths and stops playback\
		
\f1\b \
	ar(numChannels)\
	kr(numChannels)\
	\
		
\f3\b0 return a link to my output, which is limited by [numChannels]\
		causes an uninitialized proxy to create a matching bus.\
	\
	normally ar defaults to stereo, kr to mono. this can be set in the classvars:\
	
\f1\b defaultNumAudio, defaultNumControl
\f3\b0 \
	\
	\
	
\f1\b \ul \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\b0\fs26 \cf0 \ul setting the source:
\f1\b\fs24 \ul \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \ulnone \
\
	source_(anObject)\
		
\f3\b0 play a new synth through me, release old one.\
		anObject can be a Function, a SynthDef, an Instr, any valid UGen input\
		a pattern can be used if it returns an EventStream.\
			[only if the used synthdef (applies also to patterns) has the right number of channels\
			and an out argument, this can be used to do filtering. \
			if you supply a gate, the nodeProxy will assume doneAction 2 and fade out].\
		
\f1\b \
	add(anObject, channelOffset, extraArgs)\
		
\f3\b0 play a new synth, add it to the present ones\
	\
	
\f1\b removeAt(index)\
		
\f3\b0 remove the synth at index i and its player definition\
	\
	
\f1\b removeLast\
		
\f3\b0 remove the last synth and its player definition
\f1\b \
	\
	put(index, anObject, channelOffset, extraArgs)\
		
\f3\b0 set the source by index. \
			
\f1\b index
\f3\b0 :	\
						where the object should be placed in the internal  order. \
						if 
\f1\b -1
\f3\b0 , all objects are freed\
			
\f1\b anObject
\f3\b0 :	 \
						can be a Function, an Instr, any valid UGen input\
						a pattern can be used if it returns an EventStream.\
			
\f1\b channelOffset
\f3\b0 : 	\
						using a multichannel setup it can be useful to set this.\
						when the objects numChannels is smaller than the proxy \
						\
			
\f1\b extraArgs
\f3\b0 : 	extra arguments that can be sent with the object directly (not cached)\
			\

\f1\b 	put 
\f3\b0 can be used as array indexing: 
\f1\b a[0]
\f3\b0  = \{ SinOsc.ar \}\
	one can put an object at any index, only the order of indices is relevant.\
	if the index equals an existing index, the object at this index is replaced.
\f1\b \
	\
	\
	\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\b0\fs26 \cf0 \ul group-like behaviour:
\f1\b\fs24 \ulnone \
\
	set(key, val, ...)\
		
\f3\b0 I behave like my nodeMap: see [NodeMap]\
		set, setn, unset, unmap\
		\
	
\f1\b map(key(s), proxy,  ... )
\f3\b0 \
		map the arguments in keys to the subsequent channels of a control proxy\
		(keys can be a symbol, a number, or an array)\
		\
	
\f1\b setn(key, list, ...)
\f3\b0  \
		set ranges of controls\
	\
	
\f1\b run(flag)
\f3\b0 \
		pause/unpause all synths in the group\
		\
	
\f1\b pause\
		
\f3\b0 pause all synths in the group\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b \cf0 \
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\b0\fs26 \cf0 \ul extended group-like behaviour:
\f1\b\fs24 \ul \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \ulnone 	\
	xset(key, val, ...)\
		
\f3\b0 set with crossfade into new setting\
		\
	x
\f1\b map(keys, proxy)
\f3\b0 \
		map with crossfade into new setting\
	\
	
\f1\b xsetn()\
		
\f3\b0 untested\
	\
	
\f1\b lag(key, val, ...)	
\f3\b0 \
		set the lag values of these args\
	\
	
\f1\b unlag(key, key1, ...)
\f3\b0 	\
		remove the lag values of thise args\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs26 \cf0 \ul bus-like behaviour:
\f1\b\fs24 \ul \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\b0 \cf0 \ulnone \
	
\f1\b line(value, dur)\
		
\f3\b0 set my bus to the new value in dur time linearly\
	x
\f1\b line(value, dur)\
		
\f3\b0 set my bus to the new value in dur time exponentially\
	
\f1\b gate(value, dur)\
		
\f3\b0 gate my bus to the level value for dur time\
		\
	\cf3 //do not work properly yet !\cf0 \
	
\f1\b lineAt(key, value, dur)\
		
\f3\b0 set the control value to the new value in dur time linearly\
	x
\f1\b lineAt(key, value, dur)\
		
\f3\b0 set control value to the new value in dur time exponentially\
	
\f1\b gateAt(key, value, dur)\
		
\f3\b0 gate my control to the level value for dur time.\
		if the control was not set before, stay at the new value
\f1\b \

\f3\b0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b \cf0 \
\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\b0\fs26 \cf0 \ul sending synths to server
\f1\b\fs24 \ul \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\b0 \cf0 \ulnone (normally the source_ message does the sending already)
\f1\b \
	\
	wakeUp \
			
\f3\b0 until the proxy is not used by any output ( either .play or .ar/.kr )\
			it is not running on the server. you can wake it up to force it playing.\
			normally this is not needed.
\f1\b \
	\
	send(argList, index, freeLast)\
		
\f3\b0 send a new synth without releasing the old one.\
		the argument list is applied to the synth only.\
		freeLast: if to free the last synth at that index\
		\
	
\f1\b sendAll(argList, freeLast)\
		
\f3\b0 send all synths without releasing the old one.\
		the argument list is applied to all synths.\
		freeLast: if to free present synths
\f1\b \
	\
	
\f3\b0 \
			
\f1\b \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\b0\fs26 \cf0 \ul release and cleaning up:
\f1\b\fs24 \ul \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \ulnone \
	free\
		
\f3\b0 free all my running synths and the group
\f1\b \
	\
	release\
		
\f3\b0 fade out my running synths\
	\
	
\f1\b clear\
		
\f3\b0 reset everything to nil, neutralizes rate/numChannels
\f1\b \
	\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\b0\fs26 \cf0 \ul setting properties:
\f1\b\fs24 \ulnone \
	\
	fadeTime_(time)\
		
\f3\b0 set the attack/release time \
	\
	
\f1\b clock_(aClock)
\f3\b0 \
		use a tempo clock for scheduling beat accurate\
	
\f1\b \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\b0 \cf0 	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs26 \cf0 \ul misc:
\f1\b\fs24 \ul \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\b0 \cf0 \ulnone \
	
\f1\b record(path, headerFormat, sampleFormat)\
		
\f3\b0 record output to file (returns a [RecNodeProxy] that you can use for control)\
		returns a [RecNodeProxy]\
	\
	
\f1\b *defaultNumAudio_(n)\
		
\f3\b0 set the default channel number for audio busses\
	
\f1\b \
	*defaultNumControl_(n)\
		
\f3\b0 set the default channel number for control busses\
		\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs26 \cf0 _________________________________________________________\
\

\f0\fs24 \

\f3\fs26 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b\fs24 \cf0 for more examples see [ProxySpace]
\f3\b0 	
\f2\fs18 \
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 //examples\
\cf0 s = Server.local;\
s.boot;\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b\fs24 \cf0 using node proxy with ugen functions
\f2\b0\fs18 \
\
\
a = \cf4 NodeProxy.audio\cf0 (s, 2);\
a.play; \cf3 //play to hardware output, return a group with synths\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
\cf3 //setting the source\cf0 \
a.source = \{ \cf4 SinOsc\cf0 .ar([350, 351.3], 0, 0.2) \};\
\
\cf3 //the proxy has two channels now:\cf0 \
a.numChannels.postln;\
a.source = \{ \cf4 SinOsc\cf0 .ar([390, 286] * 1.2, 0, 0.2) \};\
\
\cf3 //exeeding channels wrap:\cf0 \
a.source = \{ \cf4 SinOsc\cf0 .ar([390, 286, 400, 420, 300] * 1.2, 0, 0.2) \};\
\
\cf3 //other inputs\cf0 \
a.source = \{ \cf4 WhiteNoise\cf0 .ar([0.01,0.01]) \};\
a.source = 0;\
a.source = \cf5 \\default\cf0 ; \cf3 //synthDef on server\
\cf0 a.source = \cf4 SynthDef\cf0 (\cf6 "w"\cf0 , \{ \cf4 arg\cf0  out=0; \cf4 Out\cf0 .ar(out,\cf4 SinOsc\cf0 .ar([\cf4 Rand\cf0 (430, 600), 600], 0, 0.2)) \});\
\
\cf3 //feedback\cf0 \
a.source = \{ \cf4 SinOsc\cf0 .ar(a.ar * 7000 * \cf4 LFNoise1\cf0 .kr(1, 0.3, 0.6) + 200, 0, 0.1) \};\
a.source = \{ \cf4 SinOsc\cf0 .ar(a.ar * 6000 * \cf4 MouseX.kr(0, 2)\cf0  + [100, 104], 0, 0.1) \};\
\
\
\cf3 //adding nodes\cf0 \
a.add(\{ \cf4 SinOsc\cf0 .ar([50, 390]*1.25, 0, 0.1) \});\
a.add(\{ \cf4 BrownNoise\cf0 .ar([0.02,0.02]) \});\
\
\cf3 //setting nodes at indices:\cf0 \
a[1] = \{ \cf4 LFPulse\cf0 .kr(3, 0.3) * \cf4 SinOsc\cf0 .ar(500, 0, 0.1) \};\
a[2] = \{ \cf4 LFPulse\cf0 .kr(3.5, 0.3) * \cf4 SinOsc\cf0 .ar(600, 0, 0.1) \};\
\
\cf3 //replacing input\cf0 \
a[2] = \{ \cf4 ReplaceOut\cf0 .ar(a.index, a.ar * \cf4 SinOsc\cf0 .ar(100)) \};\
a[2] = \{ \cf4 ReplaceOut\cf0 .ar(a.index, a.ar(2) * \cf4 MouseY\cf0 .kr(0,1)) \};\
a[2] = \{ \cf4 ReplaceOut\cf0 .ar(a.index, a.ar(2) * \cf4 MouseY\cf0 .kr(0,1)) \};\
\
\
\
\cf3 //setting controls\cf0 \
a.fadeTime = 2.0;\
a.source = \{ \cf4 arg\cf0  f=400; \cf4 SinOsc\cf0 .ar(f * [1,1.2] * rrand(0.9, 1.1), 0, 0.1) \};\
a.set(\cf5 \\f\cf0 , rrand(900, 300));\
a.set(\cf5 \\f\cf0 , rrand(1500, 700));\
a.xset(\cf5 \\f\cf0 , rrand(1500, 700)); \cf3 //crossfaded setting\cf0 \
a.source = \{ \cf4 arg\cf0  f=400; \cf4 RLPF\cf0 .ar(\cf4 Pulse\cf0 .ar(f * [1,1.02] * 0.05, 0.5, 0.2), f * 0.58, 0.2) \};\
\
\cf3 //control lags\
\cf0 a.fadeTime = 0.01;\
a.lag(\\f, 0.5); \cf3 //the objects are built again internally and sent to the server.\
\cf0 a.set(\cf5 \\f\cf0 , rrand(1500, 700));\
a.unlag(\\f);\
a.set(\cf5 \\f\cf0 , rrand(1500, 700));\
a.fadeTime = 1.0;\
\
\cf3 //mapping controls to other node proxies\
\cf0 c = \cf4 NodeProxy.control\cf0 (s, 2);\
c.source = \{ \cf4 SinOsc\cf0 .kr([10,20] * 0.1, 0, 150, 1300) \};\
a.map(\cf5 \\f\cf0 , c);\
a[0] = \{ \cf4 arg\cf0  f=400; \cf4 RHPF\cf0 .ar(\cf4 Pulse\cf0 .ar(f * [1,1.2] * 0.05, 0.5, 0.2), f * 0.58, 0.2) \};\
c.source = \{ \cf4 SinOsc\cf0 .kr([10,16] * 0.02, 0, 50, 700) \};\
c.source = \{ \cf4 Line\cf0 .kr(300, 1500, 10) + \cf4 SinOsc\cf0 .kr(20 * [1,2], 0, 100) \};\
a[1] = \{ \cf4 arg\cf0  f; \cf4 LFPar\cf0 .ar(f % \cf4 MouseX\cf0 .kr(1, 40, 1) * 4 + 360, 0, 0.2) \};\
\
\cf3 //map to multiple node proxies\cf0 \
a.source = \{ \cf4 arg\cf0  f=400, f2=400; \cf4 LPF\cf0 .ar(\cf4 Pulse\cf0 .ar(f * [0.4,1], 0.2, 0.2), f2 * 3) \};\
a.map([\cf5 \\f\cf0 ,\cf5 \\f2\cf0 ], c); \cf3 //same as a.map([0,1], c); \cf0 \
a.source = \{ \cf4 arg\cf0  f=400, f2=400; \cf4 LPF\cf0 .ar(\cf4 Pulse\cf0 .ar([f, f2], 0.2, 0.2), f2) \};\
a.source = \{ \cf4 arg\cf0  f=400, f2=400; \cf4 Formant\cf0 .ar(140, [f, f2]*1.5, 100, 0.1)  \};\
c.source = \{ \cf4 SinOsc\cf0 .kr([\cf4 Line\cf0 .kr(1, 30, 10), 1], 0, [100, 700], [300, 700]) \};\
c.source = 400;\
\
\
c.fadeTime = 5.5;\
c.source = \{ \cf4 LFNoise0\cf0 .kr([2.3, 1.0], [100, 700], [300, 1700]) \};\
c.source = \{ \cf4 SinOsc\cf0 .kr([2.3, 1.0], 0, [100, 700], [300, 1700]) \};\
c.source = 400;\
\cf3 \
\
//behave like a sc2 plug\
\cf0 c.gate(1400, 0.1);\
c.gate(1000, 0.1);\
c.line(1000, 1);\cf3 \
\
//direct access\
\cf0 a.lineAt(\cf5 \\f\cf0 , 300, 2);\
a.xlineAt(\cf5 \\f\cf0 , 600, 0.3);\
a.gateAt(\cf5 \\f\cf0 , 1600, 0.3);\
\cf3 \
\
//changing nodeMaps\cf0 \
a.unmap(\cf5 \\f\cf0 );\
n = a.nodeMap.copy;\
n.set(\cf5 \\f\cf0 , 700);\
a.fadeToMap(n);\
n = a.nodeMap.copy;\
n.set(\cf5 \\f\cf0 , 400);\
a.fadeTime = 1.0;\
a.fadeToMap(n, [\cf5 \\f\cf0 ]); \cf3 //linear interpolation to new map: experimental\cf0 \
a.map(\cf5 \\f\cf0 , c); \cf3 //restore mapping\
\
\
//sending envelopes (up to 8 levels)\cf0 \
w = Env.new(Array.rand(3, 400, 1000),Array.rand(2, 0.3, 0.001), -4);\
c.env(w);\
c.env(w);\
w = Env.new(Array.rand(8, 400, 1000),Array.rand(7, 0.03, 0.1));\
c.env(w);\cf3 \
\
//stop synthesis, then wake up proxies:\
\cf0 \
a.stop; \cf3 //stop the monitor\cf0 \
a.play; \cf3 //start the monitor\cf0 \
a.free;	\cf3 //release the synths\cf0 \
x.free;\
c.free;\
a.stop;\
\
\
\cf3 //prepend args: removed.\
\cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul channel offset/object index
\f2\fs18 \ulnone \
\
a = \cf4 NodeProxy\cf0 .audio(s,2);\
a.play;\
a[0] = \{ \cf4 Ringz\cf0 .ar(\cf4 Impulse\cf0 .ar(5, 0, 0.1), 1260) \};\
a.put(1, \{ \cf4 Ringz\cf0 .ar(\cf4 Impulse\cf0 .ar(5.3, 0, 0.1), 420) \}, 1);\
a.put(0, \{ \cf4 Ringz\cf0 .ar(\cf4 Dust\cf0 .ar([1,1]*15.3,  0.1), 720) \}, 1);\
a.put(1, \{ \cf4 Ringz\cf0 .ar(\cf4 Impulse\cf0 .ar(5.3, 0, 0.1), 420) \}, 1);\
a.release;\
\

\f0\fs24 \ul beat accurate playing\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \ulnone \
\
a = \cf4 NodeProxy\cf0 .audio(s,2);\
a.play;\
\cf3 \
\cf0 a.clock = \cf4 TempoClock\cf0 (2.0); \cf3 //round to every 2.0 seconds\
\cf0 a.source = \{ \cf4 Ringz\cf0 .ar(\cf4 Impulse\cf0 .ar(0.5, 0, 0.3), 3000, 0.01) \};\
a[1] = \{ \cf4 Ringz\cf0 .ar(\cf4 Impulse\cf0 .ar([0.5, 1], 0, 0.3), 1000, 0.01) \};\
a[2] = \{ \cf4 Ringz\cf0 .ar(\cf4 Impulse\cf0 .ar([3, 5]/2, 0, 0.3), 8000, 0.01) \};\
a[3] = \{ \cf4 Ringz\cf0 .ar(\cf4 Impulse\cf0 .ar([3, 5]*16, 0, 0.3), 5000, 0.01) * LFPulse.kr(0.5, 0, 0.05) \};\
\
a.removeLast;\
a.removeAt(1);\
\
a.clear;\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul using patterns - event streams
\f2\fs18 \cf3 \ulnone \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
\
\
(\
\cf3 //must have 'out' or 'i_out' argument to work properly\cf0 \
\cf4 SynthDef\cf0 (\cf6 "who"\cf0 , \{ \cf4 arg\cf0  freq, gate=1, out=0, ffreq=800; \
	\cf4 var\cf0  env;\
	env = \cf4 Env\cf0 .asr(0.01, 0.1, 0.5);\
	\cf4 Out\cf0 .ar(out, \cf4 Pan2\cf0 .ar(\
		\cf4 Formant\cf0 .ar(freq, ffreq, 300, \cf4 EnvGen\cf0 .kr(env, gate, doneAction:2)), \cf4 Rand\cf0 (-1.0, 1.0))\
	)\
\}).send(s);\
)\
\
\
(\
a = \cf4 NodeProxy\cf0 .audio(s, 2);\
a.fadeTime = 2;\
a.play; \cf3 //monitor output\cf0 \
b = \cf4 NodeProxy\cf0 .audio(s,2);\
)\
\
\cf3 //play the pattern silently in b\cf0 \
b.source = \cf4 Pbind\cf0 (\cf5 \\instrument\cf0 , \cf5 \\\cf6 who\cf0 , \cf5 \\freq\cf0 , 500, \\legato, 0.02);\
\
\cf3 //play b out through a:\cf0 \
a.source = b;\
\
\cf3 //filter b with ring modulation:\cf0 \
a.source = \{  b.ar  * \cf4 SinOsc\cf0 .ar(\cf4 SinOsc\cf0 .kr(0.2, 300, 330))  \}; \cf3 //filter the input of the pattern\
\cf0 a.source = \{  b.ar * \cf4 LFCub\cf0 .ar([2, \cf4 8], add: -0.5\cf0 )  \}; \cf3 //filter the input of the pattern\cf0 \
\
a.source = b;\
\
\cf3 //map b to another proxy\cf0 \
c = \cf4 NodeProxy\cf0 .control(s, 1).fadeTime_(1);\
c.source = \{ \cf4 SinOsc\cf0 .kr(2, 0, 400, 700) \};\
b.map(\cf5 \\ffreq\cf0 , c);\
c.source = \{ \cf4 SinOsc\cf0 .kr(\cf4 SinOsc\cf0 .kr(0.2, 0, 10, 10), 0, 400, 700) \};\
\
c.source = \{ \cf4 LFNoise1\cf0 .kr(5, 1300, 1500) \};\
c.source = \{ \cf4 MouseX.kr(\cf0 100, 5500, 1) \};\
\
(\
b.source = \cf4 Pbind\cf0 (\
			\cf5 \\instrument\cf0 , \cf5 \\who\cf0 , \
			\cf5 \\freq\cf0 , \cf4 Pseq\cf0 ([600, 390, 300],\cf4 inf\cf0 ),\
			\cf5 \\legato\cf0 , 0.1,\
			\cf5 \\dur\cf0 , \cf4 Pseq\cf0 ([1, 0.5, 0.75, 0.125]*0.25, \cf4 inf\cf0 )\
		);\
)\
\
\cf3 //remove the mapping\cf0 \
b.unmap(\cf5 \\ffreq\cf0 );\
\
\
b[2] = \cf4 Pbind\cf0 (\cf5 \\instrument\cf0 , \cf5 \\who\cf0 , \cf5 \\freq\cf0 , 620, \cf5 \\legato\cf0 , 0.1, \\dur, 0.1);\
b[3] = \cf4 Pbind\cf0 (\cf5 \\instrument\cf0 , \cf5 \\who\cf0 , \cf5 \\freq\cf0 , \cf4 Pseq\cf0 ([720, 800, 900, 1000],\cf4 inf\cf0 ), \cf5 \\legato\cf0 , 0.1, \\dur, 0.1);\
b[4] = \cf4 Pbind\cf0 (\cf5 \\instrument\cf0 , \cf5 \\who\cf0 , \cf5 \\freq\cf0 , \cf4 Pseq\cf0 ([700, 400],\cf4 inf\cf0 ), \cf5 \\legato\cf0 , 0.1);\
b[1] = \{ \cf4 WhiteNoise\cf0 .ar([0.01,0.01]) \}; \
b[4] = \{ \cf4 arg\cf0  ffreq=800; \cf4 Resonz\cf0 .ar(\cf4 WhiteNoise\cf0 .ar([1,1]), ffreq, 0.05) \}; \
\
\
b.map(\cf5 \\ffreq\cf0 , c);\
b.removeLast;\
b.removeLast;\
a.source = \{  b.ar * \cf4 WhiteNoise.ar(0.1, 1)\cf0   \}; \
a.source = \{  b.ar * \cf4 WhiteNoise\cf0 .ar(0.1, 1) + (b.ar * \cf4 SinOsc\cf0 .ar(\cf4 SinOsc\cf0 .kr(0.01, 0, 50, 330)))  \}; \
\
c.source = \{ \cf4 XLine\cf0 .kr(1900, 10, 10) \};\
\
a.clear; c.clear; \cf3 //clear all, free bus\cf0 \
\cf4 \
\
\
\
}