{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica;\f1\fswiss\fcharset77 Helvetica-Bold;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red0\green0\blue191;\red191\green0\blue0;
\red0\green115\blue0;\red191\green0\blue0;\red0\green0\blue191;\red0\green115\blue0;\red96\green96\blue96;
\red96\green96\blue96;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \
NodeProxy (ProxySynthDef) looks for inner envelopes in your definition function\
to find out whether 
\f1\b a fade envelope is needed or not
\f0\b0 . in case there is no other inner\
possibility of freeing the synth, either \
\
a) 	a fade envelope is created (audio / control rate output)\
\
b) 	the synth is freed directly with no fading (scalar output or doneAction 1)\
\
c) 	if you provide a gate arg and a doneAction 2 to your ugenGraph function, this is supposed\
	to be a fade envelope for the synth\
\
d) 	if a synthdef name is used, case c) is supposed\
\
e) 	own responsibility:\
	if the function creates a ugengraph that can be freed by trigger or other things, it \
	waits for this action instead of freeing the synth. 
\fs26 \

\f2\fs18 \cf2 \
\
p = \cf3 ProxySpace\cf2 .push(s.boot);\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 ~out.play;\cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 \

\f1\b\fs26 \cf0 a) automatic fade envelope generation
\f2\b0\fs18 \cf2 \
\
\
\cf4 // no inner envelope and audio / control rate output\cf2 \
(\
~out = \{ \cf3 PinkNoise\cf2 .ar([1,1]*0.1) \};\
)\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 (\
~kout = \{ \cf3 PinkNoise\cf2 .kr([1,1]*0.1) \};\
)\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b\fs26 \cf0 b) automatic free instead of crossfade\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs18 \cf2 \
\cf4 // inner envelope that cannot free the synth, the synth is freed when a new \cf2 \
\cf4 // function is assigned. ??\cf2 \
(\
~out = \{ \cf3 arg\cf2  t_trig; \cf3 EnvGen\cf2 .kr(\cf3 Env\cf2 .asr, t_trig) * \cf3 PinkNoise\cf2 .ar([1,1]) \};\
)\
~out.group.set(\cf5 \\t_trig\cf2 , 1);\
\
(\
~out = \{ \cf3 arg\cf2  t_trig; \cf3 EnvGen\cf2 .kr(\cf3 Env\cf2 .asr, t_trig) * \cf3 SinOsc\cf2 .ar([1,1]*400) \};\
)\
~out.group.set(\cf5 \\t_trig\cf2 , 1);\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf6 // for a scalar output also no fade env is created, but the synth is freed (without fading)\cf0 \
(\
~out = \{ \cf7 Out\cf0 .ar(0, \cf7 SinOsc\cf0 .ar(\cf7 Rand\cf0 (440,550),0,0.2)) \};\
)\cf2 \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b\fs26 \cf0 c) custom fade envelope
\f2\b0\fs18 \cf2 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 // when a gate arg is provided, and the env can free the synth, this envelope\cf2 \
\cf4 // is supposed to be the fade envelope for the synth: no extra fade env is created.\cf2 \
(\
~out = \{ \cf3 arg\cf2  gate=1; \cf3 EnvGen\cf2 .kr(\cf3 Env\cf2 .asr, gate, doneAction:2) * 0.2 * \cf3 SinOsc\cf2 .ar([1,1]*\cf7 Rand\cf0 (440,550)\cf2 ) \};\
)\
\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b\fs26 \cf0 d) SynthDef name assignment
\f2\b0\fs18 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf6 // if a symbol is used as input, the defname of a def on the server is supposed\cf0 \
\cf6 // to represent a SynthDef that has a gate, an out input and can free itself.\cf0 \
(\
~out = \cf8 \\default\cf0 ;\
)\
\
\cf6 // this is the minimal requirement arguments for such a use (similar to Pbind)\cf0 \
(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf7 SynthDef\cf0 (\cf9 "test"\cf0 , \{ \cf7 arg\cf0  gate=1, out;\
	\cf7 Out\cf0 .ar(out, \cf7 Formant\cf0 .ar(300, 200, 10) * \cf7 EnvGen\cf0 .kr(\cf7 Env\cf0 .asr, gate, doneAction:2))\
\}).send(s);\
)\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf6 // you can also provide a fadeTime arg, whic is set by the proxy:\cf0 \
(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf7 SynthDef\cf0 (\cf9 "test"\cf0 , \{ \cf7 arg\cf0  gate=1, out, fadeTime=1;\
	\cf7 Out\cf0 .ar(out, \
		\cf7 Formant\cf0 .ar(Rand(20,40), 600, 10, 0.2) \
		* \cf7 EnvGen\cf0 .kr(\cf7 Env\cf0 .asr(fadeTime,1,fadeTime), gate, doneAction:2)\
	)\
\}).send(s);\
)\
\
~out = \\test;\
~out.fadeTime = 3;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 // if the synthdef has a fixed duration envelope, there is a FAILURE /n_set Node not found message.\cf2 \
\cf4 // with no further significance\cf2 \
(\cf3 \
Sy\cf2 n\cf3 thDef\cf2 (\cf10 "test"\cf2 , \{ \cf3 arg\cf2  gate=1, out;\
	\cf3 Out\cf2 .ar(out, \
		\cf3 Formant\cf2 .ar(\cf3 Rand\cf2 (20,40), 600, 10, 0.6) \
		* \cf3 EnvGen\cf2 .kr(\cf3 Env\cf2 .perc, gate, doneAction:2)\
	)\
\}).send(s);\
)\
\cf0 \
~out = \\test;\
~out.spawner(1);\
~out.gspawner(1);\
\cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b\fs26 \cf0 e) own free responsibility
\f2\b0\fs18 \cf2 \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 //inner envelope that can free the synth, no extra fade env is created:\cf2 \
(\
~out = \{ \cf3 arg\cf2  t_trig; \cf3 EnvGen\cf2 .kr(\cf3 Env\cf2 .asr, t_trig, doneAction:2) * \cf3 PinkNoise\cf2 .ar([1,1]) \};\
)\
~out.group.set(\cf5 \\t_trig\cf2 , 1); \cf4 //end it\cf2 \
\
~out.send; \cf4 //start a new synth\cf2 \
~out.group.set(\cf5 \\t_trig\cf2 , 1); \cf4 //end it again\cf2 \
\
\
\cf4 // if there is a ugen that can free the synth, no extra fade env is created either,\cf2 \
\cf4 // but it supposes the synth frees itself, so if a new function is assigned it does\cf2 \
\cf4 // not get freed.\cf2 \
(\
~out = \{  \cf3 arg t_trig\cf2 ;\
	\cf3 FreeSelf\cf2 .kr(\cf7 t_trig\cf2 );\
	\cf7 PinkNoise\cf0 .ar([1,1]*0.3);\cf2 \
\};\
)\
\cf0 ~out.group.set(\cf8 \\t_trig\cf0 , 1);\cf2 \
\
\
\
\
\
}