{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fnil\fcharset77 Monaco;\f2\fswiss\fcharset77 Helvetica;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red191\green0\blue0;\red0\green115\blue0;
\red0\green0\blue191;\red0\green115\blue0;\red0\green0\blue191;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 MultiChannelEventHatch			
\fs24 create  bundles from event\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs18 \cf2 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 \
uses the currentEnvironment to retrieve osc  bundles.\
it does multichannel expansion, so any value that is an array gets unfolded into a list of flat arrays\
\
its main use is 
\f0\b PolyPlayer
\f2\b0  but it could be used for other ends too.\
 if used in an Event, ~finish should be called before.\
\
see also 
\f0\b EventHatch
\f2\b0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 MultiChannelEventHatch has only class methods.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf2 	\
	
\f0\b\fs24 \cf0 *newSynthMsg
\f1\b0\fs18 \cf2 \
			
\f2\fs24 \cf0 create a "/s_new" bundle list: the server must be given (~server), as nodeIDs are created\
			for each voice.
\f1\fs18 \cf2  \
	\
	
\f0\b\fs24 \cf0 *setBundle(nodeIDs)
\f2\b0 \
			create a "/n_set" bundle list: the argument names must be given in ~argNames\
	\
	
\f0\b *mapBundle(nodeIDs)
\f2\b0 \
			create a "/n_map" bundle list: the argument names must be given in ~mapNames\
\

\f1\fs18 \cf2 \
\
\cf3 // examples:\
\
\cf2 s = Server.local;\
s.boot;\
\
(\
\
~server = s;\
~instrument = \cf4 \\default\cf2 ;\
z = \cf5 MultiChannelEventHatch\cf2 .newSynthMsg;\
z.postln;\
s.listSendBundle(0.1, z);\
)\
\
s.freeAll;\
\
// start new synths\
\cf0 (\
~server = s;\
~instrument = \cf6 \\default\cf0 ;\
~argNames = [\cf6 \\freq\cf0 , \cf6 \\amp, \\pan\cf0 ];\
~freq = [300, 200, 990, 300.1];\
~amp = [0.1, 0.2, 0.1];\
~pan = [0, -1, 1];\
z = \cf7 MultiChannelEventHatch\cf0 .newSynthMsg;\
z.asCompileString.postln;\
s.listSendBundle(0.1, z);\
)\
\cf2 \
// set the synth controls\
\cf0 (\
var ids;\
~server = s;\
~argNames = [\cf6 \\freq\cf0 ];\
~freq = [300, 200, 990, 300.1] - 50;\
ids = z.collect(\{ arg item; item.at(2) \});\
j = \cf7 MultiChannelEventHatch\cf0 .setBundle(ids);\
j.asCompileString.postln;\
s.listSendBundle(0.1, j);\
)\
\
\cf2 \
// map the synths to buses\
(\
var ids;\
s.sendMsg("/c_setn", 0, 3, 500, 700, 300);\
~mapNames = [\\freq];\
~freq = [0, 1, 2];\
\cf0 ids\cf2  = z.collect(\{ arg item; item.at(2) \});\
j = \cf7 MultiChannelEventHatch.mapBundle(ids);\
\cf0 j.asCompileString.postln;\cf7 \
\cf0 s.listSendBundle(0.1, j);\cf2 \
)\
\
\cf0 s.sendBundle(nil, ["/c_setn", 0, 3] ++ Array.rand(3,  500, 700));\cf2 \
\cf0 s.sendBundle(nil, ["/c_setn", 0, 3] ++ Array.rand(3,  500, 700));\
s.sendBundle(nil, ["/c_setn", 0, 3] ++ Array.rand(3,  500, 700));\cf2 \
\
\cf3 //return to unmapped values\cf2 \
(\
\cf5 var\cf2  ids;\
~mapNames = [\cf4 \\freq\cf2 ];\
~freq = [-1,-1,-1];\
ids = z.collect(\{ \cf5 arg\cf2  item; item.at(2) \});\
j = \cf5 MultiChannelEventHatch\cf2 .mapBundle(ids);\
j.asCompileString.postln;\
s.listSendBundle(0.1, j);\
)\
\
s.freeAll;\
\
\
}