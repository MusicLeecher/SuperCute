{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fnil\fcharset77 Futura-Medium;\f1\fswiss\fcharset77 Helvetica-Bold;\f2\fnil\fcharset77 Monaco;
\f3\fswiss\fcharset77 Helvetica;\f4\fnil\fcharset77 LucidaGrande;}
{\colortbl;\red255\green255\blue255;\red163\green146\blue90;\red191\green0\blue0;\red0\green0\blue191;
\red0\green115\blue0;\red0\green0\blue0;\red191\green0\blue0;\red0\green115\blue0;\red0\green0\blue191;
\red96\green96\blue96;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs40 \cf0 ProxySpace 		
\f1\b\fs24 an environment of references on a server 
\f2\b0\fs18 \
\

\f1\b\fs24 superclass: EnvironmentRedirect \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs18 \cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs24 \cf0 Generally a proxy is a placeholder for something, which in this case \
is something playing on a server that writes to a limited number of busses.\
(this can be for example a synth or an event stream)\
\
\
When accessed, ProxySpace returns a [
\f1\b NodeProxy
\f3\b0 ]. \
\
The rate is determined in a lazy way from the first object put into this environment. \
Once it is created it can only be set to a function that returns the same rate and a number \
of channels equal to the intial one or smaller. (see 
\f1\b the_lazy_proxy
\f3\b0  
\f4 )\

\f3 \
if the ugen function's number of channels is smaller, the offset in 'put' can be used to offset the ugens\
if the number of channels is larger, the outputs will wrap around and mix accordingly.\
\
note that the two expressions are equivalent: \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 ~out = something; 
\f3\fs24   \

\f2\fs18 currentEnvironment.put(\\out, something);\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs24 \cf0 \
a proxyspace can be created when its server is not running and played later.\
\
see also: [
\f1\b NodeProxy
\f3\b0 ][
\f1\b jitlib_efficiency
\f3\b0 ]\
\
\
				
\f2\fs18 \cf2 \'a5\'a5\'a5\'a5\cf0 this is experimental and things change.\cf2 \'a5\'a5\'a5\'a5\
				\
				
\f3\fs24 \cf0 \
Note:\
The following examples can be executed line by line, usually in any order. \
code that should be evaluated together is set in parentheses.
\f2\fs18 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs26 \cf0 \ul class methods
\f2\fs18 \ulnone \
\
\

\f1\b\fs26 *new(server, name, clock)
\f2\b0\fs18 \
	\
	
\f1\b\fs24 server
\f3\b0 : 	a Server object. note that on remote computers the clock must be in sync\
	
\f1\b name
\f3\b0 : 	a symbol. if a name is given, the proxy space is stored in ProxySpace.all under this name.\
	
\f1\b clock
\f3\b0 : 	for event-based or beat-sync playing use specific clocks (like TempoClock)
\f2\fs18 \
	\

\f1\b\fs26 *push(server, name, clock)
\f2\b0\fs18 \
	\
			
\f3\fs24 replace the currentEnvironment with a new ProxySpace. \
			if it is current already, it is left where it is.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b\fs26 \cf0 *pop
\f2\b0\fs18 \
			
\f3\fs24 restore the previous currentEnvironment
\f0 \
\
\
\

\f3\fs26 \ul instance methods\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ulnone \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b \cf0 play(key)
\f2\b0\fs18 \
			
\f3\fs24 returns a group that plays the NodeProxy at that key. \
			default key: \\out
\f0 \
\

\f1\b record(key, path, headerFormat, sampleFormat)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs18 \cf0 	\
			
\f3\fs24 returns a RecNodeProxy that records the NodeProxy at that key
\fs26 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b\fs24 \cf0 ar(key, numChannels)\
kr(key, numChannels)
\f2\b0\fs18 \
	\
			
\f3\fs24 returns a NodeProxy output that plays the NodeProxy at that key.
\f0 \
\

\f1\b wakeUp
\f0\b0 	
\f3\fs26 \
			
\fs24 when the proxyspace is created without a running server this method can be used\
			to run it (internally this is done by play(key) as well.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0 \cf0 	\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b \cf0 fadeTime_
\f3\b0 	set the fadetime of all proxies as well as the default fade time\
\

\f1\b free
\f3\b0 			free all proxies\
\

\f1\b clear
\f3\b0 		clear the node proxy and remove it from the environment\
\

\f1\b release
\f3\b0 		release all proxies\
\

\f1\b *clearAll
\f3\b0 		clear all registered spaces
\f2\fs18 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs26 \cf0 ____________________________________________________
\f2\fs18 \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul \
preparation of the environment\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf3 \ulnone \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 (\
s = \cf4 Server\cf0 .local;\
s.boot;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 p = ProxySpace\cf0 .push(s);\
)\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul playing and monitoring
\f2\fs18 \ulnone \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 // play some output to the hardware busses, this could be any audio rate key.\cf0 \
x = ~out.play; \cf3 // returns a group, store in interpreter variable x\cf0 \
~out = \{ \cf4 SinOsc\cf0 .ar([400, 500]*0.9, 0, 0.2) \};\
\
\cf3 // replacing the node. the crossfade envelope is created internally.\cf0 \
~out = \{ \cf4 SinOsc\cf0 .ar([430, 600-Rand(0,200)], 0, 0.2) \};\
~out = \{ \cf4 Resonz\cf0 .ar(\cf4 Saw\cf0 .ar(30+[0,0.2], 1), [1200, 1600], 0.1) + \cf4 SinOsc\cf0 .ar(60*[1,1.1],0,0.2) \};\
~out = \{ \cf4 Pan2\cf0 .ar(\cf4 PinkNoise\cf0 .ar(0.1), \cf4 LFClipNoise\cf0 .kr(2)) \};\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul setting the node controls\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \ulnone \
~out = \{ \cf4 arg\cf0  rate=2; \cf4 Pan2\cf0 .ar(\cf4 PinkNoise\cf0 .ar(0.1), \cf4 LFClipNoise\cf0 .kr(rate)) \};\
~out.set(\cf5 \\rate\cf0 , 50);\
~out = \{ \cf4 arg\cf0  rate=2; \cf4 Pan2\cf0 .ar(\cf4 Dust\cf0 .ar(2000, 0.2), \cf4 LFClipNoise\cf0 .kr(rate)) \};\
~out.set(\cf5 \\rate\cf0 , 2);\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul mapping node controls\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \ulnone \
~lfo = \{ \cf4 LFNoise2\cf0 .kr(30, 300, 500) \};\
~out = \{ \cf4 SinOsc\cf0 .ar(~lfo.kr, 0, 0.15)  \};\
~out = \{ \cf4 SinOsc\cf0 .ar(~lfo.kr * [1, 1.2], 0, 0.1) * \cf4 Pulse\cf0 .ar(~lfo.kr * [0.1, 0.125], 0.5) \};\
~lfo = \{ \cf4 LFNoise1\cf0 .kr(30, 40) + \cf4 SinOsc\cf0 .kr(0.1, 0, 200, 500) \};\
~out = \{ \cf4 SinOsc\cf0 .ar(~lfo.kr * [1, 1.2], 0, 0.1)  \};\
~lfo = 400;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul \
math
\f2\fs18 \ulnone \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 // unary operators\cf0 \
~lfo2 = \{ \cf4 SinOsc\cf0 .kr(0.5, 0, 600, 100)  \};\
~lfo = ~lfo2.abs;\
~lfo2 = \{ \cf4 SinOsc\cf0 .kr(1.1, 0, 600, 100)  \};\
\
\
\cf3 // binary operators\cf0 \
~lfo3 = \{ \cf4 LFTri\cf0 .kr(0.5, 0, 80, 300) \};\
~lfo = ~lfo2 + ~lfo3;\
~lfo = ~lfo3;\
~lfo = (~lfo3 / 50).sin * 200 + 500 * \{ \cf4 LFTri\cf0 .kr(~lfo.kr * 0.5, 0, 0.1 * ~lfo3.kr / 200, 1) \};\
~lfo3 = \{ \cf4 Mix\cf0 (~lfo2.kr * [1, 1.2]) \};\
\
currentEnvironment.free; \cf3 // free all node proxies\cf0 \
~out.stop; \cf3 // free the playback synth: eqivalent: x.free\cf0 \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul waking up a network of proxies
\f3\fs26 \ulnone \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 // hit cmd-. to stop all nodes\cf0 \
\cf3 // start again\cf0 \
~out.play; \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul feeding back\ulnone  (one buffer size delay)
\f3\fs26 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \
~out = \{ \cf4 SinOsc\cf0 .ar([220, 330], ~out.ar(2).reverse * \cf4 LFNoise2\cf0 .kr(0.5, 2*pi), 0.4) \};\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 // supercollider 'differential equations'\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
~out = \{ \cf4 SinOsc\cf0 .ar(\cf4 Slope\cf0 .ar(~out.ar) * \cf4 MouseX\cf0 .kr(1000, 18000, 1)) * 0.1 + \cf4 SinOsc\cf0 .ar(500, 0, 0.1) \};\
\
(\
~out = \{ \cf4 var\cf0  z, zz;\
	z = \cf4 Slope\cf0 .ar(~out.ar);\
	zz = \cf4 Slope\cf0 .ar(z);\
	\cf4 SinOsc\cf0 .ar(210, z) *\
	\cf4 SinOsc\cf0 .ar(zz * 410) \
	* 0.1 + \cf4 Decay2\cf0 .ar(Pan2.ar(\cf4 Dust\cf0 .ar(15), MouseX.kr(-1,1)), 0.01, 1.5);\
\}\
)\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul multiple control
\f2\fs18 \ulnone \
\
(\
~out = \{ \cf4 arg\cf0  freqOffest;\
	\cf4 var\cf0  ctl;\
	ctl = \cf4 Control\cf0 .names(\cf5 \\array\cf0 ).kr(\cf4 Array\cf0 .rand(8, 400, 1000));\
	Pan2.ar(\cf4 Mix\cf0 (\cf4 SinOsc\cf0 .ar(ctl + freqOffest, 0, 0.1)), LFNoise0.kr(2))\
\};\
)	\
\
~out.setn(\cf5 \\array\cf0 , \cf4 Array\cf0 .exprand(8, 400, 2000));\
~out.set(\cf5 \\freqOffest\cf0 , 200);\
~out.map(\cf5 \\freqOffest\cf0 , ~lfo);\
~out.setn(\cf5 \\array\cf0 , \cf4 Array\cf0 .exprand(8, 400, 2000));\
\
\
\

\f0\fs24 \ul mixing
\f2\fs18 \ulnone \
\
\
~out1 = \{ \cf4 SinOsc\cf0 .ar(600, 0, 0.1) \};\
~out2 = \{ \cf4 SinOsc\cf0 .ar(500, 0, 0.1) \};\
~out3 = \{ \cf4 SinOsc\cf0 .ar(400, 0, 0.1) \};\
~out = ~out2 + ~out1 + ~out3;\
\
~out = ~out1 + ~out2;\
~out = ~out1;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 // another way is:\cf0 \
~out = \{ \cf4 SinOsc\cf0 .ar(600, 0, 0.1) \};\
~out.add(\{ \cf4 SinOsc\cf0 .ar(500, 0, 0.1) \});\
~out.add(\{ \cf4 SinOsc\cf0 .ar(400, 0, 0.1) \});\
\
\cf3 // or with direct access:\cf0 \
~out[1] = \{ \cf4 SinOsc\cf0 .ar(500 * 1.2, 0, 0.1) \};\
~out[2] = \{ \cf4 SinOsc\cf0 .ar(400 * 1.2, 0, 0.1) \};\
\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul restoring / erasing
\f3\fs26 \ulnone \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \
~out.free; \cf3 // this frees the group, not the play synth x\cf0 \
~out.send; \cf3 // this resends the first synth\
\cf0 ~out.free; \
~out.sendAll; \cf3 // this resends all synths\
\
// removing:\cf0 \
~out.removeLast;\
~out.removeAt(0);\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 // cleaning up:\cf0 \
~out.clear; \cf3 // this neutralizes the proxy, and frees its bus\cf0 \
\
\
\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul execution order
\f3\fs26 \ulnone \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 // you can .play .kr or .ar also a name that is not yet used.\cf0 \
\cf3 // the rate is guessed as far as possible. on this topic see also: [the_lazy_proxy]\cf0 \
\
~myOut.play; \cf3 // play some key (audio rate is assumed)\cf0 \
\
\cf3 // the rate is determined from the first access: \cf0 \
\cf3 // like this ~lfo becomes control rate\cf0 \
\
~myOut = \{ \cf4 SinOsc\cf0 .ar(~freq.kr * 2, 0, 0.1) \}; \
~freq = 900;\
~freq = \{ \cf4 SinOsc\cf0 .kr(115, 0, 70, 220) \}\
\
~myOut = \{ \cf4 SinOsc\cf0 .ar(~otherFreq.ar * 2, 0, 0.1) \};\
~otherFreq = \{ \cf4 SinOsc\cf0 .ar(115, 0, 70, 220) \};\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf6 \
currentEnvironment.clear; \cf7 // clear every  proxy in this environment.\cf6 \
\
\cf0 \
\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul setting arguments and mapping
\f2\fs18 \ulnone \
\
\
~out.play;\
\
~out = \{ \cf4 arg\cf0  freq=500, ffreq=120; \cf4 SinOsc\cf0 .ar(freq*[1,1.1], \cf4 SinOsc\cf0 .ar(ffreq, 0, pi), 0.2) \};\
~out.set(\cf5 \\freq\cf0 , 400+100.rand2);\
~out.set(\cf5 \\freq\cf0 , 400+100.rand2);\
~out.set(\cf5 \\ffreq\cf0 , 30+20.rand2);\
~out.unset(\cf5 \\freq\cf0 , \cf5 \\ffreq\cf0 );  \cf3 // remove the setting\cf0 \
~out.set(\cf5 \\ffreq\cf0 , 30+10.rand2, \cf5 \\freq\cf0 , 500 + 200.rand2);\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf6 \
\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 // argument settings and mappings are applied to every new function\cf0 \
~out = \{ \cf4 arg\cf0  freq=100, ffreq=20; \cf4 SinOsc\cf0 .ar(freq*[1,1.1], \cf4 SinOsc\cf0 .ar(ffreq, 0, pi), 0.2) \};\
\
\cf3 // mapping to other proxies\cf0 \
~lfo = \{ \cf4 SinOsc\cf0 .kr(0.3, 0, 80, 100) \};\
~out.map(\cf5 \\ffreq\cf0 , ~lfo);\
\
~out = \{ \cf4 arg\cf0  freq=300, ffreq=20; \cf4 Pulse\cf0 .ar(freq*[1,1.1]+ \cf4 SinOsc\cf0 .ar(ffreq, 0, freq), 0.3, 0.1) \};\
~out = \{ \cf4 arg\cf0  freq=300, ffreq=20; \cf4 BPF\cf0 .ar(\cf4 LFSaw\cf0 .ar(ffreq*[1,1.1], 0, 1), freq, 0.2) \};\
\
~lfo = \{ \cf4 FSinOsc\cf0 .kr(3, 0, 30, 200) \};\
~out = \{ \cf4 arg\cf0  freq=300, ffreq=20; \cf4 SinOsc\cf0 .ar(freq*[1,1.1], \cf4 SinOsc\cf0 .ar(ffreq, 0, pi), 0.1) \};\
\
\
\cf3 // crossfaded setting and mapping\cf0 \
~out.fadeTime = 2;\
~out.xset(\cf5 \\freq\cf0 , 9000);\
~out.xset(\cf5 \\freq\cf0 , rrand(400, 700));\
\
~lfo = \{ \cf4 FSinOsc\cf0 .kr(0.1, 0, 30, 100) \};\
~lfo2 = \{ \cf4 LFClipNoise\cf0 .kr(3, 100, 200) \};\
~lfo3 = \cf4 StreamKrDur\cf0 (\cf4 Pseq\cf0 ([\cf4 Prand\cf0 ([530, 600],1), 700, 400, 800, 500], \cf4 inf\cf0 ) / 3, 0.2);\
\
~out.xmap(\cf5 \\ffreq\cf0 , ~lfo2);\
~out.xmap(\cf5 \\ffreq\cf0 , ~lfo);\
~out.xmap(\cf5 \\ffreq\cf0 , ~lfo3);\
\
\cf3 // special argument names: trigger inputs\cf0 \
~out = \{ \cf4 arg\cf0  t_trig, dt=1; \cf4 Decay2\cf0 .kr(t_trig, 0.01, dt) * \cf4 Mix\cf0 (\cf4 SinOsc\cf0 .ar(7000*[1.2, 1.3, 0.2])) \}\
\
\
\cf3 // set the group, so the node proxy does not store it\cf0 \
~out.group.set(\cf5 \\t_trig\cf0 , 0.1, \\dt, 0.1); \
~out.group.set(\cf5 \\t_trig\cf0 , 0.4, \\dt, 0.31);\
~out.group.set(\cf5 \\t_trig\cf0 , 0.13, \\dt, 2);\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf7 // lagging controls:\cf6 \
~out.lag(\cf8 \\xfreq\cf6 , 1);\
(\
~out = \{ \cf9 arg\cf6  t_trig, dt=1, xfreq=700; \
	\cf9 Decay2\cf6 .kr(t_trig, 0.01, dt) * \cf9 Mix\cf6 (\cf9 SinOsc\cf6 .ar(xfreq*[1.2, 1.3, 0.2])) \
\};\
)\
~out.group.set(\cf8 \\t_trig\cf6 , 0.1, \cf8 \\dt\cf6 , 1, \cf8 \\xfreq\cf6 , rrand(2000,9000)); \cf0 \
~out.group.set(\cf5 \\t_trig\cf0 , 0.1, \cf5 \\dt\cf0 , 0.5, \cf5 \\xfreq\cf0 , rrand(2000,9000)); \
~out.group.set(\cf5 \\t_trig\cf0 , 0.1, \cf5 \\dt\cf0 , 1, \cf5 \\xfreq\cf0 , rrand(2000,9000)); \
\cf6 \
\cf7 // changing the lag, the synth is reconstructed with the new lag:\
\cf6 \
~out.lag(\cf8 \\xfreq\cf6 , 0.1);\
~out.group.set(\cf8 \\t_trig\cf6 , 0.1, \cf8 \\dt\cf6 , 1, \cf8 \\xfreq\cf6 , rrand(2000,9000)); \
\cf0 \
\
\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul setting the xfade time
\f2\fs18 \ulnone \
\
\
~out.fadeTime = 4;\
~out = \{ \cf4 SinOsc\cf0 .ar(Rand(800, 300.0)*[1,1.1], 0, 0.1) \};\
~out = \{ \cf4 SinOsc\cf0 .ar(Rand(800, 300.0)*[1,1.1], 0, 0.1) \};\
~out.fadeTime = 0.01;\
~out = \{ \cf4 SinOsc\cf0 .ar(Rand(800, 300.0)*[1,1.1], 0, 0.1) \};\
~out.fadeTime = 2;\
~out.release;  // release the synths in the group\
~out.fadeTime = 0.01;\
~out.stop;\
\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs26 \cf0 ___________________________________________________________________\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs32 \cf0 other possible inputs\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs26 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul using a synthdef as input\ulnone  (see also: jitlib_fading)\ul \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \ulnone \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 // you have the responsibility for the right number of channels and output rate\cf0 \
\cf3 // you have to supply an 'out' argument so it can be mapped to the right channel.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
~out = \cf4 SynthDef\cf0 (\cf10 "w"\cf0 , \{ \cf4 arg\cf0  out=0; \cf4 Out\cf0 .ar(out,\cf4 SinOsc\cf0 .ar([\cf4 Rand\cf0 (430, 600), 600], 0, 0.2)) \});\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 // once the SynthDef is sent, it can be assigned by name. \
// using this method, a \ul gate argument\ulnone  should be \
// provided that releases the synth. (doneAction:2)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 (\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 SynthDef\cf0 (\cf10 "staub"\cf0 , \{ \cf4 arg\cf0  out, gate=1; \
	\cf4 Out\cf0 .ar(out, \cf4 Ringz\cf0 .ar(\cf4 Dust\cf0 .ar(15), 9000*[1,1], 0.001) * \cf4 EnvGen\cf0 .kr(\cf4 Env\cf0 .asr, gate, doneAction:2)) \
\}).send(s);\
)\
\
~out = \\staub;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 // if you supply a gate it fades in and out. evaluate this several times\cf0 \
(\
~out = \cf4 SynthDef\cf0 (\cf10 "w"\cf0 , \{ \cf4 arg\cf0  out=0, gate=1.0; \
	\cf4 Out\cf0 .ar(out,\
		\cf4 SinOsc\cf0 .ar([\cf4 Rand\cf0 (430, 800), \cf4 Rand\cf0 (430, 800)], 0, 0.2) * \cf4 EnvGen\cf0 .kr(\cf4 Env\cf0 .asr(1,1,1), gate, doneAction:2)\
	) \
	\});\
)\
\
\cf3 // if you supply an envelope that frees itself, no bundle is sent to free it\cf0 \
(\
~out = \cf4 SynthDef\cf0 (\cf10 "w"\cf0 , \{ arg out, lfo;\
	\cf4 Out\cf0 .ar(out,\
		\cf4 SinOsc\cf0 .ar([\cf4 Rand\cf0 (430, 800), \cf4 Rand\cf0 (430, 800)]+lfo, 0, 0.2) * \cf4 EnvGen\cf0 .kr(\cf4 Env\cf0 .perc(0.01, 0.03), doneAction:2)\
	) \
	\});\
)\
\
~out.gspawner(0.01);\
~out.freeTask;\
\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul using instruments and players
\f2\fs18 \ulnone \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 // this is also useful for writing instruments\cf0 \
(\
~out = \cf4 Instr\cf0 (\cf5 \\test\cf0 , \
		\{ \cf4 arg\cf0  dens=520, ffreq=2000; \cf4 Ringz\cf0 .ar(\cf4 Dust\cf0 .ar(dens, [1,1]*0.1), ffreq * 5, 0.01) \}\
		);\
)\
~out.set(\cf5 \\dens\cf0 , 120);\
~out.xset(\cf5 \\dens\cf0 , 1030); \cf3 // does not work yet.\cf0 \
~out.unmap(\\ffreq);\
\
\cf3 // wait for a more general interface with cx lib, this works already \cf0 \
~out = \cf4 Patch\cf0 ([\cf5 \\test\cf0 ], [10]);\
\cf3 // set the unassigned parameter does not work currently.\cf0 \
~out.set(\cf5 \\ffreq\cf0 , 500);\
\
\
// problems here still (doesn't work yet)\
(\
~out = \cf4 InstrSpawner\cf0 (\{ \cf4 arg\cf0  freq=900,env,pan;\
	\cf4 Pan2\cf0 .ar(\cf4 SinOsc\cf0 .ar(freq, 0, 0.3) * \cf4 EnvGen\cf0 .kr(env,doneAction: 2), pan)\
\},[\
	\cf4 Prand\cf0 ([1500, 700, 800, 700], \cf4 inf\cf0 ),\
	\cf4 Env\cf0 .perc(0.02,0.04),\
	\cf4 Prand\cf0 ([0,1],\cf4 inf\cf0 )\
],0.125)\
)\
\
~out.clear;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs26 \cf0 \
\
___________________________________________________________________\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs32 \cf0 client side routines
\fs26 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul spawning\ulnone  
\f3\fs26 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \
~out.play;\
~out.awake = false; \cf3 // allow sound object assignment without immediate sending\cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 // putting an synthdef into the node proxy without playing it right away\cf0 \
\cf3 // the synthdef has an envelope that frees by itself.\cf0 \
(\
~out = SynthDef("a", \{ \cf4 arg\cf0  out=0, freq=800, pmf=1.0;\
		\cf4 var\cf0  env;\
		env = \cf4 EnvGen\cf0 .kr(\cf4 Env\cf0 .perc(0.001, 0.04, 0.4),doneAction:2); \cf3 // envelope\cf0 \
		Out.ar(out, \cf4 SinOsc\cf0 .ar(freq * \cf4 Rand\cf0 (0.9, 1.1), \cf4 SinOsc\cf0 .ar(pmf, 0, pi), env))\
	\})\
);\
\
\
\cf3 // create a task to repeatedly send grains\cf0 \
(\
t = Task.new(\{\
	loop(\{\
		\cf3 // starts a synth with the current synthdef at index 0\cf0 \
		~out.spawn([\cf5 \\pmf\cf0 , [1, 20, 300].choose]); \
		[0.1, 0.01, 0.25].choose.wait;\
	\})\
\});\
)\
\
t.start;\
t.stop;\
t.start;\
\
\cf3 // set some argument\cf0 \
~out.set(\cf5 \\freq\cf0 , 300);\
~out.set(\cf5 \\freq\cf0 , 600);\
~out.map(\cf5 \\freq\cf0 , ~lfo);\
~lfo = \{ SinOsc.kr(0.1, 0, 3000, 4000) \};\
~lfo = \{ SinOsc.kr(0.1, 0, 600, 700) \};\
~lfo.add(\{ Trig.kr(Dust.kr(1), 0.1) * 3000 \});\
~lfo = 300;\
\
\cf3 // change the definition while going along\cf0 \
(\
~out = SynthDef("a", \{ \cf4 arg\cf0  out, freq=800;\
		\cf4 var\cf0  env;\
		env = \cf4 EnvGen\cf0 .kr(\cf4 Env\cf0 .perc(0.01, 0.1, 0.3),doneAction:2);\
		Out.ar(out, \cf4 Pulse\cf0 .ar(freq * \cf4 Rand\cf0 (0.9, 1.1), 0.5, env) )\
	\});\
)\
)\
\
\
t.stop;\
~out.awake = \cf4 true\cf0 ; \cf3 // don't forget this\cf0 \
\cf3 //  free all synths in this current ProxySpace\cf0 \
currentEnvironment.free;\
x.free;
\f3\fs26 \
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul granular synthesis: efficient code
\f3\fs26 \ulnone \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs24 \cf0 see also [jitlib_efficiency]
\f2\fs18 \
\
~out.play;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs26 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 (\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 SynthDef\cf0 (\cf10 "grain"\cf0 , \{ \cf4 arg\cf0  i_out = 0;\
	\cf4 var\cf0  env;\
	env = \cf4 EnvGen\cf0 .kr(\cf4 Env\cf0 .perc(0.001, 0.003),doneAction:2);\
	\cf4 Out\cf0 .ar(i_out, \cf4 FSinOsc\cf0 .ar(\cf4 Rand\cf0 (1000,10000),0,0.1) * env) \
\}).send(s);\
)
\f3\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 // a target for the grains\cf0 \
~someInput.ar(2);  \cf3 // initialize to 2 channels audio\cf0 \
~out = ~someInput;\
\
(\
t = \cf4 Task\cf0 (\{\
	loop(\{\
		s.sendMsg(\cf10 "/s_new"\cf0 ,\cf10 "grain"\cf0 ,-1,0,0, \
			\cf5 \\i_out\cf0 , ~someInput.index \cf3 // returns the bus index of the proxy\cf0 \
		);  \
		[0.01, 0.02].choose.wait;\
	\})\
\});\
)\
t.play;\
\
\cf3 // different filters;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 ~out.fadeTime = 1.0;\
\
~out = \{ \cf4 BPF\cf0 .ar(~someInput.ar, \cf4 MouseX\cf0 .kr(100, 18000, \cf5 1\cf0 ), 0.1) \};\
\
~out = \{ \cf4 CombL\cf0 .ar(~someInput.ar * (\cf4 LFNoise0\cf0 .ar(2) > 0), 0.2, 0.2, \cf4 MouseX\cf0 .kr(0.1, 5, 1)) \};\
\
~out = \{ \cf4 RLPF\cf0 .ar(~someInput.ar, \cf4 LFNoise1\cf0 .kr(3, 1000, 1040), 0.05) \};\
\
\
t.stop;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 // a similar thing can be done using gspawner:\cf0 \
\cf3 // (this might still change. helpfile to come.)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
~someInput = \cf5 \\grain\cf0 ;\
~someInput.gspawner(\cf4 Prand\cf0 ([0.01,0.02],\cf4 inf\cf0 ));\
\
\
~someInput.freeTask;\
\
//_________\
\
~out.stop;\
currentEnvironment.clear;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 ProxySpace\cf0 .pop; \cf3 // restore original environment
\f3\fs26 \cf0 \
\
\
\
________________________________________________________________________\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul using multiple proxyspaces\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \ulnone note that this can be done while the server is not running: with p.wakeUp or p.play\
the environment can be played back.\ul \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs26 \cf0 \ulnone \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \
p = \cf4 ProxySpace\cf0 (s);\
q = \cf4 ProxySpace\cf0 (s);\
\
(\
p.use(\{\
	~out = \{ \cf4 Resonz\cf0 .ar(~in.ar, ~freq.kr, 0.01) \};\
	~in = \{ \cf4 WhiteNoise\cf0 .ar(0.5) \};\
	~freq = \{ \cf4 LFNoise2\cf0 .kr(1, 1000, 2000) \};\
\});\
)\
\
x = p.play(\cf5 \\out\cf0 ); \cf3 // play the proxy at \\out\cf0 \
\
(\
q.use(\{\
	\
	~in = \{ \cf4 Dust\cf0 .ar(20, 0.1) \};\
	~out = \{ \cf4 Resonz\cf0 .ar(~in.ar * 450, ~freq.kr, 0.005) \};\
	~freq = \{ \cf4 LFNoise2\cf0 .kr(1, 400, 2000) \};\
\});\
)\
\
y = q.play; \cf3 // out is the default output\cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul external access\ulnone \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \
\
q[\\in][1] = \{ Impulse.ar(2, 0, 0.5) \}; \cf3 // adding a synth at index 1\cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 // equivalent to\cf0 \
q.at(\\in).put(1, \{ Impulse.ar(2, 0, 0.5) \});\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \ulnone \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul connecting two spaces\ulnone  (must be on one server)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \
\
(\
q.use(\{\
	~freq =  100 + p.at(\cf5 \\freq\cf0 ) / 2;\
\})\
)\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul recording output\ulnone  (see also: [RecNodeProxy])
\f2\fs18 \
\
\
r = p.record(\cf5 \\out\cf0 , \cf10 "proxySpace12.aiff"\cf0 );\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 // start recording\cf0 \
r.unpause;\
\
\cf3 // pause recording\cf0 \
r.pause;\
\
\cf3 // stop recording\cf0 \
r.close;\
\
\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul push/pop\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \ulnone \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 // make x the currentEnvironment\cf0 \
p.push; \
\
~freq = 700;\
~freq = 400;\
~freq = \{ p.kr(\cf5 \\freq\cf0 ) + 300 \}; // feedback\
~freq = 400;\
\
p.pop; \cf3 // restore environment\cf0 \
\
\
\cf3 // make y the currentEnvironment\cf0 \
q.push; \
\
~freq = 1000;\
~in = \{ \cf4 WhiteNoise\cf0 .ar(0.01) \};\
\
q.pop; \cf3 // restore environment\cf0 \
\
q.clear;\
p.clear;\
\
\
\
\
}