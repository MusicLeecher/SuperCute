{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fnil\fcharset77 Futura-Medium;\f1\fnil\fcharset77 Monaco;\f2\fswiss\fcharset77 Helvetica-Bold;
\f3\fswiss\fcharset77 Helvetica;}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue191;\red96\green96\blue96;
\red191\green0\blue0;\red0\green115\blue0;\red0\green0\blue0;\red0\green0\blue191;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs40 \cf0 ProxySpace
\f1\fs18 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul superclass:\ulnone  EnvironmentRedirect \
an environment of references on a server 
\f1\fs18 \
\
Generally a proxy is a placeholder for something, which in this case \
is something playing on a server that writes to a limited number of busses.\
(this can be for example a synth or an event stream)\
\
\
When accessed, ProxySpace returns a [NodeProxy]. \
The rate is determined in a lazy way from the first object\
put into this environment. Once it is created it can only be set to a function\
that returns the same rate and a number of channels equal to the intial one or smaller. \
\
~out = something; is equivalent to currentEnvironment.put(\\out, something);\
\
a proxyspace can be created when its server is not running and played later.\
\
Note:\
The following examples can be executed line by line, usually in any order. \
code that should be evaluated together is set in parentheses.\
this is experimental and things change.\
\
\

\f2\b\fs26 *new(server, name, clock)
\f1\b0\fs18 \
	
\f0\fs24 server: a Server object. note that on remote computers the clock must be in sync\
	name: a symbol (can be used for access)\
	clock: for event-based or beat-sync playing use specific clocks (like TempoClock)
\f1\fs18 \
	\

\f2\b\fs26 *push(server, name, clock)
\f1\b0\fs18 \
	
\f0\fs24 replace the currentEnvironment with a new ProxySpace
\f1\fs18 \
	\

\f2\b\fs26 *pop
\f1\b0\fs18 \
	
\f0\fs24 restore the previous currentEnvironment\
\

\f2\b\fs26 play(key)
\f1\b0\fs18 \
	
\f0\fs24 returns a group that plays the NodeProxy at that key. default key: \\out\
\

\f2\b\fs26 record(key, path, headerFormat, sampleFormat)
\f1\b0\fs18 \
	
\f0\fs24 returns a RecNodeProxy that records the NodeProxy at that key
\f3\fs26 \
\

\f2\b ar(key, numChannels)\
kr(key, numChannels)
\f1\b0\fs18 \
	
\f0\fs24 returns a NodeProxy output that plays the NodeProxy at that key.\
\

\f2\b\fs26 wakeUp
\f0\b0\fs24 	
\f3\fs26 \
	
\f0\fs24 when the proxyspace is created without a running server this method can be used\
	to run it (internally this is done by play(key) as well.
\f1\fs18 \

\f3\fs26 ____________________________________________________
\f1\fs18 \
\
\

\f0\fs24 \ul \
preparation of the environment\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf2 \ulnone \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 (\
s = \cf3 Server\cf0 .local;\
s.boot;\
\cf3 p = ProxySpace\cf0 .push(s);\
)\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul playing and monitoring
\f1\fs18 \ulnone \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 //play some output to the hardware busses, this could be any audio rate key.\cf0 \
x = ~out.play; \cf2 //returns a group, store in interpreter variable x\cf0 \
~out = \{ \cf3 SinOsc\cf0 .ar([400, 500]*0.9, 0, 0.2) \};\
\
\cf2 //replacing the node\cf0 \
~out = \{ \cf3 SinOsc\cf0 .ar([430, 600-200.rand], 0, 0.2) \};\
~out = \{ \cf3 Resonz\cf0 .ar(\cf3 Saw\cf0 .ar(30+[0,0.2], 1), [1200, 1600], 0.1) + \cf3 SinOsc\cf0 .ar(60*[1,1.1],0,0.2) \};\
~out = \{ \cf3 Pan2\cf0 .ar(\cf3 PinkNoise\cf0 .ar(0.1), \cf3 LFClipNoise\cf0 .kr(2)) \};\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul using a synthdef as input\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 \ulnone \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 //you have the responsibility for the right number of channels and output rate\cf0 \
\cf2 //you have to supply an 'out' argument so it can be mapped to the right channel.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
~out = \cf3 SynthDef\cf0 (\cf4 "w"\cf0 , \{ \cf3 arg\cf0  out=0; \cf3 Out\cf0 .ar(out,\cf3 SinOsc\cf0 .ar([\cf3 Rand\cf0 (430, 600), 600], 0, 0.2)) \});\
\
\cf5 //once the SynthDef is sent, it can be assigned by name:\
\cf3 SynthDef\cf0 (\cf4 "\cf0 staub\cf4 "\cf0 , \{ \cf3 arg\cf0  out=0; \cf3 Out\cf0 .ar(out, \cf3 Pan2.ar(Ringz.ar(Dust.ar(15), 900, 0.01\cf0 )\cf3 ,0\cf0 )) \}).send(s);\
\
~out = \\staub;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 //if you supply a gate it fades in and out. evaluate this several times\cf0 \
(\
~out = \cf3 SynthDef\cf0 (\cf4 "w"\cf0 , \{ \cf3 arg\cf0  out=0, gate=1.0; \
	\cf3 Out\cf0 .ar(out,\
		\cf3 SinOsc\cf0 .ar([\cf3 Rand\cf0 (430, 800), \cf3 Rand\cf0 (430, 800)], 0, 0.2) * \cf3 EnvGen\cf0 .kr(\cf3 Env\cf0 .asr(1,1,1), gate, doneAction:2)\
	) \
	\});\
)\
\
\cf2 //a SoundDef is more efficient, as it is sent on creation and no def has to be written\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 SoundDef\cf0 (\cf6 \\service\cf0 , \{ \cf3 arg\cf0  out; \cf3 Out\cf0 .ar(out, \cf3 PinkNoise\cf0 .ar([0.1, 0.1])) \});\
\cf3 SoundDef\cf0 (\cf6 \\problem\cf0 , \{ \cf3 arg\cf0  out; \cf3 Out\cf0 .ar(out, \cf3 GrayNoise\cf0 .ar([0.1, 0.1])) \});\
~out = \cf3 SoundDef\cf0 (\cf6 \\service\cf0 );\
~out = \cf3 SoundDef\cf0 (\cf6 \\problem\cf0 );\
~out = \cf3 SoundDef\cf0 (\cf6 \\service\cf0 );\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul setting the node controls\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 \ulnone \
~out = \{ \cf3 arg\cf0  rate=2; \cf3 Pan2\cf0 .ar(\cf3 PinkNoise\cf0 .ar(0.1), \cf3 LFClipNoise\cf0 .kr(rate)) \};\
~out.set(\cf6 \\rate\cf0 , 50);\
~out = \{ \cf3 arg\cf0  rate=2; \cf3 Pan2\cf0 .ar(\cf3 Dust\cf0 .ar(2000, 0.2), \cf3 LFClipNoise\cf0 .kr(rate)) \};\
~out.set(\cf6 \\rate\cf0 , 2);\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul mapping node controls\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 \ulnone \
~lfo = \{ \cf3 LFNoise2\cf0 .kr(30, 300, 500) \};\
~out = \{ \cf3 SinOsc\cf0 .ar(~lfo.kr, 0, 0.15)  \};\
~out = \{ \cf3 SinOsc\cf0 .ar(~lfo.kr * [1, 1.2], 0, 0.1) * \cf3 Pulse\cf0 .ar(~lfo.kr * [0.1, 0.125], 0.5) \};\
~lfo = \{ \cf3 LFNoise1\cf0 .kr(30, 60) + \cf3 SinOsc\cf0 .kr(0.1, 0, 100, 500) \};\
~out = \{ \cf3 SinOsc\cf0 .ar(~lfo.kr * [1, 1.2], 0, 0.1)  \};\
~lfo = 400;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul \
math
\f1\fs18 \ulnone \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 //unary operators\cf0 \
~lfo2 = \{ \cf3 SinOsc\cf0 .kr(0.5, 0, 600, 100)  \};\
~lfo = ~lfo2.abs;\
~lfo2 = \{ \cf3 SinOsc\cf0 .kr(1.1, 0, 600, 100)  \};\
\
\
\cf2 //binary operators\cf0 \
~lfo3 = \{ \cf3 LFTri\cf0 .kr(0.5, 0, 80, 300) \};\
~lfo = ~lfo2 + ~lfo3;\
~lfo = ~lfo3;\
~lfo = (~lfo3 / 50).sin * 200 + 500;\
\
currentEnvironment.free; \cf2 //free all node proxies\cf0 \
~out.stop; \cf2 //free the playback synth: eqivalent: x.free\cf0 \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul waking up a network of proxies
\f3\fs26 \ulnone \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 //hit cmd-. to stop all nodes\cf0 \
\cf2 //start again\cf0 \
~out.play; \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul feeding back\ulnone  (one buffer size delay)
\f3\fs26 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 \
~out = \{ \cf3 SinOsc\cf0 .ar([220, 330], ~out.ar(2).reverse * \cf3 LFNoise2\cf0 .kr(0.5, 2*pi), 0.4) \};\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul multiple control
\f1\fs18 \ulnone \
\
(\
~out = \{ \cf3 arg\cf0  freqOffest;\
	\cf3 var\cf0  ctl;\
	ctl = \cf3 Control\cf0 .names(\cf6 \\array\cf0 ).kr(\cf3 Array\cf0 .rand(8, 400, 1000));\
	\cf3 Mix\cf0 (\cf3 SinOsc\cf0 .ar(ctl + freqOffest, 0, 0.1))\
\};\
)	\
\
~out.setn(\cf6 \\array\cf0 , \cf3 Array\cf0 .exprand(8, 400, 2000));\
~out.set(\cf6 \\freqOffest\cf0 , 200);\
~out.map(\cf6 \\freqOffest\cf0 , ~lfo);\
~out.setn(\cf6 \\array\cf0 , \cf3 Array\cf0 .exprand(8, 400, 2000));\
\
\
\

\f0\fs24 \ul mixing
\f1\fs18 \ulnone \
\
\
~out1 = \{ \cf3 SinOsc\cf0 .ar(600, 0, 0.1) \};\
~out2 = \{ \cf3 SinOsc\cf0 .ar(500, 0, 0.1) \};\
~out3 = \{ \cf3 SinOsc\cf0 .ar(400, 0, 0.1) \};\
~out = ~out2 + ~out1 + ~out3;\
\
~out = ~out1 + ~out2;\
~out = ~out1;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 //another way is:\cf0 \
~out = \{ \cf3 SinOsc\cf0 .ar(600, 0, 0.1) \};\
~out.add(\{ \cf3 SinOsc\cf0 .ar(500, 0, 0.1) \});\
~out.add(\{ \cf3 SinOsc\cf0 .ar(400, 0, 0.1) \});\
\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul restoring / erasing
\f3\fs26 \ulnone \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 \
~out.free; \cf2 //this frees the group, not the play synth x\cf0 \
~out.send; \cf2 //this resends the last synth\
\cf0 ~out.free; \
~out.sendAll; \cf2 //this resends all synths\
\
//removing:\cf0 \
~out.removeLast;\
~out.removeAt(0);\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 //cleaning up:\cf0 \
~out.clear; \cf2 //this neutralizes the proxy, and frees its bus\cf0 \
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul execution order
\f3\fs26 \ulnone \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 //you can .play .kr or .ar also a name that is not yet used.\cf0 \
\cf2 //the rate is guessed as far as possible.\cf0 \
\
~myOut.play; \cf2 //play some key (audio rate is assumed)\cf0 \
\
\cf2 //the rate is determined from the first access: \cf0 \
\cf2 //like this ~lfo becomes control rate\cf0 \
\
~myOut = \{ \cf3 SinOsc\cf0 .ar(~freq.kr * 2, 0, 0.1) \}; \
~freq = 900;\
~freq = \{ \cf3 SinOsc\cf0 .kr(115, 0, 70, 220) \}\
\
~myOut = \{ \cf3 SinOsc\cf0 .ar(~otherFreq.ar * 2, 0, 0.1) \};\
~otherFreq = \{ \cf3 SinOsc\cf0 .ar(115, 0, 70, 220) \};\
\
currentEnvironment.clear;\
\
\cf2 //note that you cannot really use an audio rate function/player as input for \cf0 \
\cf2 //a control rate proxy nor the other way round. You can call kr and ar on\cf0 \
\cf2 //any proxy.\cf0 \
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul setting arguments and mapping
\f1\fs18 \ulnone \
\
\
~out.play;\
\
~out = \{ \cf3 arg\cf0  freq=500, ffreq=20; \cf3 SinOsc\cf0 .ar(freq*[1,1.1], \cf3 SinOsc\cf0 .ar(ffreq, 0, pi), 0.2) \};\
~out.set(\cf6 \\freq\cf0 , 400+100.rand2);\
~out.set(\cf6 \\ffreq\cf0 , 3+10.rand2);\
~out.unset(\cf6 \\freq\cf0 , \cf6 \\ffreq\cf0 );  \cf2 //remove the setting\cf0 \
~out.set(\cf6 \\ffreq\cf0 , 3+10.rand2, \cf6 \\freq\cf0 , 300);\
~out = \{ \cf3 arg\cf0  t_trig; \cf3 Decay2\cf0 .kr(t_trig, 0.01, 0.2) * \cf3 Mix\cf0 (\cf3 SinOsc\cf0 .ar(7000*[1.2, 1.3, 0.2])) \}\
\
~out.set(\cf6 \\t_trig\cf0 , 0.1);\
~out.set(\cf6 \\t_trig\cf0 , 0.4);\
~out.set(\cf6 \\t_trig\cf0 , 0.13);\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 //argument settings and mappings are applied to every new function\cf0 \
~out = \{ \cf3 arg\cf0  freq=100, ffreq=20; \cf3 BPF\cf0 .ar(\cf3 LFSaw\cf0 .ar(ffreq*[1,1.1], 0, 1), freq, 0.2) \};\
~out = \{ \cf3 arg\cf0  freq=100, ffreq=20; \cf3 SinOsc\cf0 .ar(freq*[1,1.1], \cf3 SinOsc\cf0 .ar(ffreq, 0, pi), 0.2) \};\
\
\cf2 //mapping to other proxies\cf0 \
~lfo = \{ \cf3 SinOsc\cf0 .kr(0.3, 0, 80, 100) \};\
~out.map(\cf6 \\ffreq\cf0 , ~lfo);\
\
~out = \{ \cf3 arg\cf0  freq=100, ffreq=20; \cf3 Pulse\cf0 .ar(freq*[1,1.1]+ \cf3 SinOsc\cf0 .ar(ffreq, 0, freq), 0.3, 0.1) \};\
~lfo = \{ \cf3 FSinOsc\cf0 .kr(3, 0, 30, 200) \};\
~out = \{ \cf3 arg\cf0  freq=100, ffreq=20; \cf3 SinOsc\cf0 .ar(freq*[1,1.1], \cf3 SinOsc\cf0 .ar(ffreq, 0, pi), 0.1) \};\
\
\
\cf2 //crossfaded setting and mapping\cf0 \
~out.fadeTime = 2;\
~out.xset(\cf6 \\freq\cf0 , 9000);\
~out.xset(\cf6 \\freq\cf0 , rrand(400, 700));\
~lfo = \{ \cf3 FSinOsc\cf0 .kr(0.1, 0, 30, 100) \};\
~lfo2 = \{ \cf3 LFClipNoise\cf0 .kr(3, 100, 200) \};\
~lfo3 = \cf3 StreamKrDur\cf0 (\cf3 Pseq\cf0 ([\cf3 Prand\cf0 ([530, 600],1), 700, 400, 800, 500], \cf3 inf\cf0 ) / 3, 0.2);\
\
~out.xmap(\cf6 \\ffreq\cf0 , ~lfo2);\
~out.xmap(\cf6 \\ffreq\cf0 , ~lfo);\
~out.xmap(\cf6 \\ffreq\cf0 , ~lfo3);\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul using instruments and players
\f1\fs18 \ulnone \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 //this is also useful for writing instruments\cf0 \
(\
~out = \cf3 Instr\cf0 (\cf6 \\test\cf0 , \
		\{ \cf3 arg\cf0  dens=20, freq=2000; \cf3 Ringz\cf0 .ar(\cf3 Dust\cf0 .ar(dens), freq, 0.01) \}\
		);\
)\
~out.set(\cf6 \\dens\cf0 , 2, \cf6 \\freq\cf0 , 9000);\
\
\
\cf2 //wait for a more general interface with cx lib, this works already \cf0 \
~out = \cf3 Patch\cf0 ([\cf6 \\test\cf0 ], [10]);\
\cf2 //set the unassigned parameter\cf0 \
~out.set(\cf6 \\freq\cf0 , 5000);\
~out.stop;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf7 \
\cf0 \
(\cf7 \
~out = \cf8 InstrSpawner\cf7 (\{ \cf8 arg\cf7  freq=900,env;\
	\cf8 SinOsc\cf7 .ar(freq, 0, 0.3) * \cf8 EnvGen\cf7 .kr(env,doneAction: 2)\
\},[\
	\cf8 Prand\cf7 ([1500, 700, 800, 700], \cf8 inf\cf7 ),\
	\cf8 Env\cf7 .perc(0.02,0.04)\
\
],0.125);\
)\
\cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul use within players
\f1\fs18 \ulnone \
\
(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 Instr\cf0 (\cf6 \\filter\cf0 , \{ \cf3 arg\cf0  in, freq;\
	\cf3 HPF\cf0 .ar(in, 8000)\
\}, [\cf6 \\audio\cf0 ]);\
)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 //note that this contradicts the loadability of players\cf0 !\
c = \cf3 Patch\cf0 (\cf6 \\filter\cf0 , [ \cf3 Patch\cf0 (\{ ~out.ar \}) ]);\
\
c.gui;\
~out.set(\cf6 \\freq\cf0 , 8000);\
\
c.stop;\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul setting the xfade time
\f1\fs18 \ulnone \
\
~out.fadeTime = 4;\
~out.play;\
~out = \{ \cf3 SinOsc\cf0 .ar(rrand(800, 300.0)*[1,1.1], 0, 0.1) \};\
~out = \{ \cf3 SinOsc\cf0 .ar(rrand(800, 300.0)*[1,1.1], 0, 0.1) \};\
~out.fadeTime = 0.01;\
~out = \{ \cf3 SinOsc\cf0 .ar(rrand(800, 300.0)*[1,1.1], 0, 0.1) \};\
~out.fadeTime = 2;\
~out.release;  //elease the synths in the group\
~out.fadeTime = 0.01;\
~out.stop;\
\

\f3\fs26 \
\

\f0\fs24 \ul playing multiple synths\ulnone  (more efficient than creating new defs)
\f3\fs26 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 \
~out.play;\
~out.awake = false; \cf2 //allow sound object assignment without immediate sending\cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 //putting an synthdef into the node proxy without playing it right away\cf0 \
\cf2 //the synthdef has an envelope that frees by itself.\cf0 \
(\
~out.put(\
	SynthDef("a", \{ \cf3 arg\cf0  out=0, freq=800, pmf=1.0;\
		\cf3 var\cf0  env;\
		env = \cf3 EnvGen\cf0 .kr(\cf3 Env\cf0 .perc(0.001, 0.04, 0.4),doneAction:2); \cf2 //envelope\cf0 \
		Out.ar(out, \cf3 SinOsc\cf0 .ar(freq * \cf3 Rand\cf0 (0.9, 1.1), \cf3 SinOsc\cf0 .ar(pmf, 0, pi), env))\
	\}));\
)\
\
\cf2 //create a task to repeatedly send grains\cf0 \
(\
t = \cf3 Task\cf0 (\{\
	loop(\{\
		~out.send([\cf6 \\pmf\cf0 , [1, 20, 300].choose]); \cf2 //starts a synth with the current synthdef\cf0 \
		[0.1, 0.1].choose.wait;\
	\})\
\});\
)\
\
t.start;\
t.stop;\
t.start;\
\
\cf2 //set some argument\cf0 \
~out.set(\cf6 \\freq\cf0 , 300);\
~out.set(\cf6 \\freq\cf0 , 600);\
~out.map(\cf6 \\freq\cf0 , ~lfo);\
~lfo = \{ SinOsc.kr(0.1, 0, 3000, 4000) \};\
~lfo = \{ SinOsc.kr(0.1, 0, 600, 700) \};\
~lfo.add(\{ Trig.kr(Dust.kr(1), 0.1) * 3000 \});\
~lfo = 300;\
\
\cf2 //change the definition while going along\cf0 \
(\
~out.put(\
	SynthDef("a", \{ \cf3 arg\cf0  out, freq=800;\
		\cf3 var\cf0  env;\
		env = \cf3 EnvGen\cf0 .kr(\cf3 Env\cf0 .perc(0.01, 0.1, 0.3),doneAction:2);\
		Out.ar(out, \cf3 Pulse\cf0 .ar(freq * \cf3 Rand\cf0 (0.9, 1.1), 0.5, env) )\
	\});\
)\
)\
\
\
t.stop;\cf7 \
~out.awake = \cf8 true\cf7 ; \cf5 //don't forget this\cf7 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf5 //free all synths in this cu\cf2 rrent ProxySpace\cf0 \
currentEnvironment.free;\
x.free;
\f3\fs26 \
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul granular synthesis: efficient coding
\f3\fs26 \ulnone \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 \
\
~out.play;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs26 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 (\
\cf3 SynthDef\cf0 (\cf4 "grain"\cf0 , \{ \cf3 arg\cf0  i_out = 0;\
	\cf3 var\cf0  env;\
	env = \cf3 EnvGen\cf0 .kr(\cf3 Env\cf0 .perc(0.001, 0.003),doneAction:2);\
	\cf3 Out\cf0 .ar(i_out, \cf3 FSinOsc.ar(Rand(1000,10000),0,0.1)\cf0  * env) \
\}).send(s);\
)\
\cf7 \
\cf5 //a filter for the grains\cf0 \
~out = \{ \cf3 BPF\cf0 .ar(~someInput.ar, \cf3 MouseX\cf0 .kr(100, 18000, \cf6 'exponential'\cf0 ), 0.1) \};\
\
(\
t = \cf3 Task\cf0 (\{\
	loop(\{\
		s.sendMsg(\cf4 "/s_new"\cf0 ,\cf4 "grain"\cf0 ,-1,0,0, \
			\cf6 \\i_out\cf0 , ~someInput.index \cf2 //returns the bus index of the proxy\cf0 \
		);  \
		[0.01, 0.02].choose.wait;\
	\})\
\});\
)\
t.play;\
\
~out = \{ CombL.ar(~someInput.ar * (LFNoise0.ar(2) > 0), 0.2, 0.2, \cf3 MouseX\cf0 .kr(0.1, 5, 'exponential')) \};\
~out = \{ R\cf3 LPF\cf0 .ar(~someInput.ar, \cf3 LFNoise1\cf0 .kr(3, 1000, 1040), 0.05) \};\
\
\
t.stop;\
~out.stop;\
currentEnvironment.clear;\
\cf3 ProxySpace\cf0 .pop; \cf2 //restore original environment
\f3\fs26 \cf0 \
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul using multiple proxyspaces\
\ulnone note that this can be done while the server is not running: with p.wakeUp or p.play\
the environment can be played back.\ul \

\f3\fs26 \ulnone \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 \
p = \cf3 ProxySpace\cf0 (s);\
q = \cf3 ProxySpace\cf0 (s);\
\
(\
p.use(\{\
	~out = \{ \cf3 Resonz\cf0 .ar(~in.ar, ~freq.kr, 0.01) \};\
	~in = \{ \cf3 WhiteNoise\cf0 .ar(0.5) \};\
	~freq = \{ \cf3 LFNoise2\cf0 .kr(1, 1000, 2000) \};\
\});\
)\
\
x = p.play(\cf6 \\out\cf0 ); \cf2 //play the proxy at \\out\cf0 \
\
(\
q.use(\{\
	~in = \{ \cf3 Dust\cf0 .ar(20, 0.1) \};\
	~out = \{ \cf3 Pan2\cf0 .ar(\cf3 Ringz\cf0 .ar(~in.ar, ~freq.kr, 0.3), \cf3 LFNoise1\cf0 .kr(0.3)) \};\
	~freq = \{ \cf3 LFNoise2\cf0 .kr(1, 100, 2000) \};\
\});\
)\
\
y = q.play; \cf2 //out is the default output\cf0 \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul \
recording output\ulnone  (see also: [RecNodeProxy])
\f1\fs18 \
\
\
r = p.record(\cf6 \\out\cf0 , \cf4 "proxySpace12.aiff"\cf0 );\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 //start recording\cf0 \
r.unpause;\
\
\cf2 //pause recording\cf0 \
r.pause;\
\
\cf2 //stop recording\cf0 \
r.close;\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul connecting two spaces\ulnone  (must be on one server)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 \
(\
q.use(\{\
	~freq = p.at(\cf6 \\freq\cf0 ) + 100;\
\})\
)\
\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf0 \ul push/pop\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 \ulnone \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 //make x the currentEnvironment\cf0 \
p.push; \
\
~freq = 700;\
~freq = 400;\
~freq = \{ q.kr(\cf6 \\freq\cf0 ) + 300 \}; //feedback\
~freq = 400;\
\
p.pop; \cf2 //restore environment\cf0 \
\
\
\cf2 //make y the currentEnvironment\cf0 \
q.push; \
\
~freq = 1000;\
~in = \{ \cf3 WhiteNoise\cf0 .ar(0.01) \};\
\
q.pop; \cf2 //restore environment\cf0 \
\
q.clear;\
p.clear;\
\
\
\
\
}