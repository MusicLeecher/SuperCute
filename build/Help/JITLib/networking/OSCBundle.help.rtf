{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fnil\fcharset77 Monaco;\f2\fswiss\fcharset77 Helvetica;
}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue0;\red191\green0\blue0;
\red0\green0\blue191;\red96\green96\blue96;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 OSCBundle	
\f1\b0\fs18 		
\f0\b\fs24 network
\f1\b0\fs18  
\f0\b\fs24 bundle object
\f2\b0 \
\
\
superclass: Object\
\
a bundle object that allows to add preparation messages for async processes.\
if this feature is not needed, a list object can be used instead.\
\
\

\f0\b *add(msg)
\f2\b0 			add a message to the bundle\
\

\f0\b *addAll(array)	
\f2\b0 		add an array of messages to the bundle\
\

\f0\b *addPrepare(msg)
\f2\b0 		add a preparation message, which is sent\
					before the bundle is sent.\
\
\
\

\f0\b send(server, latency)
\f2\b0 	send the bundle to a server.  If preparation messages are given,\
					they are sent, the process waits for their reception abd then sends the\
					bundle.\
\

\f0\b schedSend(server, clock)
\f2\b0  like send, but the sending is synced to a given clock (TempoClock) to the next beat.\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf2 // example\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
\cf3 	\cf4 // create a new, empty instance\cf3 \
	a = \cf5 OSCBundle\cf3 .new; \
	\
	\cf4 // a synthdef that needs to be sent to the server, an operation that is asynchronous,\cf3 \
	\cf4 // i.e. we have to wait until it is finished.\cf3 \
	x = \cf5 SynthDef\cf3 (\cf6 "test"\cf3 , \{\'ca\cf5 OffsetOut\cf3 .ar(0, \cf5 BPF\cf3 .ar(\cf5 Impulse\cf3 .ar(4) * 10, \cf5 Rand\cf3 (9000, 1000), 0.1)) \});\
	\cf4 // this is why addPrepare is used.\cf3 \
	a.addPrepare([\cf6 "/d_recv"\cf3 , x.asBytes]);\
	\cf4 // add is used with synchronous operations, like starting synths.\cf3 \
	a.add([\cf6 "/s_new"\cf3 , \cf6 "test"\cf3 , -1]);\
\
	\cf4 // the bundle has now the synchronous separated from the asynchronous bundles:\cf3 \
	a.messages;\
	a.preparationMessages;\
	\
	\cf4 // this can be simply sent - the bundle takes care of the server client communication\cf3 \
	\cf4 // like waiting for the synthdef to be loaded. the synth is started when the preparation\cf3 \
	\cf4 // is finished.\cf3 \
	\
	s.boot; \cf4 // boot the server\cf3 \
	a.send(s);\
\
	s.freeAll; \cf4 // free all nodes on the server\cf3 \
\
	\cf2 // scheduled sending: the synths are started on the next beat.\cf0 \
\cf3 \
	a.schedSend(s, \cf5 TempoClock\cf3 .default, 1); 	\
	a.schedSend(s, \cf5 TempoClock\cf3 .\cf0 default\cf3 , 1);		\
	a.schedSend(s, \cf5 TempoClock\cf3 .\cf0 default\cf3 , 1);\
	\
	s.freeAll; \cf4 // free all nodes on the server\cf0 \
\
	\cf2 // the bundle can contain several preparation messages and messages at a time.\cf0 \
	\cf2 // the proparationMessages are sent first and only when they are all completed,\cf0 \
	\cf2 // the other bundles are sent.\cf0 \
	\cf2 // the bundle can also be reused, if there is no specific allocated buffers/node ids.		\cf0 \
	}