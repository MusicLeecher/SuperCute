{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fnil\fcharset77 Monaco;\f2\fswiss\fcharset77 Helvetica;
}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue191;\red0\green115\blue0;
\red96\green96\blue96;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 Client				
\fs24 represents a remote sclang application
\fs36 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs18 \cf0 \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 	Client
\f2\b0  and 
\f0\b LocalClient
\f2\b0  together represent a sender / reciever pair for sclang side osc messages. \
	Using SynthDef like global function definitions, 
\f0\b ClientFunc
\f2\b0 , an sclang application \
	can evaluate code on a remote sclang app.
\f1\fs18 \
\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 \ul \ulc0 Class Methods
\fs28 \ul \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs18 \cf0 \ulnone \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 	*new(name, netAddr) \
			
\f2\b0 returns a new instance and stores it in a global dictionary\
			the port is set to defaultPort, which is hardcoded presently.\
			if no address is passed in, localhost is used.
\f1\fs18 \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 \ul Instance Methods\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs18 \cf0 \ulnone \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 	send(key, args ...)\
		
\f2\b0 evaluates a client function that is stored at that key\
	
\f0\b \
	password_ (symbol)\

\f2\b0 		set the password for interpreter access\
	\
	
\f0\b cmdName_
\f2\b0 \
		set the cmdName under which the client sends (default: 
\f0\b '/client'
\f2\b0 )\
		this cmdName must be the same like the LocalClient reciever cmdName\
	
\f0\b \
	interpret(string)\
		
\f2\b0 if the remote client has the same password, it interprets  the string
\f0\b \
\
\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs18 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 LocalClient		
\fs24 represents a listener to a remote sclang application
\fs36 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs18 \cf0 	\
	
\f0\b\fs24 superclass: Client\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs28 \cf0 \ul \
	
\f1\b0\fs18 \ulnone \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 	Note that passing a 
\f0\b nil address
\f2\b0  to LocalClient will make it respond to 
\f0\b any
\f2\b0  remote client \
	and try to match any message that is sent from a client object. \
	If it is expected to listen to a specific remote client, the address of that client should be used.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 \ul \

\fs24 \ul Instance Methods\ulnone 	
\f1\b0\fs18 \
	\
	
\f0\b\fs24 start \
		
\f2\b0 start listening to the world\
		
\f0\b \
	stop \
		
\f2\b0 stop listening to the world\
	\
	
\f0\b remove \
		
\f2\b0 remove from client list\
		
\f0\b \
	isListening \
		
\f2\b0 returns whether it is listening to the world\
		
\f0\b \
	password_ (symbol)\
		
\f2\b0 set the password for interpreter access from outside\
		\
	
\f0\b cmdName_
\f2\b0 \
		set the cmdName under which the client recieves (default: 
\f0\b '/client'
\f2\b0 )\
		this cmdName must be the same like the Client sender cmdName\
		
\f0\b \
	allowInterpret \
		
\f2\b0 open the interpreter to the world (potential hacking danger)\
		
\f0\b \
	disallow \
		
\f2\b0 close the interpreter access
\f1\fs18 \
	\
	\
	\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 ClientFunc		
\fs24 similar to SynthDef - represents a client side stored function
\f1\b0\fs18 \
	\
	
\f0\b\fs24 *new(name, func)\
		\
	
\f2\b0 global function that is accessed by LocalClient when a message is recieved.\
	the key sent is a key of the ClientFunc that is evaluated.\
	the other args are passed to the function: time, responder, args...
\f0\b \
		
\f1\b0\fs18 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 Note:
\f2\b0 \
\
	for accessing a gui element or a document from an OSCResponder such as the one \
	in LocalClient, one has to defer the action:\
	\
	ClientFunc(\\ok, \{ defer(\{ ... \}) \});
\f0\b \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs18 \cf0 \
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // example\cf0 \
\cf2 // instantiate a remote-local pair (in this case both are local of course)\cf0 \
a = \cf3 LocalClient\cf0 .default; 	\cf2 // this one listens to any remote client and evaluates the functions. \cf0 \
b = \cf3 Client\cf0 .new;		\cf2 // this one sends the messages\cf0 \
\
\cf2 // eqivalent to the above defaults:\cf0 \
a = \cf3 LocalClient\cf0 (\cf4 \\default\cf0 , \cf3 nil\cf0 ); \cf2 //addr is nil : listen to all\cf0 \
b = \cf3 Client\cf0 (\cf4 \\default\cf0 , \cf3 NetAddr\cf0 (\cf5 "127.0.0.1"\cf0 , 57120));\
\
\cf2 // store some client functions to be accessible from outside (analogous to SynthDef)\cf0 \
\cf3 ClientFunc\cf0 (\cf4 \\ok\cf0 , \{ \cf3 arg\cf0  ... args; args.postln \});\
\cf3 ClientFunc\cf0 (\cf4 \\yes\cf0 , \{ \cf3 arg\cf0  ... args; \cf4 \\ok2\cf0 .postln \});\
\
\cf2 // start the local client\cf0 \
a.start;\
\
\cf2 // send messages\cf0 \
b.send(\cf4 \\ok\cf0 , \cf5 "rrere"\cf0 , 39); \
b.send(\cf4 \\ok\cf0 , \cf5 "rrxxxre"\cf0 );\
b.send(\cf4 \\ok\cf0 , 2, 3, 4, 5, 6);\
b.send(\cf4 \\yes\cf0 , \cf5 "rrere"\cf0 , 39);\
b.send(\cf4 \\yes\cf0 );\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 opening remote interpreter access is risky, because\
anyone can access the interpreter (also unix commands)\
if you do not set the password, this is not possible.
\f1\fs18 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // open interpreter\cf0 \
a.password = \cf4 \\xyz\cf0 ;\
b.password = \cf4 \\xyz\cf0 ;\
a.allowInterpret;\
\
\cf2 // remote interpret\cf0 \
b.interpret(\cf5 " Array.fill(8, \{ [1,0].choose \}).postln "\cf0 );\
b.interpret(\cf5 " String.fill(80, \{ [$u, $n].choose \}).postln"\cf0 );\
\
\cf2 // remote GUI\cf0 \
b.interpret(\cf5 " SCWindow.new(\\"\cf0 aLl uR mAchIneZ are bEloNg to us!\\\cf5 ").front;\{ SinOsc.ar(500, 0, LFPulse.kr(4)) \}.play;"\cf0 );  \
\
\cf2 // close interpret\cf0 \
a.disallow\
\
\cf2 //test: this should not interpret\cf0 \
b.interpret(\cf5 " String.fill(8, \{ [$u, $n].choose \}).postln"\cf0 );\
\
a.stop; \cf2 //stop local responder\cf0 \
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 writing a chat
\f1\b0\fs18 \
\
\
(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // hit tab for sending\cf0 \
\cf3 var\cf0  n, d, e, b;\
n = \cf5 "John"\cf0 ;\
d = \cf3 Document\cf0 (\cf5 "chat"\cf0 ).background_(\cf3 Color\cf0 .rand).bounds_(\cf3 Rect\cf0 (30, 10, 400, 200));\
e = \cf3 Document\cf0 (\cf5 "chat-write"\cf0 ).background_(\cf3 Color\cf0 .rand).bounds_(\cf3 Rect\cf0 (30, 210, 400, 50));\
\
a = \cf3 LocalClient\cf0 .default.start; 	\
b = \cf3 Client\cf0 .new;\
\cf3 ClientFunc\cf0 (\cf4 \\chat\cf0 , \{ \cf3 arg\cf0  str; \{ d.string =  d.string ++ str ++ \cf3 "\\n"\cf0  \}.defer \});\
\
e.keyDownAction_(\{\'ca\cf3 arg\cf0  doc, char;\
	\cf3 var\cf0  string;\
	 if(char === \cf3 Char\cf0 .tab) \
	 \{ \
	 	string = n + \cf5 ":"\cf0  + e.currentLine;	 	\
	 	b.send(\cf4 \\chat\cf0 , string.copy); \
	 	\cf3 AppClock\cf0 .sched(0.1, \{ e.string = \cf5 ""\cf0  \}); \cf2 // time is the original crime. remove the tab.\cf0 \
	 \} \
\});\
e.onClose_(\{ \cf3 AppClock\cf0 .sched(0.1, \{ a.remove; d.close; \cf3 nil\cf0  \}) \}); \cf2 // sched, otherwise sc crashes\cf0 \
)\
\
}