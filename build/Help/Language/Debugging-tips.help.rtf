{\rtf1\mac\ansicpg10000\cocoartf824\cocoasubrtf100
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
\f3\fswiss\fcharset77 Helvetica-Oblique;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red0\green115\blue0;\red191\green0\blue0;
\red255\green0\blue0;\red0\green0\blue255;\red153\green102\blue51;\red0\green255\blue0;\red255\green0\blue255;
\red255\green128\blue0;\red96\green96\blue96;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs40 \cf0 Debugging tips 
\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 Debugging synthdefs \
Debugging client-to-server communication\
Debugging client code \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 Debugging synthdefs \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 \
The challenge in debugging synthdefs is the invisibility of the server's operations. There are a handful of techniques to expose the output of various UGens. \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 SendTrig / OSCresponderNode \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 \
SendTrig is originally intended to send a trigger message back to the client, so the client can take further action on the server. However, it can be used to send any numeric value back to the client, which can then be printed out. \
\
To print out the values, you need to create an OSCresponderNode as follows:\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 o = \cf2 OSCresponderNode\cf0 (myServer.addr, \cf3 '/tr'\cf0 , \{ \cf2 |time, resp, msg|\cf0  msg.postln \}).add; \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
Each line of output is an array with four values: ['/tr', defNode, id (from SendTrig), value (from SendTrig)]. \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \{	\cf2 var\cf0 	freq;\
	freq = \cf2 LFNoise1\cf0 .kr(2, 600, 800);\
		\cf4 // Impulse is needed to trigger the /tr message to be sent\cf0 \
	\cf2 SendTrig\cf0 .kr(\cf2 Impulse\cf0 .kr(4), 0, freq);\
	\cf2 SinOsc\cf0 .ar(freq, 0, 0.3) ! 2\
\}.play;\
[ /tr, 1000, 0, 1340.8098144531 ]\
[ /tr, 1000, 0, 1153.9201660156 ]\
[ /tr, 1000, 0, 966.35247802734 ]\
[ /tr, 1000, 0, 629.31628417969 ]\
\
o.remove;  \cf4 // when done, you need to clean up the OSCresponderNode\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
If you need to track multiple values, you can store them in a collection of arrays and differentiate them by assigning different IDs in the SendTrig UGen. \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 l = \{ \cf2 List\cf0 .new \} ! 2;\
o = \cf2 OSCresponderNode\cf0 (myServer.addr, \cf3 '/tr'\cf0 , \{ \cf2 |time, resp, msg|\cf0 \
		\cf4 // msg[2] is the index\cf0 \
	l[msg[2]].add(msg[3]);\
\}).add; \
\
\{	\cf2 var\cf0 	freq, amp;\
	freq = \cf2 LFNoise0\cf0 .kr(8, 600, 800);\
	amp = \cf2 LFNoise1\cf0 .kr(10, 0.5, 0.5);\
		\cf4 // Impulse is needed to trigger the /tr message to be sent\cf0 \
	\cf2 SendTrig\cf0 .kr(\cf2 Impulse\cf0 .kr(4), 0, freq);\
	\cf2 SendTrig\cf0 .kr(\cf2 Impulse\cf0 .kr(4), 1, amp);\
	\cf2 SinOsc\cf0 .ar(freq, 0, 0.3) ! 2\
\}.play;\
\
o.remove;  \cf4 // when done, you need to clean up the OSCresponderNode\cf0 \
\
l[0].array.plot	\cf4 // view frequencies\cf0 \
l[1].array.plot	\cf4 // view amps\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 Shared controls (Internal server only, control rate only) \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 \
The internal server allocates a number of control buses whose memory addresses are shared with the client. The client can poll these buses without using OSC messages. \
\
Insert a SharedOut.kr UGen into your synthdef. Then, on the client side, use s.getSharedControl(num) to read the value. If you want to track the value over time, use a routine to poll repeatedly.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \{	\cf2 var\cf0 	freq;\
	freq = \cf2 LFNoise1\cf0 .kr(2, 600, 800);\
	\cf2 SharedOut\cf0 .kr(0, freq);		\cf4 // no need for Impulse here\cf0 \
	\cf2 SinOsc\cf0 .ar(freq, 0, 0.3) ! 2\
\}.play;\
\
l = \cf2 List\cf0 .new;\
r = fork \{ loop \{ l.add(s.getSharedControl(0)); 0.1.wait \} \};\
r.stop;\
l.array.plot;  \cf4 // to view the results graphically \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 Server-side trace 
\f1\b0 \
\
The /n_trace message causes the server to print a list of all the UGens in the node as well as their input and output values. \
\
It takes some practice to read a synthdef trace, but it's the ultimate source of information when a synthdef is not behaving as expected. Signal flow can be identified by looking at the numbers at inputs and outputs. When a UGen's output feeds into another's input, the values will be the same at both ends.\
\
For a concrete example, let's look at a synthdef that doesn't work. The intent is to generate a detuned sawtooth wave and run it through a set of parallel resonant filters whose cut-off frequencies are modulating randomly. We run the synth and generate the trace (reproduced below). The trace comes out in monochrome; colors are used here to highlight signal flow.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf2 SynthDef\cf0 (\cf3 \\resonz\cf0 , \{ \cf2 |freq = 440|\cf0 \
	\cf2 var\cf0 	sig, ffreq;\
	sig = \cf2 Saw\cf0 .ar([freq, freq+1], 0.2);\
	ffreq = \cf2 LFNoise1\cf0 .kr(2, 1, 0.5);\
	\cf2 Out\cf0 .ar(0, \cf2 Resonz\cf0 .ar(sig, (800, 1000..1800) * ffreq, 0.1))\
\}).send(s);\
\
a = \cf2 Synth\cf0 (\cf3 \\resonz\cf0 );\
a.trace;\
a.free;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
		TRACE 1005  resonz    #units: 21\
		  unit 0 Control\
		    in \
		    out 440\
		  unit 1 BinaryOpUGen\
		    in  440 1\
		    out 441\
		  unit 2 Saw\
		    in  441\
		    out 0.451348\
		  unit 3 BinaryOpUGen\
		    in  0.451348 0.2\
		    out 0.0902696\
		  unit 4 Saw\
		    in  440\
		    out -0.367307\
		  unit 5 BinaryOpUGen\
		    in  -0.367307 0.2\
		    out -0.0734615\
		  unit 6 LFNoise1\
		    in  2\
		    out -0.836168\
		  unit 7 BinaryOpUGen\
		    in  -0.836168 0.5\
		    out 
\f3\i \cf5 -0.336168
\f1\i0 \cf0 \
		  unit 8 BinaryOpUGen\
		    in  800 
\f3\i \cf5 -0.336168
\f1\i0 \cf0 \
		    out 
\f3\i \cf5 -268.934
\f1\i0 \cf0 \
		  unit 9 Resonz\
		    in  -0.0734615 
\f3\i \cf5 -268.934
\f1\i0 \cf0  0.1\
		    out 
\f0\b 843934
\f1\b0 \
		  unit 10 BinaryOpUGen\
		    in  1000 -0.336168\
		    out -336.168\
		  unit 11 Resonz\
		    in  0.0902696 
\f3\i -336.168
\f1\i0  0.1\
		    out 
\f0\b \cf6 3.02999e+08
\f1\b0 \cf0 \
		  unit 12 BinaryOpUGen\
		    in  1200 -0.336168\
		    out -403.402\
		  unit 13 Resonz\
		    in  -0.0734615 
\f3\i -403.402
\f1\i0  0.1\
		    out 
\f0\b \cf7 9.14995e+10
\f1\b0 \cf0 \
		  unit 14 BinaryOpUGen\
		    in  1400 -0.336168\
		    out -470.635\
		  unit 15 Resonz\
		    in  0.0902696 
\f3\i -470.635
\f1\i0  0.1\
		    out 
\f0\b \cf8 -5.42883
\f1\b0 \cf0 \
		  unit 16 BinaryOpUGen\
		    in  1600 -0.336168\
		    out -537.869\
		  unit 17 Resonz\
		    in  -0.0734615 
\f3\i -537.869
\f1\i0  0.1\
		    out 
\f0\b \cf9 515.506
\f1\b0 \cf0 \
		  unit 18 BinaryOpUGen\
		    in  1800 -0.336168\
		    out -605.102\
		  unit 19 Resonz\
		    in  0.0902696 
\f3\i -605.102
\f1\i0  0.1\
		    out 
\f0\b \cf10 32785.2
\f1\b0 \cf0 \
		  unit 20 Out\
		    in  0 
\f0\b 843934 \cf6 3.02999e+08\cf0  \cf7 9.14995e+10\cf0  \cf8 -5.42883\cf0  \cf9 515.506\cf0  \cf10 32785.2
\f1\b0 \cf0 \
		    out \
\
Two problems leap out from the trace: first, there are six channels of the output (there should be 1), and second, all the outputs are well outside the audio range -1..1. The first is because we use multichannel expansion to produce an array of Resonz filters, but we don't mix them down into a single channel. \
\
The above trace uses colors to track the source of each output signal. Note that there are no out of range signals prior to each Resonz. Looking at the Resonz inputs, we see that the frequency input is negative, which will blow up most digital filters. \
\
The resonance frequency derives from multiplying an array by a LFNoise1. Tracing back (the red, italicized numbers), the LFNoise1 is outputting a negative number, where we expected it to be 0.5..1.5. But, the mul and add inputs are reversed! \
\
If you look very carefully at the trace, you will see another problem relating to multichannel expansion. The two components of the detuned sawtooth go into alternate Resonz'es, where we expected both to go, combined, into every Resonz. To fix it, the sawtooths need to be mixed as well.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf2 SynthDef\cf0 (\cf3 \\resonz\cf0 , \{ \cf2 |freq = 440|\cf0 \
	\cf2 var\cf0 	sig, ffreq;\
	sig = \cf2 Mix\cf0 .ar(\cf2 Saw\cf0 .ar([freq, freq+1], 0.2));\
	ffreq = \cf2 LFNoise1\cf0 .kr(2, 0.5, 1);\
	\cf2 Out\cf0 .ar(0, \cf2 Mix\cf0 .ar(\cf2 Resonz\cf0 .ar(sig, (800, 1000..1800) * ffreq, 0.1)))\
\}).send(s);\
\
a = \cf2 Synth\cf0 (\cf3 \\resonz\cf0 );\
a.trace;\
a.free;\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 Debugging client-to-server communication
\f1\b0\fs24 \
\
Some bugs result from OSC messages to the server being constructed incorrectly. Julian Rohrhuber's DebugNetAddr is a convenient way to capture messages. The class may be downloaded from:\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \ul \ulc0 http://swiki.hfbk-hamburg.de:8888/MusicTechnology/710\ulnone  \
\
To use it, you need to quit the currently running local server, then create a new server using a DebugNetAddr instead of a regular NetAddr. Messages will be dumped into a new document window.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 s.quit;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 Server\cf0 .default = s = \cf2 Server\cf0 .new(\cf3 'local-debug'\cf0 , \cf2 DebugNetAddr\cf0 (\cf11 "localhost"\cf0 , 57110));\
s.boot;\
s.makeWindow;		\cf4 // optional\cf0 \
\
	latency nil		// these messages get sent on bootup\
		[ "/notify", 1 ]\
	\
	latency nil\
		[ "/g_new", 1 ]\
\
a = \{ \cf2 SinOsc\cf0 .ar(440, 0, 0.4) ! 2 \}.play;\
\
	latency nil\
		[ "/d_recv", "data[ 290 ]", [ 9, "-1589009783", 1001, 0, 1, 'i_out', 0, 'out', 0 ] ]\
\
a.free;\
\
	latency nil\
		[ 11, 1001 ]\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 Debugging client code 
\f1\b0\fs24 \
 \
SuperCollider does not have a step trace function, which makes debugging on the client side tougher, but not impossible. \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 Errors
\f1\b0  \
\
Learning how to read SuperCollider error output is absolutely essential. Error dumps often (though not always) contain a great deal of information: what the action was, which objects are being acted upon, and how the flow of execution reached that point.\
\
See the [\ul Understanding-Errors\ulnone ] help file for a tutorial. \
\
There's also a graphic Inspector for error dumps, which is enabled with the following command:\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf2 Exception\cf0 .debug = \cf2 true\cf0 ;		\cf4 // enable\cf0 \
\cf2 Exception\cf0 .debug = \cf2 false\cf0 ;	\cf4 // disable \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
In most cases, this will give you more information than a regular error dump. Usually the regular error dump is sufficient. If you are using Environments or prototype-style programming, the graphic inspector is indispensable.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 Debug output using post statements
\f1\b0 \
\
The most common approach is to insert statements to print the values of variables and expressions. Since the normal printing methods don't change the value of an expression, they can be placed in the middle of the statement without altering the processing flow. There's no significant difference between:\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 if(a > 0) \{ positive.value(a) \};\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
and\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 if((a > 0).postln) \{ positive.value(a) \}; \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
Common methods to use are: \
\
.postln\
.postcs		\cf4 // post the object as a compile string\cf0 \
.debug(caller)	\cf4 // post the object along with a tag identifying the caller\cf0 \
\
.debug is defined in the crucial library, so Linux and Windows users may not have access to it. It's used like this:\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 (\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 var\cf0 	positiveFunc;\
positiveFunc = \{ \cf2 |a|\cf0 \
	a.debug(\cf3 'positiveFunc-arg a'\cf0 );\
	a*10\
\};\
a = 5;\
if (a > 0) \{ positiveFunc.value(a) \};\
)\
\
// output:\
positiveFunc-arg a: 5\
50
\f1\fs24 \
\
The caller argument is optional; however, it's very helpful for tracing the origin of erroneous values. \
\
Another advantage of .debug is that it's easier to search for debug calls and differentiate them from legitimate postln and postcs calls.\
\
To print multiple values at one time, wrap them in an array before using .debug or .postcs. Note that if any of the array members are collections, postln will hide them behind the class name: "an Array, a Dictionary" etc. Use postcs if you expect to be posting collections.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 [val1, val2, val3].debug(\cf3 \\myMethod\cf0 );	\cf4 // or, for a non-Crucial way:\cf0 \
[\cf3 \\callerTag\cf0 , val1, val2, val3].postcs;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
By sprinkling these throughout your code, especially at the beginnings of functions or methods, the debugging output can give you a partial trace of which code blocks get visited in what order.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 dumpBackTrace
\f1\b0 \
\
If you discover that a particular method or function is being entered but you don't know how it got there, you can use the .dumpBackTrace method on any object. You'll get what looks like an error dump, but without the error. Execution continues normally after the stack dump.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf2 (\
var\cf0 	positiveFunc;\
positiveFunc = \{ \cf2 |a|\cf0 \
	a.debug(\cf3 'positiveFunc-arg a'\cf0 );\
	a.dumpBackTrace;\
	a*10\
\};\
a = 5;\
if (a > 0) \{ positiveFunc.value(a) \};\
)\
\
// output:\
positiveFunc-arg a: 5\
CALL STACK:\
	< FunctionDef in closed FunctionDef >\
		arg a = 5\
	< closed FunctionDef >\
		var positiveFunc = <instance of Function>\
	Interpreter-interpretPrintCmdLine\
		arg this = <instance of Interpreter>\
		var res = nil\
		var func = <instance of Function>\
	Process-interpretPrintCmdLine\
		arg this = <instance of Main>\
50\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
This tells you that the function came from interpreting a closed FunctionDef (automatically created when evaluating a block of code).\
\
In a method definition, it's recommended to use "this.dumpBackTrace"; in a free-standing function, there is no "this" so you should pick some arbitrary object.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 Tracing streams\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 \
To see the results of a pattern, use the .trace method. Each output value from the pattern gets posted to the main output.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 s.boot;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 SynthDescLib\cf0 .global.read;\
\
p = \cf2 Pbind\cf0 (\cf3 \\degree\cf0 , \cf2 Pwalk\cf0 ((0..14), \cf2 Pstutter\cf0 (\cf2 Pwhite\cf0 (1, 4, \cf2 inf\cf0 ), \cf2 Prand\cf0 (#[-2, -1, 1, 2], \cf2 inf\cf0 )), \cf2 Pseq\cf0 (#[-1, 1], \cf2 inf\cf0 ), 0), \cf3 \\delta\cf0 , 0.25, \cf3 \\sustain\cf0 , 0.2, \cf3 \\instrument\cf0 , \cf3 \\default\cf0 ).trace.play;\
\
p.stop;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 Debugging infinite loops or recursion
\f1\b0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 while(\cf2 true\cf0 ); \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
This is a bad idea. It will lock up SuperCollider and you will have to force quit. Sometimes this happens in your code and the reason isn't obvious. Debugging these situations is very painful because you might have to force quit, relaunch SuperCollider, and reload your code just to try again. \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 f = \{ \cf2 |func|\cf0  func.value(func) \};\
f.value(f); \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
Infinite recursion, on the other hand, is more likely to cause SuperCollider to quit unexpectedly when the execution stack runs out of space.\
\
In Mac OS X, inserting "post" or "debug" calls will not help with infinite loops or recursion, because posted output is held in a buffer until execution is complete. If execution never completes, you never see the output. \
\
One useful approach is to insert statements that will cause execution to halt. The easiest is .halt, but it provides you with no information about where or how it stopped, or how it got there. If you want a more descriptive message, make up an error and throw it:\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf2 Error\cf0 (\cf11 "myFunction-halt"\cf0 ).throw; \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
When debugging code that crashes, place a line like this somewhere in the code. If you get the error output, you know that the infinite loop is happening after the error--so move the error.throw later and try again. If it crashes, you know the infinite loop is earlier. Eventually, after a lot of heartache, you can zero in on the location. \
\
Here is a rogues' gallery of infinite loop gotchas--things that don't look like infinite loops, but they will kill your code quicker than you can wish you hadn't just pushed the enter key:\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 i = 0;\
while (i < 10) \{ i.postln; i = i+1 \}; 	\cf4 // crash\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
While loop syntax is different in SuperCollider from C. The above loop means to check whether i < 10 once, at the beginning of the loop, then loop if the value is true. Since the loop condition is evaluated only once, it never changes, so the loop never stops. The loop condition should be written inside a function, to wit:\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 i = 0;\
while \{ i < 10 \} \{ i.postln; i = i+1 \};\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
Routines and empty arrays:\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 a = \cf2 Array\cf0 .new;\
r = \cf2 Routine\cf0 (\{\
	loop \{\
		a.do(\{ \cf2 |item|\cf0  item.yield \});\
	\}\
\}); \
r.next;	\cf4 // crash\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
This looks pretty innocent: iterate repeatedly over an array and yield each item successively. But, if the array is empty, the do loop never executes and yield never gets called. So, the outer loop\{\} runs forever, doing nothing. \
\
Recursion is often used to walk through a tree structure. Tree structures are usually finite--no matter which branch you go down, eventually you will reach the end. If you have a data structure that is self-referential, you can easily get infinite recursion:\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 a = (1..10);\
a.put(5, a);	\cf4 // now one of the items of a is a itself\cf0 \
a.postcs;		\cf4 // crash--postcs has to walk through the entire collection, which loops on itself \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
Self-referential data structures are sometimes an indication of poor design. If this is the case, avoid them.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 a = 0;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 SystemClock\cf0 .sched(2, \{ a.postln \});	\cf4 // crashes when scheduler fires the function\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
When a scheduled function executes, if it returns a number, the function will be rescheduled for now + the number. If the number is 0, it is effectively the same as an infinite loop.\
\
To fix it, make sure the function returns a non-number.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 a = 0;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 SystemClock\cf0 .sched(2, \{ a.postln; \cf2 nil\cf0  \});
\f1\fs24 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 Removing debugging statements\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 \
Use formatting to help your eye locate debugging statements when it's time to remove them. SuperCollider code is usually indented. If you write your debugging statements fully left-justified, they're much easier to see.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 a = \cf2 Array\cf0 .new;\
r = \cf2 Routine\cf0 (\{\
	loop \{\
		\cf11 "debugging"\cf0 .postln;	\cf4 // looks like regular code, doesn't stand out\cf0 \
		a.do(\{ \cf2 |item|\cf0  item.yield \});\
	\}\
\}); \
r.next;	\cf4 // crash\cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 // vs:\cf0 \
\
a = \cf2 Array\cf0 .new;\
r = \cf2 Routine\cf0 (\{\
	loop \{\
\cf11 "debugging"\cf0 .postln;	\cf4 // this obviously sticks out\cf0 \
		a.do(\{ \cf2 |item|\cf0  item.yield \});\
	\}\
\}); \
r.next;	\cf4 // crash\cf0 \
}