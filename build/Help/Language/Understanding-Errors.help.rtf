{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
\f3\fswiss\fcharset77 Helvetica-Oblique;}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue191;\red96\green96\blue96;
\red191\green0\blue0;\red0\green0\blue0;\red0\green0\blue191;}
\pard\tx1440\tx2880\tx4320\tx5760\tx7200\ql\qnatural

\f0\b\fs40 \cf0 Understanding errors 
\f1\b0\fs24 \
\

\f0\b 1. Reading error dumps\
2. Error objects and error handling\
3. Common primitive errors\

\f1\b0 \

\f0\b\fs32 1. Reading error dumps \

\f1\b0\fs24 \
When sc3 reports an error to the user, there are usually three parts: \
\
- the error text\
- a dump of the receiver of the method that caused the error, and/or any arguments of the method call\
- a dump of the call stack to the point of the error \
\
For example:\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 1.blech  \cf2 // no class implements this method; therefore you'll get an error\cf0 \
\cf2 \
// error text\cf0 \
ERROR: Message 'blech' not understood.\
\cf2 // receiver and args\cf0 \
RECEIVER:\
   Integer 1\
ARGS:\
Instance of Array \{    (02207560, gc=01, fmt=01, flg=11, set=00)\
  indexed slots [0]\
\}\
\cf2 // call stack\cf0 \
CALL STACK:\
	DoesNotUnderstandError-reportError\
		arg this = <instance of DoesNotUnderstandError>\
	Nil-handleError\
		arg this = nil\
		arg error = <instance of DoesNotUnderstandError>\
	Object-throw\
		arg this = <instance of DoesNotUnderstandError>\
	Object-doesNotUnderstand\
		arg this = 1\
		arg selector = 'blech'\
		arg args = [*0]\
	< closed FunctionDef >  (no arguments or variables)\
	Interpreter-interpretPrintCmdLine\
		arg this = <instance of Interpreter>\
		var res = nil\
		var func = <instance of Function>\
	Process-interpretPrintCmdLine\
		arg this = <instance of Main>
\f1\fs24 \
\pard\tx1440\tx2880\tx4320\tx5760\tx7200\ql\qnatural
\cf0 \
Each of these parts provides valuable information about the cause of the error. Debugging is much easier if you understand what the error output means. \
\

\f0\b Error text:
\f1\b0  A string describing the error. In this case, "Message 'xxx' not understood" means that you attempted to use the method xxx on a class that does not implement it. \
\

\f0\b Receiver and arguments:
\f1\b0  The method was applied to an integer (1), with no arguments (the size of the arguments array is 0). \
\

\f0\b Call stack:
\f1\b0  Order of execution in the call stack is in reverse: the top of the stack shows the most recent calls. \
\
Most call stacks for errors will show the same top three calls as shown here (calling the method reportError on an error class, calling handleError on Nil, and calling throw on the error object). You can ignore these three calls. \
\
Following is the meat: the error happened when an object was not understood. Continuing to read down, it happened inside a function definition. (Every time you highlight a block of code and press the enter key, the code is compiled into a function definition and executed. So, this function definition simply refers to the text submitted to the interpreter.) And, it all began with the instruction to interpret and print a command line. \
\
Here is a slightly more complex example, showing how you can use the variables listed for each call in the call stack to help locate the error.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf3 Routine\cf0 (\{\
	\cf3 var\cf0  a;\
	a = 5;\
	loop \{\
		\cf3 var\cf0  b;\
		b = 20.rand;\
		b.postln.ecky_ecky_phtang;   \cf2 // "NI!!!!"\cf0 \
		a.wait;\
	\}\
\}).play;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \

\f2\fs18 ERROR: Message 'ecky_ecky_phtang' not understood.\
RECEIVER:\
   Integer 6\
ARGS:\
Instance of Array \{    (02207560, gc=01, fmt=01, flg=11, set=00)\
  indexed slots [0]\
\}\
CALL STACK:\
	DoesNotUnderstandError-reportError\
		arg this = <instance of DoesNotUnderstandError>\
	Nil-handleError\
		arg this = nil\
		arg error = <instance of DoesNotUnderstandError>\
	Object-throw\
		arg this = <instance of DoesNotUnderstandError>\
	Object-doesNotUnderstand\
		arg this = 6\
		arg selector = 'ecky_ecky_phtang'\
		arg args = [*0]\
	< FunctionDef in closed FunctionDef >\
		var b = 6\
	Function-loop\
		arg this = <instance of Function>\
	< FunctionDef in closed FunctionDef >\
		var a = 5\
	Routine-prStart\
		arg this = <instance of Routine>\
		arg inval = 1542.075067\
\

\f1\fs24 Reading from the bottom this time, to trace the flow in chronological order: this time, execution did not begin with the command line, but with a routine commencing within the scheduler (Routine(\{...\}).play). Note that there are two calls identified as "FunctionDef in closed FunctionDef" and that they can be distinguished by the variables contained within. The earlier call (second from the bottom) defines the variable "a" while the other defines "b." To locate the error in the code, then, you should look for a function defining the variable "b" that is 
\f3\i called
\f1\i0  within another function defining "a" inside a routine. \
\
What if the error occurred not inside a function definition that you wrote, but inside a method in the class library? There may be a bug in the method, or you may have thought the method took a certain kind of argument when in fact it expects something else. \
\
If you double click on the construction "ClassName-methodName" in the call stack, the whole thing is selected. Then you can press cmd-J to open the method definition and look at the source code.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs32 \cf0 2. Error objects and error handling 
\f1\b0\fs24 \
\
sc3 implements error reporting using Error objects, which are instances of the class Error or one of its subclasses. Any code (whether in the class library or any user application) can throw an error any time as follows: \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf3 Error\cf0 (\cf4 "This is a basic error."\cf0 ).throw; \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
You can also catch exceptions that occur within functions by executing the function with "try" or "protect" instead of "value."\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 try -
\f1\b0  execute the first function. On an error, execute the second function and suppress the error. The second function can rethrow the error if desired, allowing you to decide which errors will be reported and which suppressed. In this example, we do not rethrow the error, so the error is swallowed and execution continues to the end.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 try \{ 1.blech \} \{ \cf3 |error|\cf0  \cf4 "oops"\cf0 .postln \};\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 "next line"\cf0 .postln;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \

\f2\fs18 oops\
next line\

\f1\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 protect -
\f1\b0  executes the first function. On an error, execute the second function before reporting the error. This is useful when the steps before the protect make some changes that need to be undone if an error occurs. See the method Environment-use for an example.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 protect \{ 1.blech \} \{ \cf3 |error|\cf0  \cf4 "oops"\cf0 .postln \};\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 "next line"\cf0 .postln;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \

\f2\fs18 oops  \cf2 // without protect, this would not be posted\cf0 \
ERROR: Message 'blech' not understood.\
RECEIVER:\
   Integer 1\
ARGS:\
Instance of Array \{    (02207560, gc=01, fmt=01, flg=11, set=00)\
  indexed slots [0]\
\}\
CALL STACK:\
	DoesNotUnderstandError-reportError\
		arg this = <instance of DoesNotUnderstandError>\

\f1\fs24 \
\
Prior to August 2004, try and protect do not return the value of the function to the caller if there is no error.\
\

\f2\fs18 try \{ 1+1 \}\
\
a Function\

\f1\fs24 \
More recent builds (since early August 2004) do return the function's value. Non-error objects can be thrown using the class 
\f0\b Exception
\f1\b0 .\
\

\f2\fs18 try \{ 1+1 \}\
2
\f1\fs24 \
\

\f2\fs18 \cf5 // can't add a Point to an integer - binary op failed error\cf6 \
\cf5 // result of try func is returned instead\cf6 \
\cf0 try \cf6 \{ 1+\cf7 Point\cf6 (0, 0) \} \{ 2*5 \}\
10\

\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs32 \cf0 3. Common primitive errors \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 - operation cannot be called from this Process. \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 \
This is usually the results of performing a GUI operation within a routine or scheduled function that is executing on some clock other than AppClock. AppClock is the only clock that can execute GUI manipulation because it is a lower priority thread. If the CPU is busy with audio synthesis or maintaining accurate scheduling for musical events, AppClock events will be delayed until the CPU is free enough. \
\
Solution: write your GUI updates as follows. 
\f0\b defer
\f1\b0  schedules the function on AppClock.\
\

\f2\fs18 \{ myGUIObject.value_(newValue) \}.defer; \

\f1\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 - Attempted write to immutable object. \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 \

\f2\fs18 #[0, 1, 2].put(1, 3)\
\
ERROR: Primitive '_BasicPut' failed.\
Attempted write to immutable object.\

\f1\fs24 \
#[0, 1, 2] is a literal array. Literal arrays cannot be manipulated--they can only be indexed. They cannot be changed internally. \
\
Solution: copy the array first.\
\

\f2\fs18 #[0, 1, 2].copy.put(1, 3)\
\
[ 0, 3, 2 ] \

\f1\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 - Index not an Integer.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 \

\f2\fs18 \cf6 #[0, 1, 2].at(\\1)\
\cf0 \
ERROR: Primitive '_BasicAt' failed.\
Index not an Integer\

\f1\fs24 \
Arrays can be indexed only with integers (or, in builds since August 2004, floats).\
\
Solution: use .asInteger\'d1note that if the object cannot be converted into an integer, you'll get a "Does not understand" error!\
\

\f2\fs18 #[0, 1, 2].at(\\1.asInteger)\
1\

\f1\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 - Index out of range.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 \

\f2\fs18 [0, 1, 2].put(5, 5)\
\
ERROR: Primitive '_BasicPut' failed.\
Index out of range.\

\f1\fs24 \
Arrays have a finite size. If you try to put an object into an array slot but the slot does not exist because the array is too small, you'll get this error. \
\
Solution: extend the array.\
\

\f2\fs18 [0, 1, 2].extend(6).put(5, 5)\
\
[ 0, 1, 2, nil, nil, 5 ]\
\

\f1\fs24 Note that if the argument to extend() is smaller than the array, then the array will be truncated. If you're not sure, use max:
\f2\fs18 \
\
i = rrand(5, 10);\
a = [0, 1, 2];\
a.extend(max(i+1, a.size)).put(i, 100);\

\f1\fs24 \
Why i+1? An array with size 4 allows 0, 1, 2 and 3 as indexes (4 elements starting with 0).}