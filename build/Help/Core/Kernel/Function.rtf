{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 Function
\f1\b0\fs24 \
\

\f0\b superclass: AbstractFunction\

\f1\b0 \
A Function is a reference to a FunctionDef and its defining context Frame.\
When a FunctionDef is encountered in your code it is pushed on the stack as a Function.\
A Function can be evaluated by using the 'value' method.\
\
Because it inherits from AbstractFunction, Functions can respond to math operations by \
creating a new Function. For example:\
\

\f2 (\
var a, b, c;\
a = \{ [100, 200, 300].choose \};	// a Function\
b = \{ 10.rand + 1 \};	// another Function\
c = a + b; 	// c is a Function.\
c.value.postln;	// evaluate c and print the result\
)\

\f1 \

\f0\b\fs28 \ul Accessing
\f1\b0\fs24 \ulnone \
\

\f0\b def
\f1\b0 \
\
Get the FunctionDef definition of the Function.\
\

\f0\b\fs28 \ul Evaluation
\f1\b0\fs24 \ulnone \
\

\f0\b value(...args)\

\f1\b0 \
Evaluates the FunctionDef referred to by the Function. The Function is passed the args given.\
\

\f2 \{ arg a, b; (a * b).postln \}.value(3, 10);\

\f1 \

\f0\b valueArray(..args..)\

\f1\b0 \
Evaluates the FunctionDef referred to by the Function. If the last argument is an Array or List, \
then it is unpacked and appended to the other arguments (if any) to the Function. \
If the last argument is not an Array or List then this is the same as the 'value' method.\
\

\f2 \{ arg a, b, c; ((a * b) + c).postln \}.valueArray([3, 10, 7]);\

\f1 \

\f2 \{ arg a, b, c, d; [a, b, c, d].postln \}.valueArray([1, 2, 3]);\

\f1 \

\f2 \{ arg a, b, c, d; [a, b, c, d].postln \}.valueArray(9, [1, 2, 3]);\
\
\{ arg a, b, c, d; [a, b, c, d].postln \}.valueArray(9, 10, [1, 2, 3]);\

\f1 \

\f0\b kr(lagTime)\

\f1\b0 \
Wraps the Function in a Plug object. The Function will be evaluated every\
control period and its result becomes the signal for the Plug object.\
The lagTime is used by the Plug object to smooth the signal. See Plug.\
\
(\

\f2 Synth.scope(\
	SinOsc.ar(\
		\{ (MouseX.new(0,1).value.coin.binaryValue + 1) * 800 \}.kr(0), \
		0, \
		0.1\
	)\
))\
\
Synth.play(SinOsc.ar(\{ (10.rand + 1) * 200 \}.kr(MouseX.kr(0,1)), 0, 0.2))\

\f1\fs18 \
}