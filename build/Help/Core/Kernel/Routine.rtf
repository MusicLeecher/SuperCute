{\rtf1\mac\ansicpg10000\cocoartf824\cocoasubrtf100
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
\f3\fswiss\fcharset77 Helvetica-Oblique;\f4\fswiss\fcharset77 Helvetica-BoldOblique;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red96\green96\blue96;\red191\green0\blue0;
\red0\green115\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 Routine
\f1\b0\fs24 \
\

\f0\b Superclass: Thread\
\

\f1\b0 Routines are functions that can return in the middle and then resume where \
they left off when called again. Routines can be used to implement co-routines\
as found in Scheme and some other languages.\
Routines are useful for writing things that behave like Streams.\
Routines inherit behaviour for math operations and filtering from 
\f0\b [\ul Stream\ulnone ]
\f1\b0 .\
\

\f0\b *new(func, stackSize, seed)\

\f1\b0 \
Creates a Routine instance with the given function.\
The stackSize and random seed may be overridden if desired.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 (\
a = \cf2 Routine\cf0 .new(\{ 1.yield; 2.yield; \});\
a.next.postln;\
a.next.postln;\
a.next.postln;\
)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\

\f0\b value(inval)\
resume(inval)\
next(inval)\

\f1\b0 \
These are all synonyms for the same method.\
\
The Routine function is either started if it has not been called yet, or it is \
resumed from where it left off. The argument inval is passed as the argument\
to the Routine function if it is being started, or as the result of the yield\
method if it is being resumed from a yield. The result of the method will be\
what the Routine yields.\
\
There are basically 2 conditions for a Routine: one is when the routine starts. The other case is \
that the routine continues after it has yielded. \
\
When the routine starts (by calling the above methods), you are passing in a first inval. \
This inval is accessible as the routine function argument:\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 (\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 Routine\cf0  \{ \cf2 arg\cf0  inval;\
	inval.postln;\
\}.value(\cf3 "hello routine"\cf0 );\
)
\f1\fs24 \
\
When there is a yield in the routine, the next time you call 
\f3\i next
\f1\i0  (or synonym), the routine continues\
from there, and you get a chance to pass in a value from the outside. To access that value within the\
continuing routine, you have to assign the 
\f4\i\b result of the yield call
\f1\i0\b0  to a variable:\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 (\
r = \cf2 Routine\cf0  \{ \cf2 arg\cf0  inval;\
	\cf2 var\cf0  valuePassedInbyYield;\
	inval.postln;\
	valuePassedInbyYield = 123.yield;\
	valuePassedInbyYield.postln;\
	\
\}\
)\
\
r.value(\cf3 "hello routine"\cf0 );\
r.value(\cf3 "goodbye world"\cf0 );
\f1\fs24 \
\
\
Typically the name 
\f3\i inval
\f1\i0  (or inevent) is reused, instead of declaring a variable like "valuePassedInbyYield":\
\

\f2\fs18 (\
r = \cf2 Routine\cf0  \{ \cf2 arg\cf0  inval;\
	inval.postln;\
	inval = 123.yield;\
	inval.postln;\
\}\
)\
\
r.value(\cf3 "hello routine"\cf0 );\
r.value(\cf3 "goodbye world"\cf0 );
\f1\fs24 \
\
\
Typically a routine uses a multiple yield, in which the inval is reassigned repeatedly:\
\

\f2\fs18 (\
r = \cf2 Routine\cf0  \{ \cf2 arg\cf0  inval;\
	inval.postln;\
	5.do \{ \cf2 arg\cf0  i;\
		inval = (i + 10).yield;\
		inval.postln;\
	\}\
\}\
)\
(\
5.do \{\
	r.value(\cf3 "hello routine"\cf0 ).postln;\
\}\
)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\
\

\f0\b reset
\f1\b0 \
\
Causes the Routine to start from the beginning next time it is called.\
A Routine cannot reset itself except by calling the yieldAndReset method.\
\
See also in class 
\f0\b Object :\
yield(outval)\
yieldAndReset(outval)\
alwaysYield(outval)\
\

\f1\b0 If a Routine's function returns then it will always yield nil until reset.\
\
\
\
\

\f0\b play(clock, quant)
\f1\b0 \
		
\f0\b clock
\f1\b0 :		a Clock, 
\f0\b TempoClock
\f1\b0  by default\
		
\f0\b quant
\f1\b0 :		either a number
\f0\b  n
\f1\b0  (quantize to 
\f0\b n 
\f1\b0 beats)\
					or an array
\f0\b  [n, m]
\f1\b0  (quantize to 
\f0\b n
\f1\b0  beats, with offset 
\f0\b m
\f1\b0 )\
\
In the SuperCollider application, a Routine can be played using a Clock, as can any Stream.\
every time the Routine yields, it should do so with a float, the clock will interpret that, usually\
pausing for that many seconds, and then resume the routine, passing it it the clock's current time.\

\f0\b \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs26 \cf0 Accessible instance variables
\fs24 \
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f4\i \cf0 Routine
\f0\i0  inherits from 
\f4\i Thread
\f0\i0 , which allows access to some of its state:\
\
\
beats\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 	return the elapsed beats (logical time) of the routine. The beats do not proceed when the routine is\
	not playing.
\f0\b \
	\
seconds\
	
\f1\b0 return the elapsed seconds (logical time) of the routine. The seconds do not proceed when the routine is\
	not playing, it is the converted beat value.
\f0\b \
\
clock\

\f1\b0 	return the thread's clock. If it hs not played, it is the SystemClock.\
	\
\

\f0\b \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs18 \cf0 (\
r = \cf2 Routine\cf0  \{ \cf2 arg\cf0  inval;\
	loop \{\
		\cf4 // thisThread refers to the routine.\cf0 \
		postf(\cf3 "beats: % seconds: % time: % \\n"\cf0 , \
			\cf2 thisThread\cf0 .beats, \cf2 thisThread\cf0 .seconds, \cf2 Main\cf0 .elapsedTime\
		);\
		1.0.yield;\
		\
	\}\
\}.play;\
)\
\
r.stop;\
r.beats;\
r.seconds;\
r.clock;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 \
\
\
\
Routine Example:\

\f1\b0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 (\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 var\cf0  r, outval;\
r = \cf2 Routine\cf0 .new(\{ \cf2 arg\cf0  inval;\
	(\cf3 "->inval was "\cf0  ++ inval).postln;\
	inval = 1.yield;\
	(\cf3 "->inval was "\cf0  ++ inval).postln;\
	inval = 2.yield;\
	(\cf3 "->inval was "\cf0  ++ inval).postln;\
	inval = 99.yield;\
\});\
\
outval = r.next(\cf5 'a'\cf0 );\
(\cf3 "<-outval was "\cf0  ++ outval).postln;\
outval = r.next(\cf5 'b'\cf0 );\
(\cf3 "<-outval was "\cf0  ++ outval).postln;\
r.reset; \cf3 "reset"\cf0 .postln;\
outval = r.next(\cf5 'c'\cf0 );\
(\cf3 "<-outval was "\cf0  ++ outval).postln;\
outval = r.next(\cf5 'd'\cf0 );\
(\cf3 "<-outval was "\cf0  ++ outval).postln;\
outval = r.next(\cf5 'e'\cf0 );\
(\cf3 "<-outval was "\cf0  ++ outval).postln;\
outval = r.next(\cf5 'f'\cf0 );\
(\cf3 "<-outval was "\cf0  ++ outval).postln;\
)\
\
\
\
(\
\cf2 var\cf0  r;\
r = \cf2 Routine\cf0 .new(\{\
	10.do(\{ \cf2 arg\cf0  a;\
		a.postln;\
		\cf4 // Often you might see Wait being used to pause a routine\cf0 \
		\cf4 // This waits for one second between each number\cf0 \
		1.wait;\
	\});\
	\cf4 // Wait half second before saying we're done\cf0 \
	0.5.wait;\
	\cf3 "done"\cf0 .postln;\
\});\
\
\cf2 SystemClock\cf0 .play(r);\
)\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs24 \cf0  }