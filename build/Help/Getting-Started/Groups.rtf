{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fswiss\fcharset77 Helvetica-Oblique;
\f3\fnil\fcharset77 Monaco;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red191\green0\blue0;\red96\green96\blue96;
\red0\green115\blue0;\red191\green0\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural

\f0\b\fs36 \cf0 Groups
\fs28 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural

\f1\b0\fs24 \cf0 \
Our discussion about the order of synths on the server brings us to the topic of groups. Synths on the server are a type of what are called 
\f2\i nodes
\f1\i0 . There's one other type of node: groups. Groups are simply collections of nodes, and can contain synths, other groups, or combinations of both. They are mostly useful in two ways: First they are very helpful in controlling order, second, they allow you to easily group together nodes and send them messages all at once. As you've probably guessed, there's a handy Server abstraction object to represent group nodes in the client app: Group.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural

\f0\b\fs28 \cf0 Groups as Ordering Tools
\f1\b0\fs24 \
\
Groups can be quite helpful in terms of controlling order. Like synths they take targets and addActions as arguments, which makes it easy to put them in position.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural

\f3\fs18 \cf0 \
	g = \cf2 Group\cf0 .new;\
	h = \cf2 Group\cf0 .before(g);\
	g.free; h.free;
\f1\fs24 \
\
This can be very helpful for things like keeping effects or processing separate from sound sources, and in the right order. Let's reconsider our reverb example from the previous section.
\f3\fs18 \
	\
	(\
	\cf3 // a stereo version\cf0 \
	\cf2 SynthDef\cf0 (\cf4 "tutorial-DecaySin2"\cf0 , \{ \cf2 arg\cf0  outBus = 0, effectBus, direct = 0.5, freq = 440;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 		\cf2 var\cf0  source;\
		\cf3 // 1.0.rand2 returns a random number from -1 to 1, used here for a random pan\cf0 \
		source = \cf2 Pan2\cf0 .ar(\cf2 Decay2\cf0 .ar(\cf2 Impulse\cf0 .ar(\cf2 Rand\cf0 (0.3, 1), 0, 0.125), 0.3, 1, \
			\cf2 SinOsc\cf0 .ar(\cf2 SinOsc\cf0 .kr(0.2, 0, 110, freq))), Rand(-1.0, 1.0));\
		\cf2 Out\cf0 .ar(outBus, source * direct);\
		\cf2 Out\cf0 .ar(effectBus, source * (1 - direct));\
	\}).send(s);\
	\
	\cf2 SynthDef\cf0 (\cf4 "tutorial-Reverb2"\cf0 , \{ \cf2 arg\cf0  outBus = 0, inBus;\
		\cf2 var\cf0  input;\
		input = \cf2 In\cf0 .ar(inBus, 2);\
		16.do(\{ input = \cf2 AllpassC\cf0 .ar(input, 0.04, \cf2 Rand\cf0 (0.001,0.04), 3)\});\
		\cf2 Out\cf0 .ar(outBus, input);\
	\}).send(s);\
	)\
	\
	\cf3 // now we create groups for effects and synths\cf0 \
	(\
	~sources = \cf2 Group\cf0 .new;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural
\cf0 	~effects = \cf2 Group\cf0 .after(~sources); 	\cf3 // make sure it's after\
	\cf0 b = \cf2 Bus\cf0 .audio(s, 2); 				\cf3 // this will be our stereo effects bus\cf0 \
	)\
	\
	\cf3 // now synths in the groups. The default addAction is \\addToHead\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 	(\
	x = \cf2 Synth\cf0 (\cf4 "tutorial-Reverb2"\cf0 , [\cf5 \\inBus\cf0 , b.index], ~effects);\
	y = \cf2 Synth\cf0 (\cf4 "tutorial-DecaySin2"\cf0 , [\cf5 \\effectBus\cf0 , b.index, \cf5 \\outBus\cf0 , 0], ~sources);\
	z = \cf2 Synth\cf0 (\cf4 "tutorial-DecaySin2"\cf0 , [\cf5 \\effectBus\cf0 , b.index, \cf5 \\outBus\cf0 , 0, \cf5 \\freq\cf0 , 660], ~sources);\
	)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural
\cf0 	\
	\cf3 // we could add other source and effects synths here\cf0 \
	\
	~sources.free; ~effects.free; \cf3 // this frees their contents (x, y, z) as well\
	\cf0 b.free;
\f1\fs24 \
\
Note that we probably don't care what order the sources and effects are within the groups, all that matters is that all effects synths come after the source synths that they process.\
\
If you're wondering about the names '~sources' and '~effects', placing a tilde (~) in front of a word is a way of creating an 
\f2\i environment variable
\f1\i0 . For the moment, all you need to know about them is that they can be used in the same way as interpreter variables (you don't need to declare them, and they are persistent), and they allow for more descriptive names. \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural

\f0\b\fs28 \cf0 All the addActions\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural

\f1\b0\fs24 \cf0 At this point it's probably good to cover the remaining add actions. In addition to \\addBefore and \\addAfter, there is also the (rarely) used \\addReplace, and two add actions which apply to Groups: \\addToHead and \\addToTail. The former adds the receiver to the beginning of the group, so that it will execute first, the latter to the end of the group, so that it will execute last. Like the other addActions, \\addToHead and \\addToTail have convenience methods called 'head' and 'tail'.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural

\f3\fs18 \cf0 	g = \cf2 Group\cf0 .new;\
	h = \cf2 Group\cf0 .head(g);				\cf6 // add h to the head of g\cf0 \
	x = \cf2 Synth\cf0 .tail(h, \cf4 "default"\cf0 );	\cf3 // add x to the tail of h\cf0 \
	s.queryAllNodes;				\cf3 // this will post a representation of the node hierarchy\cf0 \
	x.free; h.free; g.free;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural

\f0\b\fs28 \cf0 'queryAllNodes' and node IDs
\f3\b0\fs18 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural

\f1\fs24 \cf0 \
Server has a method called 'queryAllNodes' which will post a representation of the server's node tree. You should have seen something like the following in the post window when executing the example above:\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs18 \cf0 nodes on localhost:\
a Server\
Group(0)\
        Group(1)\
                Group(1000)\
                        Group(1001)\
                                Synth 1002\
                            
\f1\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural
\cf0 When you see a Group printed here, anything below it and indented to the right is contained within it. The order of nodes is from top to bottom. The numbers you see are what are called node IDs, which are how the server keeps track of nodes. Normally when working with Server abstraction objects you won't need to deal with node IDs as the objects keep track of them, assigning and freeing them when appropriate.\
\
You may have been wondering why there were four groups posted above when we only created two. The first two, with the IDs 0 and 1, are special groups, called the RootNode and the 'default group'.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural

\f0\b\fs28 \cf0 \
The Root Node and the Default Group\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 When a server app is booted there is a special group created with a node ID of 0. This represents the top of the server's node tree. There is a special server abstraction object to represent this, called RootNode. In addition there is another group created with an ID of 1, called the default group. This is the default target for all Nodes  and is what you will get if you supply a Server as a target. If you don't specify a target or pass in nil, you will get the default group of the default Server.  \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs18 \cf2 	Server\cf0 .default.boot;\
	a = \cf2 Synth\cf0 .new(\cf5 \\default\cf0 ); \cf3 // creates a synth in the default group of the default Server\cf0 \
	a.group; \cf3 // Returns a Group object. Note the ID of 1 (the default group) in the post window\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
The default group serves an important purpose: It provides a predictable basic Node tree so that methods such as Server-scope and Server-record (which create nodes which 
\f2\i must
\f1\i0  come after everything else) can function without running into order of execution problems. In the example below the scoping node will come after the default group.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs18 \cf2 	Server\cf0 .internal.boot;\
	\
	\{ \cf2 SinOsc\cf0 .ar(mul: 0.2) \}.scope(1);\
	\cf3 \
	// watch the post window;\cf0 \
	\cf2 Server\cf0 .internal.queryAllNodes; \
	\
	\cf3 // our SinOsc synth is within the default group (ID 1)\cf0 \
	\cf3 // the scope node ('stethoscope') comes after the default group, so no problems\cf0 \
	\cf2 \
	Server\cf0 .internal.quit;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
In general you should add nodes to the default group, or groups contained within it, and 
\f2\i not
\f1\i0  before or after it. When adding an 'effects' synth, for instance, one should resist the temptation to add it after the default group, and instead create a separate source group within the default group. This will prevent problems with scoping or recording. \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 	default group [\
		source group [\
			source synth1\
			source synth2\
		]\
		effects synth\
	]\
	recording synth
\f1\b0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural
\cf0 Groups as, well, groups...\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural

\f1\b0\fs24 \cf0 \
The other major use of groups is to allow you to easily treat a number of synths as a whole. If you send a 'set' message to a group, it will apply that message to all nodes contained within it.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural

\f3\fs18 \cf0 	g = \cf2 Group\cf0 .new;\
	\
	\cf3 // make 4 synths in g\cf0 \
	\cf3 // 1.0.rand2 returns a random number from -1 to 1. \cf0 \
	4.do(\{ \{ \cf2 arg\cf0  amp = 0.1; \cf2 Pan2\cf0 .ar(\cf2 SinOsc\cf0 .ar(440 + 110.rand, 0, amp), 1.0.rand2) \}.play(g); \});\
\
	g.set(\cf4 "amp"\cf0 , 0.005); \cf3 // turn them all down\cf0 \
\
	g.free;
\f1\fs24 \
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural

\f0\b\fs28 \cf0 Groups, their Inheritance, and More on Tracking Down Help
\f1\b0\fs24 \
\
Now for a little more OOP theory. Both Group and Synth are examples of what are called 
\f2\i subclasses
\f1\i0 . You can think of subclasses as being children of a parent class, called their 
\f2\i superclass
\f1\i0 . All subclasses inherit the methods of their superclass. They may 
\f2\i override
\f1\i0  some methods with their own implementation (taking advantage of 
\f2\i polymorphism
\f1\i0 ), but in general subclasses respond to all the methods of their superclass, and some other ones of their own. Some classes are 
\f2\i abstract classes
\f1\i0 , which means that you don't actually make instances of them, they just exist to provide a common set of methods and variables to their subclasses. \
\
We might for instance imagine an abstract class called Dog, which has a number of subclasses, such as Terrier, BassetHound, etc. These might all have a 'run' method, but not all would need a 'herdSheep' method.\
\
This way of working has certain advantages: If you need to change an inherited method, you can do so in one place, and all the subclasses which inherit it will be changed too. As well, if you want to extend a class to make your own personal variant or enhanced version, you can automatically get all the functionality of the superclass.\
\
Inheritance can go back through many levels, which is to say that a class' superclass may also have a superclass. (A class cannot, however have more than one immediate superclass.) All objects in SC in fact inherit from a class called Object, which defines a certain set of methods which all its subclasses either inherit or override.\
\
Group and Synth are subclasses of the abstract class 
\f0\b [\ul Node\ulnone ]
\f1\b0 . Because of this, some of their methods are defined in Node, and (perhaps more practically important) 
\f2\i are documented in Node's helpfile
\f1\i0 . \
\
So if you're looking at a helpfile and can't find a particular method that a class responds to, you may need to go to the helpfile for that class' superclass, or farther up the chain. Most classes have their superclass listed at the top of their helpfile. You can also use the following methods for getting this kind of info and tracking down documentation (watch the post window):\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural

\f3\fs18 \cf0 	\cf2 Group\cf0 .superclass; 						\cf3 // this will return 'Node'\cf0 \
	\cf2 Group\cf0 .superclass.openHelpFile;\
	\cf2 Group\cf0 .findRespondingMethodFor(\cf5 'set'\cf0 );		\cf3 // Node-set\cf0 \
	\cf2 Group\cf0 .findRespondingMethodFor(\cf5 'postln'\cf0 );	\cf3 // Object-postln;\cf0 \
	\cf2 Group\cf0 .helpFileForMethod(\cf5 'postln'\cf0 ); 		\cf3 // opens class Object help file
\f1\fs24 \cf0 \
\
For more information see:
\f0\b  \
\
[\ul Group\ulnone ] [\ul Node\ulnone ] [\ul default_group\ulnone ] [\ul RootNode\ulnone ] [\ul \ulc0 Intro-to-Objects\ulnone ] [\ul Order-of-execution\ulnone ] [\ul Synth\ulnone ] [\ul More-On-Getting-Help\ulnone ] [\ul Internal-Snooping\ulnone ]\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 \
____________________\
\
This document is part of the tutorial 
\f0\b Getting Started With SuperCollider
\f1\b0 .\
\
Click here to go on to the next section: 
\f0\b [\ul Buffers\ulnone ]
\f1\b0 \
\
Click here to return to the table of Contents: 
\f0\b [\ul Getting Started With SC\ulnone ]}