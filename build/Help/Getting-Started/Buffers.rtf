{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fswiss\fcharset77 Helvetica-Oblique;
\f3\fnil\fcharset77 Monaco;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red191\green0\blue0;\red96\green96\blue96;
\red0\green115\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural

\f0\b\fs36 \cf0 Buffers
\fs28 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural

\f1\b0\fs24 \cf0 \
Buffers represent server buffers, which are ordered arrays of floats on the server. 'float' is short for floating point number, which means a number with a decimal point, like 1.3. This is in contrast to integers, which are positive or negative whole numbers (or zero), and are written without decimal points. So 1 is an integer, but 1.0 is a float.\
\
Server buffers can be single or multichannel, and are the usual way of storing data server-side. Their most common use is to hold soundfiles in memory, but any sort of data that can be represented by floats can be stored in a buffer.\
\
Like busses, the number of buffers is set before you boot a server (using 
\f0\b [\ul ServerOptions\ulnone ]
\f1\b0 ), but before buffers can be used, you need to allocate memory to them, which is an asynchronous step. Also like busses, buffers are numbered, starting from 0. Using Buffer takes care of allocating numbers, and avoids conflicts.\
\
You can think of buffers as the server-side equivalent of an Array, but without all the elegant OOP functionality. Luckily with Buffer, and the ability to manipulate data in the client app when needed, you can do almost anything you want with buffer data. A server's buffers are global, which is to say that they can be accessed by any synth, and by more than one at a time. They can be written to or even changed in size, 
\f2\i while
\f1\i0  they are being read from.\
\
Many of Buffer's methods have numerous arguments. Needless to say, for full information see the 
\f0\b [\ul Buffer\ulnone ]
\f1\b0  help file.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural

\f0\b\fs28 \cf0 Making a Buffer Object and Allocating Memory
\f1\b0\fs24 \
\
Making a Buffer object and allocating the necessary memory in the server app is quite easy. You can do it all in one step with Buffer's alloc method:\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural

\f3\fs18 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural
\cf0 	s.boot;\
	b = \cf2 Buffer\cf0 .alloc(s, 100, 2); 	\cf3 // allocate 2 channels, and 100 frames \cf0 \
	b.free;						\cf3 // free the memory (when you're finished using it)\cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural

\f1\fs24 \cf0 The example above allocates a 2 channel buffer with 100 frames. The actual number of values stored is numChannels * numFrames, so in this case there will be 200 floats. So each frame is in this case a pair of values.\
\
If you'd like to allocate in terms of seconds, rather than frames, you can do so like this:\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural

\f3\fs18 \cf0 	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural
\cf0 	b = \cf2 Buffer\cf0 .alloc(s, s.sampleRate * 8.0, 2); \cf3 // an 8 second stereo buffer\
	\cf0 b.free;
\f1\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural
\cf0 \
Buffer's 'free' method frees the memory on the server, and returns the Buffer's number for reallocation. You should not use a Buffer object after doing this.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural

\f0\b\fs28 \cf0 Using Buffers with Sound Files\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural

\f1\b0\fs24 \cf0  \
Buffer has another class method called 'read', which reads a sound file into memory, and returns a Buffer object. Using the UGen PlayBuf, we can play the file.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural

\f3\fs18 \cf0 		\cf3 // read a soundfile\cf0 \
		b = \cf2 Buffer\cf0 .read(s, \cf4 "sounds/a11wlk01.wav"\cf0 );\
		\
		\cf3 // now play it\cf0 \
		(\
		x = \cf2 SynthDef\cf0 (\cf4 "tutorial-PlayBuf"\cf0 ,\{ \cf2 arg\cf0  out = 0, bufnum;\
			\cf2 Out\cf0 .ar( out,\
				\cf2 PlayBuf\cf0 .ar(1, bufnum, \cf2 BufRateScale\cf0 .kr(bufnum))\
			)\
		\}).play(s,[\cf5 \\bufnum\cf0 , b.bufnum ]);\
		)\
		x.free; b.free;\
		
\f1\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural
\cf0 PlayBuf.ar has a number of arguments which allow you to control various aspects of how it works. Take a look at the 
\f0\b [\ul PlayBuf\ulnone ]
\f1\b0  helpfile for details of them all, but for now lets just concern ourselves with the first three, used in the example above.\
\
	
\f3\fs18 \cf2 PlayBuf\cf0 .ar(\
			1,						\cf3 // number of channels\cf0 \
			bufnum, 					\cf3 // number of buffer to play\cf0 \
			\cf2 BufRateScale\cf0 .kr(bufnum)		\cf3 // rate of playback\cf0 \
			)
\f1\fs24 \
\
Number of channels: When working with PlayBuf you must let it know how many channels any buffer it will read in will have. 
\f2\i You cannot make this an argument in the SynthDef and change it later
\f1\i0 . Why? Remember that SynthDefs must have a fixed number of output channels. So a one channel PlayBuf is 
\f2\i always
\f1\i0  a one channel PlayBuf. If you need versions that can play varying numbers of channels then make multiple SynthDefs or use Function-play.\
\
Bufffer Number: As noted above, Buffers are numbered, starting from zero. You can get a Buffer's number using its 'bufnum' method. This is done at the end of the SynthDef above, where it is passed in as an argument to the resulting Synth. (Note that SynthDef-play allows you to include an array of arguments, just like Synth-new.)\
\
Rate of Playback: A rate of 1 would be normal speed, 2 twice as fast, etc. But here we see a UGen called BufRateScale. What this does is check the samplerate of the the buffer (this is set to correspond to that of the soundfile when it is loaded) and outputs the rate which would correspond to normal speed. This is useful because the soundfile we loaded (a11wlk01.wav) actually has a samplerate of 11025 Hz. With a rate of 1, PlayBuf would play it back using the sampling rate of the server, which is usually 44100 Hz, or four times as fast! BufRateScale thus brings things back to normal. \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural

\f0\b\fs28 \cf0 Streaming a File in From Disk\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural

\f1\b0\fs24 \cf0 In some cases, for instance when working with very large files, you might not want to load a sound completely into memory. Instead, you can stream it in from disk a bit at a time, using the UGen DiskIn, and Buffer's 'cueSoundFile' method:\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural

\f3\fs18 \cf0 		(\
		\cf2 SynthDef\cf0 (\cf4 "tutorial-Buffer-cue"\cf0 ,\{ \cf2 arg\cf0  out=0,bufnum;\
			\cf2 Out\cf0 .ar(out,\
				\cf2 DiskIn\cf0 .ar( 1, bufnum )\
			)\
		\}).send(s);\
		)\
		\
		b = \cf2 Buffer\cf0 .cueSoundFile(s,\cf4 "sounds/a11wlk01-44_1.aiff"\cf0 , 0, 1);\
		y = \cf2 Synth\cf0 .new(\cf4 "tutorial-Buffer-cue", \cf0 [\cf5 \\bufnum\cf0 ,b.bufnum], s);\
\
		b.free; y.free;
\f1\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural
\cf0 \
This is not as flexible as PlayBuf (no rate control), but can save memory.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural

\f0\b\fs28 \cf0 \
More on Instance Variables and Action Functions\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural

\f1\b0\fs24 \cf0 Now a little more OOP. Remember that individual Objects store data in 
\f2\i instance variables
\f1\i0 . Some instance variables have what are called getter or setter methods, which allow you to get or set their values. We've already seen this in action with Buffer's 'bufnum' method, which is a getter for its buffer number instance variable.\
\
Buffer has a number of other instance variables with getters which can provide helpful information. The ones we're interested in at the moment are numChannels, numFrames, and sampleRate. These can be particularly useful when working with sound files, as we may not have all this information at our fingertips before loading the file.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural

\f3\fs18 \cf0 	\cf3 // watch the post window\cf0 \
	b = \cf2 Buffer\cf0 .read(s, \cf4 "sounds/a11wlk01.wav"\cf0 );\
	b.bufnum;\
	b.numFrames;\
	b.numChannels;\
	b.sampleRate;\
	b.free;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural

\f1\fs24 \cf0 Now (like with the example using an action function in our Bus-get example; see 
\f0\b [Busses]
\f1\b0 ) because of the small messaging latency between client and server, instance variables will not be immediately updated when you do something like read a file into a buffer. For this reason, many methods in Buffer take action functions as arguments. Remember that an action function is just a Function that will be evaluated after the client has received a reply, and has updated the Buffer's vars. It is passed the Buffer object as an argument.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural

\f3\fs18 \cf0 		\cf3 // with an action function\cf0 \
		\cf3 // note that the vars are not immediately up-to-date\cf0 \
		(\
		b = \cf2 Buffer\cf0 .read(s, \cf4 "sounds/a11wlk01.wav"\cf0 , action: \{ \cf2 arg\cf0  buffer; \
			(\cf4 "numFrames after update:"\cf0  + buffer.numFrames).postln;\
			x = \{ \cf2 PlayBuf\cf0 .ar(1, buffer.bufnum, \cf2 BufRateScale\cf0 .kr(buffer.bufnum)) \}.play;\
		\});\
		\
		\cf3 // Note that the next line will execute BEFORE the action function\cf0 \
		(\cf4 "numFrames before update:"\cf0  + b.numFrames).postln;\
		)\
		x.free; b.free;
\f1\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural
\cf0 \
In the example above, the client sends the read command to the server app, along with a request for the necessary information to update the Buffer's instance variables. It then cues the action function to be executed when it receives the reply, and continues executing the block of code. That's why the 'Before update...' line executes first.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural

\f0\b\fs28 \cf0 \
Recording into Buffers\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural

\f1\b0\fs24 \cf0 In addition to PlayBuf, there's a UGen called RecordBuf, which lets you record into a buffer.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs18 \cf0 	b = \cf2 Buffer\cf0 .alloc(s, s.sampleRate * 5, 1); \cf3 // a 5 second 1 channel Buffer\cf0 \
	\
	\cf3 // record for four seconds\cf0 \
	(\
	x = \cf2 SynthDef\cf0 (\cf4 "tutorial-RecordBuf"\cf0 ,\{ \cf2 arg\cf0  out=0,bufnum=0;\
		\cf2 var\cf0  noise;\
		noise = \cf2 PinkNoise\cf0 .ar(0.3);		\cf3 // record some PinkNoise\cf0 \
		\cf2 RecordBuf\cf0 .ar(noise, bufnum); 	\cf3 // by default this loops\cf0 \
	\}).play(s,[\cf5 \\out\cf0 , 0, \cf5 \\bufnum\cf0 , b.bufnum]);\
	)\
	\
	\cf3 // free the record synth after a few seconds\cf0 \
	x.free;\
	\
	\cf3 // play it back\cf0 \
	(\
	\cf2 SynthDef\cf0 (\cf4 "tutorial-playback"\cf0 ,\{ \cf2 arg\cf0  out=0,bufnum=0;\
		\cf2 var\cf0  playbuf;\
		playbuf = \cf2 PlayBuf\cf0 .ar(1,bufnum);\
		\cf2 FreeSelfWhenDone\cf0 .kr(playbuf); \cf3 // frees the synth when the PlayBuf has played through once\cf0 \
		\cf2 Out\cf0 .ar(out, playbuf);\
	\}).play(s,[\cf5 \\out\cf0 , 0, \cf5 \\bufnum\cf0 , b.bufnum]);\
	)\
	b.free;\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural

\f1\fs24 \cf0 See the 
\f0\b [\ul RecordBuf\ulnone ]
\f1\b0  help file for details on all of its options.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural

\f0\b\fs28 \cf0 \
Accessing Data\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural

\f1\b0\fs24 \cf0 Buffer has a number of methods to allow you to get or set values in a buffer. Buffer-get and Buffer-set are straightforward to use and take an index as an argument. Multichannel buffers interleave their data, so for a two channel buffer index 0 = frame1-chan1, index 1 = frame1-chan2, index 2 = frame2-chan1, and so on. 'get' takes an action function.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural

\f3\fs18 \cf0 	b = \cf2 Buffer\cf0 .alloc(s, 8, 1);\
	b.set(7, 0.5); 				\cf3 // set the value at 7 to 0.5\cf0 \
	b.get(7, \{\cf2 |msg|\cf0  msg.postln\});	\cf3 // get the value at 7 and post it when the reply is received\cf0 \
	b.free;	\
		
\f1\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural
\cf0 The methods 'getn' and 'setn' allow you to get and set ranges of adjacent values. 'setn' takes a starting index and an array of values to set, 'getn' takes a starting index, the number of values to get, and an action function.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural

\f3\fs18 \cf0 \
	b = \cf2 Buffer\cf0 .alloc(s,16);\
	b.setn(0, [1, 2, 3]);							\cf3 // set the first 3 values\cf0 \
	b.getn(0, 3, \{\cf2 |msg|\cf0  msg.postln\});				\cf3 // get them\cf0 \
	b.setn(0, \cf2 Array\cf0 .fill(b.numFrames, \{1.0.rand\}));	\cf3 // fill the buffer with random values\cf0 \
	b.getn(0, b.numFrames, \{\cf2 |msg|\cf0  msg.postln\});		\cf3 // get them\cf0 \
	b.free;
\f1\fs24 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 There is an upper limit on the number of values you can get or set at a time (usually 1633 when using UDP, the default). This is because of a limit on network packet size. To overcome this Buffer has two methods, 'loadCollection' and 'loadToFloatArray' which allow you to set or get large amounts of data by writing it to disk and then loading to client or server as appropriate.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs18 \cf0 	(\
	\cf3 // make some white noise\cf0 \
	v = \cf2 FloatArray\cf0 .fill(44100, \{1.0.rand2\});\
	b = \cf2 Buffer\cf0 .alloc(s, 44100);\
	)\
	(\
	\cf3 // load the FloatArray into b, then play it\cf0 \
	b.loadCollection(v, action: \{\cf2 |buf|\cf0  \
		x = \{ \cf2 PlayBuf\cf0 .ar(buf.numChannels, buf.bufnum, \cf2 BufRateScale\cf0 .kr(buf.bufnum), loop: 1) \
			* 0.2 \}.play;\
	\});\
	)\
	x.free;\
	\
	\cf3 // now get the FloatArray back, and compare it to v; this posts 'true'\cf0 \
	\cf3 // the args 0, -1 mean start from the beginning and load the whole buffer\cf0 \
	b.loadToFloatArray(0, -1, \{\cf2 |floatArray|\cf0  (floatArray == v).postln \});\
	b.free;
\f1\fs24 \
\
A FloatArray is just a subclass of Array which can only contain floats.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural

\f0\b\fs28 \cf0 \
Plotting and Playing\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 Buffer has two useful convenience methods: 'plot' and 'play'.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs18 \cf0 	\cf3 // see the waveform\cf0 \
	b = \cf2 Buffer\cf0 .read(s,\cf4 "sounds/a11wlk01.wav"\cf0 );\
	b.plot;\
	\
	\cf3 // play the contents\cf0 \
	\cf3 // this takes one arg: loop. If false (the default) the resulting synth is\cf0 \
	\cf3 // freed automatically\cf0 \
	b.play; 				\cf3 // frees itself\cf0 \
	x = b.play(\cf2 true\cf0 );		\cf3 // loops so doesn't free\cf0 \
	x.free; b.free;
\f0\b\fs28 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 	
\f0\b\fs28 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural
\cf0 Other Uses For Buffers
\f1\b0\fs24 \
\
In addition to being used for loading in sound files, buffers are also useful for any situation in which you need large and/or globally accessible data sets on the server. One example of another use for them is as a lookup table for waveshaping. \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs18 \cf0 	b = \cf2 Buffer\cf0 .alloc(s, 512, 1);\
	b.cheby([1,0,1,1,0,1]);\
	(\
	x = play(\{ \
		\cf2 Shaper\cf0 .ar(\
			b.bufnum, \
			\cf2 SinOsc\cf0 .ar(300, 0, \cf2 Line\cf0 .kr(0,1,6)),\
			0.5\
		) \
	\});\
	)\
	x.free; b.free;
\f1\fs24 	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural
\cf0 \
The Shaper UGen performs waveshaping on an input source. The method 'cheby' fills the buffer with a series of chebyshev polynomials, which are needed for this. (Don't worry if you don't understand all this.) Buffer has many similar methods for filling a buffer with different waveforms.\
\
There are numerous other uses to which buffers can be put. You'll encounter them throughout the documentation.\
\
For more information see:
\f0\b  \
\
[\ul Buffer\ulnone ] [\ul PlayBuf\ulnone ] [\ul RecordBuf\ulnone ] [\ul SynthDef\ulnone ] [\ul \ulc0 BufRateScale\ulnone ] [\ul Shaper\ulnone ]\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural

\f1\b0 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 ____________________\
\
This document is part of the tutorial 
\f0\b Getting Started With SuperCollider
\f1\b0 .\
\
Click here to return to the table of Contents: 
\f0\b [\ul Getting Started With SC\ulnone ]}