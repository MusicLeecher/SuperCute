{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red96\green96\blue96;\red0\green0\blue0;
\red0\green0\blue191;\red96\green96\blue96;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 SystemClock
\f1\b0 \
\
superclass: Clock\

\fs24 \
SystemClock is more accurate, but cannot call Cocoa primitives.\
AppClock is less accurate (uses NSTimers) but can call Cocoa primitives.\

\f2\fs18 \

\f0\b\fs24 *sched(delta,task)\

\f1\b0 	the float you return specifies the delta to resched the function for\

\f2\fs18 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 		SystemClock\cf0 .sched(0.0,\{ arg time;  \
			time.postln; \
			rrand(0.1,0.9) \
		\});\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 	returning \cf2 nil\cf0  will stop the task from being rescheduled\

\f2\fs18 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 		SystemClock\cf0 .sched(2.0,\{ \
			\cf3 "2.0 seconds later"\cf0 .postln; \
			\cf2 nil\cf0  \
		\});\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 *clear\

\f1\b0 	clear the AppClock's scheduler to stop it\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf2 \
	SystemClock\cf0 .clear\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 *absSched(time,task)\
	\

\f2\b0\fs18 \cf4 	\cf5 SystemClock\cf4 .schedAbs( (\cf5 thisThread\cf4 .time + 4.0).round(1.0),\{ \cf5 arg\cf4  time;\
		(\cf6 "the time is exactly "\cf4  ++ time.asString ++ \cf6 " seconds since starting SuperCollider")\cf4 .postln;\
	\});\

\f0\b\fs24 			\cf0 	
\f2\b0\fs18 \
	
\f0\b\fs24 \
*play(task)\

\f1\b0 	Calls to the cocoa framework (including all GUI) may not be made directly \
	from actions triggered by SystemClock or incoming socket messages (OSCresponder). \
\
	To do this indirectly, schedule a function using the AppClock and a delta of zero.\
	AppClock.sched(0, function):\

\f2\fs18 \
\
	(\
	\cf2 var\cf0  w, r;\
	w = \cf2 SCWindow\cf0 (\cf3 "trem"\cf0 , \cf2 Rect\cf0 (512, 256, 360, 130));\
	w.front;\
	r = \cf2 Routine\cf0 (\{ arg time;\
			60.do(\{ \cf2 arg\cf0  i;\
				0.05.yield;\
				AppClock.sched(0,\{\
					w.bounds = w.bounds.moveBy(10.rand2, 10.rand2);\
					w.alpha = cos(i*0.1pi)*0.5+0.5;\
				\})\
			\});\
			1.yield;\
			w.close;\
	\});\
	\cf2 SystemClock\cf0 .play(r);\
	)\
\

\f1\fs24 	This example is only to show how to make calls to Cocoa/GUI when scheduling with the SystemClock.\
	If you only wish to control the GUI, use AppClock.\

\f2\fs18 		\

\f1\fs24 \
}