{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue191;\red96\green96\blue96;
\red191\green0\blue0;\red0\green0\blue0;\red0\green0\blue191;\red96\green96\blue96;\red0\green115\blue0;
}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 "Spawning" and "TSpawning"\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 \
In SC2, Spawn and TSpawn were two of the most powerful and commonly used UGens. In SC3 the idea of a top level Synth in which everything is spawned is no longer valid. Synthesis is always running (at least as long as a server is) and new Synths can be created on the fly. This arrangement results in even greater flexibility than in SC2, but requires a slightly different approach.\
\
In SC3 one can create Synths at any time simply by executing blocks of code.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf2 // do this\cf0 \
	(
\f1\fs24 \
	
\f2\fs18 x = \cf3 SynthDef\cf0 (\cf4 "Help-SynthDef"\cf0 , \
		\{ \cf3 arg\cf0  out=0;\
			 \cf3 Out\cf0 .ar(out, \cf3 PinkNoise\cf0 .ar(0.1))\
		\}).play; \cf2 // SynthDef-play returns a Synth object.\cf0 \
	) \
\
\cf2 // then do this\cf0 \
	(\
	\cf3 SynthDef\cf0 (\cf4 "help-Rand"\cf0 , \{ \cf3 arg\cf0  out=0;\
		\cf3 Out\cf0 .ar(out, \
			\cf3 FSinOsc\cf0 .ar(\
				\cf3 Rand\cf0 (200.0, 400.0), 	\cf2 // frequency between 200 and 400 Hz\cf0 \
				0, \cf3 Line\cf0 .kr(0.2, 0, 1, \
				doneAction:2)) 		\cf2 // frees itself\cf0 \
		)\
	\}).play(s);\
	)\
	\
	x.free;
\f1\fs24 \
\
Clocks, such as 
\f0\b SystemClock
\f1\b0 , provide a way to schedule things at arbitrary points in the future. This is similar to Synth.sched in SC2.\
\

\f2\fs18 \cf3 	(\cf0 \
	\cf3 SystemClock\cf0 .sched(2.0,\{ \
		\cf4 "2.0 seconds later"\cf0 .postln; \cf2 // this could be any code, including Synth creation\cf0 \
		\cf3 nil \cf2 // this means don't repeat\cf0  \
	\});\
	)
\f1\fs24 \
\
In SC3 time-based sequences of events can be implemented using Routines. A 
\f0\b Routine
\f1\b0  which yields a number can be scheduled using a clock:\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 	(\
	\cf3 var\cf0  w, r;\
	w = \cf3 SCWindow\cf0 (\cf4 "trem"\cf0 , \cf3 Rect\cf0 (512, 256, 360, 130));\
	w.front;\
	r = \cf3 Routine\cf0 (\{ \cf3 arg\cf0  time;\
			60.do(\{ \cf3 arg\cf0  i;\
				0.05.yield; \cf2 // wait for 0.05 seconds\cf0 \
				\{\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li200\ql\qnatural
\cf0 					w.bounds = w.bounds.moveBy(10.rand2, 10.rand2);\
					w.alpha = cos(i*0.1pi)*0.5+0.5;\
				\}.defer;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 			\});\
			1.yield; \cf2 // wait for 1 second before closing w\cf0 \
			w.close;\
	\});\
	\cf3 SystemClock\cf0 .play(r);\
	)\
		\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 Note that this implementation avoids one of the stranger aspects of the SC2 approach: The need to start a Synth to schedule time-based behavior, even if no audio is involved.\
\
Both 
\f0\b SystemClock
\f1\b0  and 
\f0\b AppClock
\f1\b0  (a less accurate version which can call Cocoa primitives) have only class methods. Thus one does not create instances of them. If you need to have an individual clock to manipulate (for instance to manipulate the tempi of different sequences of events) you can use 
\f0\b TempoClock
\f1\b0 .\
\
A simple SC2 Spawn example is shown below, followed by its translation into SC3 style code.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf2 // This will not execute in SC3\cf0 \
	(\
\
	\cf3 Synth\cf0 .play(\{\
		\cf3 Spawn\cf0 .ar(\{ \
			\cf3 EnvGen\cf0 .ar(Env.perc) * \cf3 SinOsc\cf0 .ar(440,0,0.1)\
		\}, \
		1, \cf2 // one channels\cf0 \
		1) \cf2 // new event every second\cf0 \
	\}))\
	\
\cf2 // The same example in SC3 (will execute)\cf0 \
\
	s = \cf3 Server\cf0 .local;\
	s.boot;\
	(\
	\cf3 SynthDef\cf0 (\cf4 "help-EnvGen"\cf0 ,\{ \cf3 arg\cf0  out=0;\
		\cf3 Out\cf0 .ar(out,\
			\cf3 EnvGen\cf0 .kr(\cf3 Env\cf0 .perc,1.0,doneAction: 2) \
				* \cf3 SinOsc\cf0 .ar(440,0,0.1)\
		)\
	\}).send(s);\
	)\
	\
	(\
	r = \cf3 Routine\cf0 .new(\{ \{ \cf3 Synth\cf0 .new(\cf4 "help-EnvGen"\cf0 , s); 1.yield; \}.loop \}); \cf2 // loop every one second\cf0 \
	\cf3 SystemClock\cf0 .play(r);\
	)	\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 Note that the above example uses a precompiled 
\f0\b SynthDef
\f1\b0 . This results in a lower CPU spike when Synths are created than SC2-style Spawning. It is possible to create SynthDefs on the fly, if this is necessary, but a great deal of variation can be achieved with arguments, or with ugens such as 
\f0\b Rand
\f1\b0  and 
\f0\b TRand
\f1\b0 . See the helpfile 
\f0\b SynthDefsVsSynths 
\f1\b0 for more detail.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf2 // SynthDefs on the fly\cf0 \
\
	s = \cf3 Server\cf0 .local;\
	s.boot;\
	(\
	t = \cf3 TempoClock\cf0 .new;\
	r = \cf3 Routine\cf0 .new(\{ \
		10.do(\{\
			\cf2 // could be done with an argument instead of a new def, but proves the point\cf0 \
			\cf3 SynthDef\cf0 (\cf4 "help-EnvGen"\cf0  ++ i,\{ \cf3 arg\cf0  out=0;\
				\cf3 Out\cf0 .ar(out,\
				\cf3 EnvGen\cf0 .kr(\cf3 Env\cf0 .perc,1.0,doneAction: 2) \
					* \cf3 SinOsc\cf0 .ar(100 + (100 * t.elapsedBeats),0,0.1)\
				)\
			\}).play(s);\
			1.yield;\
		\}); \
	\}).play(t); \cf5 // Note the alternative syntax: Routine.play(aClock)\cf0 \
	)\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 Note the alternative syntax for playing a Routine. aClock.play(aRoutine) and aRoutine.play(aClock) are functionally equivalent. The two make different things more or less convienent, like sending messages to the 
\f0\b Routine
\f1\b0  or 
\f0\b Clock
\f1\b0 . For instance:\
\
\cf6 	
\f2\fs18 (\
	\cf5 // this, that and the other\cf6 \
	r = \cf7 Routine\cf6 .new(\{\cf7 var\cf6  i = 0; \{ (\cf8 "this: "\cf6  ++ i).postln; i = i + 1; 1.yield; \}.loop \});\
	q = \cf7 Routine\cf6 .new(\{\cf7 var\cf6  i = 0; \{ (\cf8 "that: "\cf6  ++ i).postln; i = i + 1; 1.yield; \}.loop \}); \cf5 \
	\cf0 t = \cf3 Routine\cf0 .new(\{\cf3 var\cf0  i = 0; \{ (\cf4 "the other: "\cf0  ++ i).postln; i = i + 1; 1.yield; \}.loop \});\
	)\
	\cf6 \
	\cf7 SystemClock\cf6 .play(r); 	\cf5 // start this\cf6 \
	\cf7 SystemClock\cf6 .play(q); 	\cf5 // start that\
	\cf3 SystemClock\cf0 .play(t); 	\cf2 // start the other\cf6 \
	\
	r.stop; 				\cf5 // stop this but not that or the other\cf6 \
	q.reset;				\cf5 // reset that while playing\
	\cf6 \
	c = \cf7 TempoClock\cf6 .new;	\cf5 // make a TempoClock\cf6 \
	r.reset;				\cf5 // have to reset this because it's stopped\cf6 \
	c.play(r);			\cf5 // play this in the new clock; starts from the beginning\cf6 \
	c.tempo = 16;			\cf5 // increase the tempo of this\
	\cf6 \
	\cf7 SystemClock\cf6 .clear; 	\cf5 // clear EVERYTHING scheduled in the SystemClock; so that and the other \
						// but not this\
						\cf6 \
	c.clear;				\cf5 // clear everything scheduled in c, i.e. this\cf6 \
	c.play(r);			\cf5 // since it wasn't stopped, we don't have to reset this\
						// and it picks up where it left off\
						\cf6 \
	c.stop				\cf5 // stop c, destroy its scheduler, and release its OS thread
\f1\fs24 \cf0 \
\
For convenience pauseable scheduling can be implemented with a 
\f0\b Task
\f1\b0 . Task.new takes two arguments, a function and a clock, and creates it's own 
\f0\b Routine
\f1\b0 . If you don't specify a clock, it will create a 
\f0\b TempoClock
\f1\b0  for you. Since you don't have to explicitly create a Clock or Routine, use of Task can result in code that is a little more compact.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf6 	
\f2\fs18 \cf6 (\
	t = \cf7 Task.\cf6 new(\{ \
			\cf7 inf\cf6 .do(\{ \cf7 arg\cf6  i;\
				i.postln; \
				0.5.wait \
			\}); \
		\});\
	)\
	\
	t.start; 				\cf5 // Start it\cf6 \
	t.stop;				\cf5 // Stop it\cf6 \
	t.start;				\cf5 // Start again from the beginning\cf6 \
	t.reset;				\cf5 // Reset on the fly\cf6 \
	t.stop;				\cf5 // Stop again\cf6 \
	t.resume;				\cf5 // Restart from where you left off\
	\cf6 t.clock.tempo = 0.25;\cf5 	// Get the Task's clock and change the tempo. This works since the\
						// default is a TempoClock.\cf6 \
	t.pause;				\cf5 // Same as t.stop\cf6 \

\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
TSpawn's functionality can be replicated with 
\f0\b SendTrig
\f1\b0  and 
\f0\b OSCresponder
\f1\b0  or 
\f0\b OSCresponderNode
\f1\b0 . See their individual helpfiles for details on their arguments and functionality.\
\
	
\f2\fs18 s = \cf3 Server\cf0 .local;\
	s.boot;\
	\
	(\
	\cf2 // this Synth will send a trigger to the client app\cf0 \
	\cf3 SynthDef\cf0 (\cf4 "help-SendTrig"\cf0 ,\{\
		\cf3 SendTrig\cf0 .kr(\
			\cf3 Dust\cf0 .kr(1.0), \cf2 // trigger could be anything, e.g. Amplitude.kr(AudioIn.ar(1) > 0.5)\cf0 \
			0,0.9\
		); \
	\}).send(s);\
	)\
	\
	(\
	\cf2 // this recieves the trigger on the client side and 'Spawns' a new Synth on the server\cf0 \
	\cf3 OSCresponder\cf0 (s.addr,\cf9 '/tr'\cf0 ,\{ \
		\cf3 SynthDef\cf0 (\cf4 "help-EnvGen"\cf0 ,\{ \cf3 arg\cf0  out=0;\
			\cf3 Out\cf0 .ar(out,\
				\cf3 EnvGen\cf0 .kr(\cf3 Env\cf0 .perc,1.0,doneAction: 2) \
					* \cf3 SinOsc\cf0 .ar(440,0,0.1)\
			)\
		\}).play(s);\
	\}).add;\
	\
	\cf5 // Start 'spawning'\cf0 \
	\cf3 Synth\cf0 (\cf4 "help-SendTrig"\cf0 );\
	)}