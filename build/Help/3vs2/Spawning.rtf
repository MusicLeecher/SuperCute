{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue191;\red96\green96\blue96;
\red191\green0\blue0;\red0\green115\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 "Spawning" and "TSpawning"\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 \
In SC2, Spawn and TSpawn were two of the most powerful and commonly used UGens. In SC3 the idea of a top level Synth in which everything is spawned is no longer valid. Synthesis is always running (at least as long as a server is) and new Synths can be created on the fly. This arrangement results in even greater flexibility than in SC2, but requires a slightly different approach.\
\
In SC3 one can create Synths at any time simply by executing blocks of code.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf2 // do this\cf0 \
	(
\f1\fs24 \
	
\f2\fs18 x = \cf3 SynthDef\cf0 (\cf4 "Help-SynthDef"\cf0 , \
		\{ \cf3 arg\cf0  out=0;\
			 \cf3 Out\cf0 .ar(out, \cf3 PinkNoise\cf0 .ar(0.1))\
		\}).play; \
	) \
\
\cf2 // then do this\cf0 \
	(\
	\cf3 SynthDef\cf0 (\cf4 "help-Rand"\cf0 , \{ \cf3 arg\cf0  out=0;\
		\cf3 Out\cf0 .ar(out, \
			\cf3 FSinOsc\cf0 .ar(\
				\cf3 Rand\cf0 (200.0, 400.0), 	\cf2 // frequency between 200 and 400 Hz\cf0 \
				0, \cf3 Line\cf0 .kr(0.2, 0, 1, \
				doneAction:2)) 		\cf2 // frees itself\cf0 \
		)\
	\}).play(s);\
	)\
	\
	x.free;
\f1\fs24 \
\
Clocks, such as 
\f0\b SystemClock
\f1\b0 , provide a way to schedule things at arbitrary points in the future. This is similar to Synth.sched in SC2.\
\

\f2\fs18 \cf3 	(\cf0 \
	\cf3 SystemClock\cf0 .sched(2.0,\{ \
		\cf4 "2.0 seconds later"\cf0 .postln; \cf2 // this could be any code, including Synth creation\cf0 \
		\cf3 nil \cf5 // this means don't repeat\cf0  \
	\});\
	)
\f1\fs24 \
\
In SC3 time-based sequences of events can be implemented using Routines. A 
\f0\b Routine
\f1\b0  which yields a number can be scheduled using a clock:\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 	(\
	\cf3 var\cf0  w, r;\
	w = \cf3 SCWindow\cf0 (\cf4 "trem"\cf0 , \cf3 Rect\cf0 (512, 256, 360, 130));\
	w.front;\
	r = \cf3 Routine\cf0 (\{ \cf3 arg\cf0  time;\
			60.do(\{ \cf3 arg\cf0  i;\
				0.05.yield; \cf2 // wait for 0.05 seconds\cf0 \
				\{\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li200\ql\qnatural
\cf0 					w.bounds = w.bounds.moveBy(10.rand2, 10.rand2);\
					w.alpha = cos(i*0.1pi)*0.5+0.5;\
				\}.defer;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 			\});\
			1.yield; \cf2 // wait for 1 second before closing w\cf0 \
			w.close;\
	\});\
	\cf3 SystemClock\cf0 .play(r);\
	)\
		\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 Note that this implementation avoids one of the stranger aspects of the SC2 approach: The need to start a Synth to schedule time-based behavior, even if no audio is involved.\
\
Both 
\f0\b SystemClock
\f1\b0  and 
\f0\b AppClock
\f1\b0  (a less accurate version which can call Cocoa primitives) have only class methods. Thus one does not create instances of them. If you need to have an individual clock to manipulate (for instance to manipulate the tempi of different sequences of events) you can use 
\f0\b TempoClock
\f1\b0 .\
\
A simple SC2 Spawn example is shown below, followed by its translation into SC3 style code.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf2 // This will not execute in SC3\cf0 \
	(\
\
	\cf3 Synth\cf0 .play(\{\
		\cf3 Spawn\cf0 .ar(\{ \
			\cf3 EnvGen\cf0 .ar(Env.perc) * \cf3 SinOsc\cf0 .ar(440,0,0.1)\
		\}, \
		1, \cf2 // one channels\cf0 \
		1) \cf2 // new event every second\cf0 \
	\}))\
	\
\cf2 // The same example in SC3 (will execute)\cf0 \
\
	s = \cf3 Server\cf0 .local;\
	s.boot;\
	(\
	\cf3 SynthDef\cf0 (\cf4 "help-EnvGen"\cf0 ,\{ \cf3 arg\cf0  out=0;\
		\cf3 Out\cf0 .ar(out,\
			\cf3 EnvGen\cf0 .kr(\cf3 Env\cf0 .perc,1.0,doneAction: 2) \
				* \cf3 SinOsc\cf0 .ar(440,0,0.1)\
		)\
	\}).send(s);\
	)\
	\
	(\
	r = \cf3 Routine\cf0 .new(\{ \{ \cf3 Synth\cf0 .new(\cf4 "help-EnvGen"\cf0 , s); 1.yield; \}.loop \}); \cf2 // loop every one second\cf0 \
	\cf3 SystemClock\cf0 .play(r);\
	)	\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 Note that the above example uses a precompiled 
\f0\b SynthDef
\f1\b0 . This results in a lower CPU spike when Synths are created than SC2-style Spawning. It is possible to create SynthDefs on the fly, if this is necessary, but a great deal of variation can be achieved with arguments, or with ugens such as 
\f0\b Rand
\f1\b0  and 
\f0\b TRand
\f1\b0 . See the helpfile 
\f0\b SynthDefsVsSynths 
\f1\b0 for more detail.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf2 // SynthDefs on the fly\cf0 \
\
	s = \cf3 Server\cf0 .local;\
	s.boot;\
	(\
	t = \cf3 TempoClock\cf0 .new;\
	r = \cf3 Routine\cf0 .new(\{ \
		10.do(\{\
			\cf2 // could be done with an argument instead of a new def, but proves the point\cf0 \
			\cf3 SynthDef\cf0 (\cf4 "help-EnvGen"\cf0  ++ i,\{ \cf3 arg\cf0  out=0;\
				\cf3 Out\cf0 .ar(out,\
				\cf3 EnvGen\cf0 .kr(\cf3 Env\cf0 .perc,1.0,doneAction: 2) \
					* \cf3 SinOsc\cf0 .ar(100 + (100 * t.elapsedBeats),0,0.1)\
				)\
			\}).play(s);\
			1.yield;\
		\}); \
	\});\
	t.play(r);\
	)\
	\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 TSpawn's functionality can be replicated with 
\f0\b SendTrig
\f1\b0  and 
\f0\b OSCresponder
\f1\b0  or 
\f0\b OSCresponderNode
\f1\b0 . See their individual helpfiles for detail on their arguments and functionality.\
\
	
\f2\fs18 s = \cf3 Server\cf0 .local;\
	s.boot;\
	\
	(\
	\cf2 // this Synth will send a trigger to the client app\cf0 \
	\cf3 SynthDef\cf0 (\cf4 "help-SendTrig"\cf0 ,\{\
		\cf3 SendTrig\cf0 .kr(\
			\cf3 Dust\cf0 .kr(1.0), \cf2 // trigger could be anything, e.g. Amplitude.kr(AudioIn.ar(1) > 0.5)\cf0 \
			0,0.9\
		); \
	\}).send(s);\
	)\
	\
	(\
	\cf2 // this recieves the trigger on the client side and 'Spawns' a new Synth on the server\cf0 \
	\cf3 OSCresponder\cf0 (s.addr,\cf6 '/tr'\cf0 ,\{ \
		\cf3 SynthDef\cf0 (\cf4 "help-EnvGen"\cf0 ,\{ \cf3 arg\cf0  out=0;\
			\cf3 Out\cf0 .ar(out,\
				\cf3 EnvGen\cf0 .kr(\cf3 Env\cf0 .perc,1.0,doneAction: 2) \
					* \cf3 SinOsc\cf0 .ar(440,0,0.1)\
			)\
		\}).play(s);\
	\}).add;\
	\
	\cf3 Synth\cf0 (\cf4 "help-SendTrig"\cf0 );\
	)}