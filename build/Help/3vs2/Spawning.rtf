{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red96\green96\blue96;\red191\green0\blue0;
\red191\green0\blue0;\red0\green0\blue0;\red0\green0\blue191;\red96\green96\blue96;\red0\green115\blue0;
}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 "Spawning" and "TSpawning"\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 \
In SC2, Spawn and TSpawn were two of the most powerful and commonly used UGens. In SC3 the idea of a top level Synth in which everything is spawned is no longer valid. Synthesis is always running (at least as long as a server is) and new Synths can be created on the fly. This arrangement results in even greater flexibility than in SC2, but requires a slightly different approach.\
\
In SC3 time-based sequences of events can be implemented using Routines. A 
\f0\b Routine
\f1\b0  which yields a number can be scheduled using a clock, such as 
\f0\b SystemClock
\f1\b0 :\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 	(\
	\cf2 var\cf0  w, r;\
	w = \cf2 SCWindow\cf0 (\cf3 "trem"\cf0 , \cf2 Rect\cf0 (512, 256, 360, 130));\
	w.front;\
	r = \cf2 Routine\cf0 (\{ \cf2 arg\cf0  time;\
			60.do(\{ \cf2 arg\cf0  i;\
				0.05.yield; \cf4 // wait for 0.05 seconds\cf0 \
				\{\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li200\ql\qnatural
\cf0 					w.bounds = w.bounds.moveBy(10.rand2, 10.rand2);\
					w.alpha = cos(i*0.1pi)*0.5+0.5;\
				\}.defer;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 			\});\
			1.yield; \cf4 // wait for 1 second before closing w\cf0 \
			w.close;\
	\});\
	\cf2 SystemClock\cf0 .play(r);\
	)\
		\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 Note that this implementation avoids one of the stranger aspects of the SC2 approach: The need to instantiate a Synth to schedule time-based behavior, even if no audio is involved.\
\
Both 
\f0\b SystemClock
\f1\b0  and 
\f0\b AppClock
\f1\b0  (a less accurate version which can call Cocoa primitives) have only class methods. Thus one does not create instances of them. If you need to have an individual clock to manipulate (for instance to manipulate the tempi of different sequences of events) you can use 
\f0\b TempoClock
\f1\b0 .\
\
A simple SC2 Spawn example is shown below, followed by its translation into SC3 style code.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf5 // This will not execute in SC3\cf6 \
	(\
\
	\cf7 Synth\cf6 .play(\{\
		\cf7 Spawn\cf6 .ar(\{ \
			\cf7 EnvGen\cf6 .ar(Env.perc) \cf0 * \cf2 SinOsc\cf0 .ar(440,0,0.1)\cf6 \
		\}, \
		1, \cf5 // one channels\cf6 \
		1) \cf5 // new event every second\cf6 \
	\}))\
	\
\cf5 // The same example in SC3 (will execute)\cf6 \
\
	s = \cf7 Server\cf6 .local;\
	s.boot;\
	(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf6 	\cf7 SynthDef\cf6 (\cf8 "help-EnvGen"\cf6 ,\{ \cf7 arg\cf6  out=0;\
		\cf7 Out\cf6 .ar(out,\
			\cf7 EnvGen\cf6 .kr(\cf7 Env\cf6 .perc,1.0,doneAction: 2) \
				* \cf7 SinOsc\cf6 .ar(440,0,0.1)\
		)\
	\}).send(s);\
	)\
	\
	(\
	r = \cf7 Routine\cf6 .new(\{ \{ \cf7 Synth\cf6 .new(\cf8 "help-EnvGen"\cf6 , s); 1.yield; \}.loop \});\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf6 	\cf7 SystemClock\cf6 .play(r);\
	)	\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 Note that the above example uses a precompiled 
\f0\b SynthDef
\f1\b0 . This results in a lower CPU spike when Synths are created than SC2-style Spawning. It is possible to create SynthDefs on the fly, if this is necessary, but a great deal of variation can be achieved with arguments, or with ugens such as 
\f0\b Rand
\f1\b0  and 
\f0\b TRand
\f1\b0 . See the helpfile 
\f0\b SynthDefsVrsSynths 
\f1\b0 for more detail.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf4 // SynthDefs on the fly\cf0 \
\
	s = \cf2 Server\cf0 .local;\
	s.boot;\
	(\cf6 \
	t = \cf7 TempoClock\cf6 .new;\
	r = \cf7 Routine\cf6 .new(\{ \
		10.do(\{\
			\cf5 // could be done with an argument instead of a new def, but proves the point\cf6 \
			\cf7 SynthDef\cf6 (\cf8 "help-EnvGen"\cf6  ++ i,\{ \cf7 arg\cf6  out=0;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf6 				\cf7 Out\cf6 .ar(out,\
				\cf7 EnvGen\cf6 .kr(\cf7 Env\cf6 .perc,1.0,doneAction: 2) \
					* \cf7 SinOsc\cf6 .ar(100 + (100 * t.elapsedBeats),0,0.1)\
				)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf6 			\}).play(s);\
			1.yield;\
		\}); \
	\});\
	t.play(r);\
	\cf0 )\
	\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 TSpawn's functionality can be replicated with 
\f0\b SendTrig
\f1\b0  and 
\f0\b OSCresponder
\f1\b0  or 
\f0\b OSCresponderNode
\f1\b0 . See their individual helpfiles for detail on their arguments and functionality.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 	
\f2\fs18 \cf6 s = \cf7 Server\cf6 .local;\
	s.boot;\
	\
	(\
	\cf5 // this Synth will send a trigger to the client app\cf6 \
	\cf7 SynthDef\cf6 (\cf8 "help-SendTrig"\cf6 ,\{\
		\cf7 SendTrig\cf6 .kr(\
			\cf7 Dust\cf6 .kr(1.0), \cf5 // trigger could be anything, e.g. Amplitude.kr(AudioIn.ar(1) > 0.5)\cf6 \
			0,0.9\
		); \
	\}).send(s);\
	)\
	\
	(\
	\cf5 // this recieves the trigger on the client side and 'Spawns' a new Synth on the server\cf6 \
	\cf7 OSCresponder\cf6 (s.addr,\cf9 '/tr'\cf6 ,\{ \
		\cf7 SynthDef\cf6 (\cf8 "help-EnvGen"\cf6 ,\{ \cf7 arg\cf6  out=0;\
			\cf7 Out\cf6 .ar(out,\
				\cf7 EnvGen\cf6 .kr(\cf7 Env\cf6 .perc,1.0,doneAction: 2) \
					* \cf7 SinOsc\cf6 .ar(440,0,0.1)\
			)\
		\}).play(s);\
	\}).add;\
	\
	\cf7 Synth\cf6 (\cf8 "help-SendTrig"\cf6 );\
	)}