{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red0\green0\blue191;\red191\green0\blue0;
\red96\green96\blue96;\red0\green115\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 SynthDefs versus Synths\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 \
In SC2 Synth.play was the standard way to compile a ugenGraphFunc and play it. Each time you executed Synth.play, or Spawned a new event, that function was compiled anew. SC3 makes use of SynthDefs. A 
\f0\b SynthDef
\f1\b0  takes a ugenGraphFunc and compiles it to a kind of bytecode (sort of like Java bytecode) which can be understood by the server app. The server reads the SynthDef and creates a 
\f0\b Synth
\f1\b0  node based upon it.\
\
SynthDefs can be precompiled and saved to disk. Any def saved in the synthdefs/ directory (or in any directory set in the environment variable SC_SYNTHDEF_PATH) will be loaded into memory by a local 
\f0\b Server
\f1\b0  when it is booted. If the def being used in a new 
\f0\b Synth
\f1\b0  is already compiled and loaded, there is much less of a CPU spike when creating a new Synth than there was in SC2.\
\
SynthDefs can also be compiled and loaded into the Server while performing without writing them to disk.\
\
The downside of this is that precompiled SynthDefs lack some of the programmatic flexibility that was one SC2's great strengths. Much of this flexibility is gained back however, through the ability to set and change arguments, and through new ugens such as 
\f0\b Rand
\f1\b0  and 
\f0\b TRand
\f1\b0 .\
\
When maximum flexibility is required, it is still possible to compile and send SynthDefs 'on the fly', but with SC2-like CPU spikes and a small amount of messaging latency.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs26 \cf0 \ul Examples
\f1\b0\fs24 \ulnone \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf2 (\
s = \cf3 Server\cf2 .local;\
s.boot;\
)\
\
\cf4 // Compile a SynthDef and write it to disk\cf2 \
	(\
	\cf3 SynthDef\cf2 (\cf5 "Help-SynthDef"\cf2 , \
		\{ \cf3 arg\cf2  out=0;\
			 \cf3 Out\cf2 .ar(out, \cf3 PinkNoise\cf2 .ar(0.1))\
		\}).writeDefFile;\
	)\
\
\cf4 // Compile, write, and load it to the server\cf2 \
	(\
	\cf3 SynthDef\cf2 (\cf5 "Help-SynthDef"\cf2 , \
		\{ \cf3 arg\cf2  out=0;\
			 \cf3 Out\cf2 .ar(out, \cf3 PinkNoise\cf2 .ar(0.1))\
		\}).load(s);\
	)\
	\
\cf4 // Load it to the server without writing to disk\cf2 \
	(\
	\cf3 SynthDef\cf2 (\cf5 "Help-SynthDef"\cf2 , \
		\{ \cf3 arg\cf2  out=0;\
			 \cf3 Out\cf2 .ar(out, \cf3 PinkNoise\cf2 .ar(0.1))\
		\}).send(s);\
	)\
	\
\cf4 // Create a Synth with it\cf2 \
	x = \cf3 Synth\cf2 .new(\cf5 "Help-SynthDef"\cf2 , s);\
	x.free;
\f1\fs24 \
	\

\f2\fs18 \cf4 // shorthand method to compile and write a SynthDef, and then play it in a Synth. Look familiar?\cf2 \
	(
\f1\fs24 \
	
\f2\fs18 x = \cf3 SynthDef\cf2 (\cf5 "Help-SynthDef"\cf2 , \
		\{ \cf3 arg\cf2  out=0;\
			 \cf3 Out\cf2 .ar(out, \cf3 PinkNoise\cf2 .ar(0.1))\
		\}).play;\
	)\
		\
	x.set(\cf6 \\out\cf2 , 1); \cf4 // change one of the arguments\cf2 \
	x.free;\
	\
\cf4 // SynthDef with a parameter that will be randomly determined each time a new Synth is created\
// (try it several times to hear the differences)\cf2 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 	(\cf2 \
	\cf3 SynthDef\cf2 (\cf5 "help-Rand"\cf2 , \{ \cf3 arg\cf2  out=0;\
		\cf3 Out\cf2 .ar(out, \
			\cf3 FSinOsc\cf2 .ar(\
				\cf3 Rand\cf2 (200.0, 400.0), \cf4 // frequency between 200 and 400 Hz\cf2 \
				0, \cf3 Line\cf2 .kr(0.2, 0, 1, doneAction:2))\
		)\
	\}).play;\
	\cf0 )}