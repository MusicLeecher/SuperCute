{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red191\green0\blue0;\red0\green0\blue191;
\red0\green0\blue0;\red191\green0\blue0;\red0\green115\blue0;\red96\green96\blue96;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 Backwards Compatibility
\f1\b0\fs24 \
\
There are a number of classes and methods that have been added to allow for backwards compatibility with SC2 code. The most notable of these is Synth.play, which is basically a wrapper for Function.play.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \{ \cf2 SinOsc\cf0 .ar(440, 0, 0.5) \}.play; \cf3 // creates an arbitrarily named SynthDef and a Synth to play it\cf0 \
\cf2 Synth\cf0 .play(\{ \cf2 SinOsc\cf0 .ar(440, 0, 0.5) \}); \cf3 // in SC3 just a wrapper for Function.play with fewer args\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
Both of these will create synth nodes on the default server. Note that neither requires the use of an Out.ar ugen; they simply output to the first audio bus. One can however add an Out to Function.play in order to specify.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf4 Synth\cf5 .play(\{ \cf4 Out\cf5 .ar(1, \cf4 SinOsc\cf5 .ar(440, 0, 0.5)) \});
\f1\fs24 \cf0 \
\
In general, one should be aware of this distinction when using this code. When copying such code for reuse with other SC3 classes (for example in a reusable SynthDef), it will usually be necessary to add an Out.ar. Although useful for quick testing these methods are generally inferior to SynthDef.play, as the latter is more direct, requires no modifications for general reuse, has greater general flexibility and has slightly less overhead. (Although this is insignificant in most cases, it could be relevant when large numbers of defs or nodes are being created.) \
\
Like SynthDef.play, Function.play returns a Synth object which can then be messaged, etc. However, since Function.play creates an arbitrarily named SynthDef, one cannot reuse the resulting def, at least not without reading its name from the post window, or getting it from the Synth object.\
\

\f2\fs18 \cf6 //The following examples are functionally equivalent\cf5 \
x = \{ \cf4 arg\cf5  freq = 440; \cf4 Out\cf5 .ar(1, \cf4 SinOsc\cf5 .ar(freq, 0, 0.5)) \}.play(fadeTime: 0); \
x.set(\cf7 \\freq\cf5 , 880); 		\cf6 // you can set arguments\cf5 \
y = \cf4 Synth\cf5 .new(x.defName); 	\cf6 // get the arbitrary defname from x\cf5 \
x.free;\
y.free;\
\
x = \cf4 SynthDef\cf5 (\cf8 "backcompat-sine"\cf5 , \{ \cf4 arg\cf5  freq = 440; \cf4 Out\cf5 .ar(1, \cf4 SinOsc\cf5 .ar(freq, 0, 0.5)) \}).play; \
x.set(\cf7 \\freq\cf5 , 880);\
y = \cf4 Synth\cf5 .new(\cf8 "backcompat-sine"\cf5 );\
x.free;\
y.free;
\fs20 \cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 Function.play is in general superior to both its SC2 equivalent and Synth.play. It has a number of significant features such as the ability to specify the output bus and fade times as arguments. See the 
\f0\b Function
\f1\b0  helpfile for a more in-depth discussion.\
\
A number of other classes and methods have also been added to improve compatibility. These are listed below. In general there are equivalent or better ways of doing the same things in SC3.\
\

\f0\b Synth *play			
\f1\b0 use Function.play or SynthDef.play
\f0\b \
GetFileDialog
\f1\b0   			use CocoaDialog\

\f0\b GetStringDialog
\f1\b0 \

\f0\b Synth *stop
\f1\b0 			use Server.freeAll\

\f0\b Synth *isPlaying
\f1\b0 		Server.numSynths (this will include non-running nodes)\

\f0\b Mix *ar *arFill	
\f1\b0 		use Mix *new and *fill\

\f0\b SimpleNumber.rgb
\f1\b0 \

\f0\b Rawarray.write}