{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue191;\red96\green96\blue96;
\red191\green0\blue0;\red0\green0\blue0;\red96\green96\blue96;\red0\green0\blue191;\red0\green115\blue0;
\red0\green115\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 Synchronous and Asynchronous Execution\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 \
Using a program such as SuperCollider introduces a number of issues regarding timing and order of execution. Realtime audio synthesis requires that samples are calculated and played back at a certain rate and on a certain schedule, in order to avoid dropouts, glitches, etc. Other tasks, such as loading a sample into memory, might take arbitrary amounts of time, and may not be needed within a definite timeframe. This is the difference between synchronous and asynchronous tasks.\
\
Problems can arise when synchronous tasks are dependent upon the completion of asynchronous ones. For instance trying to play a sample that may or may not have been completely loaded yet.\
\
In SC2 this was relatively simple to handle. One scheduled synchronous tasks during synthesis, i.e. within the scope of a Synth.play. Asynchronous tasks were executed in order, outside of synthesis. Thus one would first create buffers, load samples into them, and then start synthesis and play them back. The interpreter made sure that each step was only done when the necessary previous step had been completed.\
\
In SC3 the separation of language and synth apps creates a problem: How does one side know that the other has completed necessary tasks, or in other words, how does the left hand know if the right is finished? The flexibility gained by the new architecture introduces another layer of complexity, and an additional demand on the user.\
\
A simple way to deal with this is to execute code in blocks. In the following code, for instance, each block or line of code is dependent upon the previous one being completed.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf2 // Execute these one at a time\
\
// Boot the local Server
\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 	
\f2\fs18 (\
	s = \cf3 Server\cf0 .local;\
	s.boot;\
	)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // Compile a SynthDef and write it to disk\cf0 \
	(\
	\cf3 SynthDef\cf0 (\cf4 "Help-SynthDef"\cf0 , \
		\{ \cf3 arg\cf0  out=0;\
			 \cf3 Out\cf0 .ar(out, \cf3 PinkNoise\cf0 .ar(0.1))\
		\}).writeDefFile;\
	)\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf5 // Load it into the server\cf6 \
	s.loadSynthDef(\cf7 "Help-SynthDef"\cf6 );\cf0 \
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // Create a Synth with it\cf0 \
	x = \cf3 Synth\cf0 .new(\cf4 "Help-SynthDef"\cf0 , s);\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf5 // Free the node on the server\cf6 \
	x.free;\
\
\cf5 // Allow the client-side Synth object to be garbage collected\cf6 \
	x = \cf8 nil\cf6 ; 
\f1\fs24 \cf0  \
\
In the previous example it was necessary to use interpreter variables (the variables a-z, which are declared at compile time) in order to refer to previously created objects in later blocks or lines of code. If one had declared a variable within a block of code (i.e.\cf8  
\f2\fs18 va\cf6 r\cf0  mySynth;
\f1\fs24 ) than it would have only persisted within that scope. (See the helpfile 
\f0\b Scope
\f1\b0  for more detail.)\
\
This style of working, executing lines or blocks of code one at a time, can be very dynamic and flexible, and can be quite useful in a performance situation, especially when improvising. But it does raise the issues of scope and persistence. Another way around this that allows for more descriptive variable names, is to use environment variables (i.e. names that begin with ~, so ~mysynth; see the 
\f0\b Environment
\f1\b0  helpfile for details). However, in both methods you become responsible for making sure that objects and nodes do not persist when you no longer need them. \

\f2\fs18 \
\cf6 	(\
	\cf8 SynthDef\cf6 (\cf7 "Help-SynthDef"\cf6 , \
		\{ \cf8 arg\cf6  out=0;\
			 \cf8 Out\cf6 .ar(out, \cf8 PinkNoise\cf6 .ar(0.1))\
		\}).send(s);\
	)\
	\
	\cf5 // make a Synth and assign it to an environment variable\cf6 \
	~mysynth = \cf8 Synth\cf6 .new(\cf7 "Help-SynthDef"\cf6 , s);\
	\
	\cf5 // free the synth\cf6 \
	~mysynth.free;\
	\
	\cf5 // but you've still got a Synth object\cf6 \
	~mysynth.postln;\
	\
	\cf5 // so remove it from the Environment so that the Synth will be garbage collected\cf6 \
	currentEnvironment.removeAt(\cf9 \\mysynth\cf6 );\cf0 \
	
\f1\fs24 \
But what if you want to have one block of code which contains a number of synchronous and asynchronous tasks. The following will cause an error, as the SynthDef that the server needs has not yet been received.\
\

\f2\fs18 \cf5 // Doing this all at once produces the error "FAILURE /s_new SynthDef not found"
\f1\fs24 \cf6 \

\f2\fs18 \cf6 	(\
	\cf8 var\cf6  name;\
	name = \cf7 "Rand-SynthDef"\cf6  ++ 400.0.rand; \cf5 // use a random name to ensure it's not already loaded\cf6 \
	\cf8 SynthDef\cf6 (name, \
		\{ \cf8 arg\cf6  out=0;\
			 \cf8 Out\cf6 .ar(out, \cf8 PinkNoise\cf6 .ar(0.1))\
		\}).send(s);\
	\
	\cf8 Synth\cf6 .new(name, s);\
	)\
	
\f1\fs24 \cf0 \
A crude solution would be to schedule the dependant code for execution after a seemingly sufficient delay using a clock.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf2 // This one works since the def gets to the server app first
\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 	(\
	\cf3 var\cf0  name;\
	name = \cf4 "Rand-SynthDef"\cf0  ++ 400.0.rand;\
	\cf3 SynthDef\cf0 (name, \
		\{ \cf3 arg\cf0  out=0;\
			 \cf3 Out\cf0 .ar(out, \cf3 PinkNoise\cf0 .ar(0.1))\
		\}).send(s);\
	\
	SystemClock.sched(0.05, \{\cf3 Synth\cf0 .new(name, s);\}); // create a Synth after 0.05 seconds\
	)
\f1\fs24 \
\
Although this works, it's not very elegant or efficient. What would be better would be to have the next thing execute immediately upon the previous thing's completion. To explore this, we'll look at an example which is already implemented.\
\
You may have realized that first example above was needlessly complex. SynthDef-play will do all of this compilation, sending and Synth creation in one stroke.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf2 // All at once\cf0 \
	(\
	\cf3 SynthDef\cf0 (\cf4 "Help-SynthDef"\cf0 , \
		\{ \cf3 arg\cf0  out=0;\
			 \cf3 Out\cf0 .ar(out, \cf3 PinkNoise\cf0 .ar(0.1))\
		\}).play(s);\
	)\
	
\f1\fs24 \
Let's take a look at the method definition for SynthDef-play and see what it does.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf6 	play \{ \cf8 arg\cf6  target,args,addAction=\cf9 \\addToTail\cf6 ;\
		\cf8 var\cf6  synth, msg;\
		target = target.asTarget;\
		\
		synth = \cf8 Synth\cf6 .basicNew(name,target.server); \cf5 // create a Synth, but not a synth node \cf6 \
		msg = synth.newMsg(target, addAction, args);\cf5 // make a message that will add a synth node \cf6 \
		\cf8 this\cf6 .send(target.server, msg); \cf5 // ** send the def, and the message as a completion message\cf6 \
		^synth \cf5 // return the Synth object\cf6 \
	\}
\f1\fs24 \cf0 \
\
This might seem a little complicated if you're not used to mucking about in class definitions, but the important part is the second argument to 
\f2\fs18 \cf3 this\cf0 .send(target.server, msg);
\f1\fs24 . This argument is a completion message, it is a message that will be sent to the server when the send action is complete. In this case it says create a synth node on the server which corresponds to the 
\f0\b Synth
\f1\b0  object I've already created, when and only when the def has been sent to the server app. How does we know when this has happened? Because the server app sends a 'done' message back to the language app. (See the helpfile 
\f0\b Server-Command-Reference 
\f1\b0 for details on messaging.)\
\
Many methods in SC have the option to include completion messages. SynthDef-play is actually one of them:\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf2 // Compile, send, and start playing; change the output channel to right as soon as you're done\cf0 \
	(\
	x = \cf3 SynthDef\cf0 (\cf4 "Help-SynthDef"\cf0 , \
		\{ \cf3 arg\cf0  out=0;\
			 \cf3 Out\cf0 .ar(out, \cf3 PinkNoise\cf0 .ar(0.1))\
		\}).play(s, ["/n_set", x.nodeID, "out", 1]);\
	)\
	\
	x.free;
\f1\fs24 \
\
The completion message need not be an OSC message, it can also be some code to be evaluated:\
\

\f2\fs18 \cf2 // Interpret some code on completion. The .value is needed.
\f1\fs24 \cf0 \
	
\f2\fs18 (
\f1\fs24 \cf6 \
	
\f2\fs18 \cf8 SynthDef\cf6 (\cf7 "Help-SynthDef"\cf6 , \
		\{ \cf8 arg\cf6  out=0;\
			 \cf8 Out\cf6 .ar(out, \cf8 PinkNoise\cf6 .ar(0.1))\
		\}).load(s, \{ x = \cf8 Synth\cf6 .new(\cf7 "Help-SynthDef"\cf6 ); \cf7 "Pink Noise"\cf6 .postln \}.value);\
	\cf0 )\
	\
	x.free;\
	
\f1\fs24 \
In the case of 
\f0\b Buffer
\f1\b0  objects a function can be used as a completion message. It will be evaluated and passed the 
\f0\b Buffer
\f1\b0  object as an argument.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 	(\
	\cf3 SynthDef\cf0 (\cf4 "help-Buffer"\cf0 ,\{ \cf3 arg\cf0  out=0,bufnum;\
		\cf3 Out\cf0 .ar( out,\
			\cf3 PlayBuf\cf0 .ar(1,bufnum,\cf3 BufRateScale\cf0 .kr(bufnum))\
		)\
	\}).load(s);\
		\
	y = \cf3 Synth\cf0 .basicNew(\cf4 "help-Buffer"\cf0 ); \cf2 // not sent yet\
\cf0 	b = \cf3 Buffer\cf0 .read(s,\cf4 "sounds/a11wlk01.wav"\cf0 , \
		completionMessage: \{ \cf3 arg\cf0  buffer; \
			\cf2 // synth add its s_new msg to follow \
\cf0 			\cf2 // after the buffer read completes\
\cf0 			y.newMsg(s,\cf10 \\addToTail\cf0 ,[\cf10 \\bufnum\cf0 ,buffer.bufnum])\
		\}); \cf5 // .value NOT needed, unlike in the previous example\cf0 \
	\
	)\
	\
	\cf2 // when done...\
\cf0 	y.free;\
	b.free;\
	
\f1\fs24 \
One can also evaluate a function in response to a 'done' message, or indeed any other one, using an 
\f0\b OSCresponder
\f1\b0  or an 
\f0\b OSCresponderNode
\f1\b0 . The main difference between the two is that the former allows only a single responder per command, where as the latter allows multiple responders. See their respective helpfiles for details.\
\

\f2\fs18 (\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 SynthDef\cf0 (\cf4 "help-SendTrig"\cf0 ,\{\
	\cf3 SendTrig\cf0 .kr(\cf3 Dust\cf0 .kr(1.0), 0, 0.9);\
\}).send(s);\
\
\cf2 // register to receive this message\cf0 \
\cf3 a = OSCresponderNode\cf0 (s.addr, \cf10 '/tr'\cf0 , \{ \cf3 arg\cf0  time, responder, msg;\
	[time, responder, msg].postln;\
\}).add;\
\cf3 b = OSCresponderNode\cf0 (s.addr, \cf10 '/tr'\cf0 , \{ \cf3 arg\cf0  time, responder, msg;\
	"this is another call".postln;\
\}).add;\
)\
\
\
\cf3 x = Synth\cf0 .new(\cf4 "help-SendTrig"\cf0 );\
a.remove;\
b.remove;\
x.free;}