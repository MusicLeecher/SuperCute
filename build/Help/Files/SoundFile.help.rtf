{\rtf1\mac\ansicpg10000\cocoartf824\cocoasubrtf410
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fnil\fcharset77 Monaco;\f2\fswiss\fcharset77 Helvetica;
\f3\fswiss\fcharset77 Helvetica-Oblique;\f4\fmodern\fcharset77 Courier;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red96\green96\blue96;\red191\green0\blue0;
}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 SoundFile
\f1\b0\fs18 \
\

\f2\fs24 In most cases you will wish to send commands to the server to get it to load SoundFiles directly into Buffers.  You will not use this class for this.  See 
\f0\b Server-Command-Reference.
\f2\b0  \
\
This class is used to check the size, format, channels etc. when the client needs this information about a SoundFile.\
\
Some manipulation of the sound file data is possible. Soundfile data can be read and written incrementally, so with properly designed code, there is no restriction on the file size.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 \
\
(\
\
f = \cf2 SoundFile\cf0 .new;\
\
f.openRead(\cf3 "sounds/a11wlk01.wav"\cf0 );\
\
f.inspect;\
\
f.close;\
\
\
)
\f2\fs24 \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 \ul \ulc0 Creating\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs24 \cf0 \ulnone \

\f0\b *new\

\f2\b0 \
Creates a new SoundFile instance. \
\

\f0\b *collect(pattern = "sounds/*")\
\

\f2\b0 Returns an array of SoundFile objects whose paths match the pattern.  \
(The associated files are closed. These objects can be used to cue playback buffers)\
\

\f0\b\fs28 Playback
\f2\b0 \

\fs24 \

\f0\b cue(event | Nil, playNow = false)\
\

\f2\b0 Allocates a buffer and cues the SoundFile for playback. Returns an event parameterized to play that buffer.\
(See 
\f0\b NodeEvent 
\f2\b0 for a description of how events can be used to control running synths.)\
The event responds to 
\f0\b play, stop, pause, resume
\f2\b0 , keeping both the file and buffer open.\
The file is closed and the  buffer is freed when the event is sent a 
\f0\b close 
\f2\b0 message.\
\

\f0\b arguments
\f2\b0 \

\f0\b 	event | Nil\
	
\f2\b0 An 
\f0\b event 
\f2\b0 can passed as an argument allowing playback to be customized using the following keys:\
	\
	
\f0\b 	key			default value			what it does\
	
\f2\b0 	\
		// buffer and playback position:	\
		bufferSize		65536\
		firstFrame		0					first frame to play\
		lastFrame		nil					last frame to play (nil plays to end of file)\
	\
		// synth parameters\
		out:			0					sets output bus\
		server:		Server.default			which server\
		group:		1					what target\
		addAction:	0					head/tail/before/after\
		amp:			1					amplitude\
	\
		instrument:	nil					if nil SoundFile:cue determines the SynthDef\
										(one of diskIn1, diskIn2, ...diskIn16)\
										\
		Here is the default SynthDef used for stereo files:\
	
\f1\fs18 \cf2 \
		SynthDef\cf0 (\cf3 "diskIn2"\cf0 , \{ \cf2 | bufnum, out,  gate = 1, sustain,  amp = 1, ar = 0, dr = 0.01 |\cf0 \
			\cf2 Out\cf0 .ar(out, \cf2 DiskIn\cf0 .ar(2, bufnum) \
			* Linen.kr(gate, ar, 1, dr, 2)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural
\cf0 			* \cf2 EnvGen\cf0 .kr(\cf2 Env\cf0 .linen(0, sustain - ar - dr max: 0 ,dr),1, doneAction: 2) * amp)\
		\});\
		\
	
\f2\fs24 	The control 
\f0\b sustain
\f2\b0  determines playback duration based on the firstFrame and lastFrame.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 		The control 
\f0\b gate 
\f2\b0 allows early termination of the playback\
	
\f1\fs18 	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural
\cf0 	
\f0\b\fs24 playNow
\f1\b0\fs18 \
	
\f2\fs24 	This is a boolean that determines whether the file is to be played immediately after cueing.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 			\
	
\f0\b 	example:\
	
\f2\b0 	f = SoundFile.collect("sounds/*")\
		e = f[1].cue;\
		\
		e = f[1].cue( (addAction: 2, group: 1) );	// synth will play ahead of the default group\
		\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 \ul Read/Write\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs24 \cf0 \ulnone \

\f0\b openRead(inPathname)\

\f2\b0 \
Read the header of a file. Answers a Boolean whether the read was successful.\
sets the numFrames,numChannels and sampleRate.  does not set the headerFormat and sampleFormat.\

\f0\b inPathname
\f2\b0  - a String specifying the path name of the file to read.\
\

\f0\b readData(rawArray)
\f2\b0 \
\
Reads the sample data of the file into the raw array you supply. You  must have already called openRead.\
\
The raw array must be a FloatArray. Regardless of the sample format of the file, the array will be populated with floating point values. For integer formats, the floats will all be in the range -1..1.\
\
The size of the FloatArray determines the maximum number of single samples (
\f3\i not
\f2\i0  sample frames) that will be read. If there are not enough samples left in the file, the size of the array after the readData call will be less than the original size.\
\
When you reach EOF, the array's size will be 0. Checking the array size is an effective termination condition when looping through a sound file. See the method channelPeaks for example.\
\

\f0\b openWrite(inPathname)\

\f2\b0 \
Write the header of a file. Answers a Boolean whether the write was successful.\

\f0\b inPathname
\f2\b0  - a String specifying the path name of the file to write.\
\

\f0\b \
writeData(rawArray)
\f2\b0 \
\
Writes the rawArray to the sample data of the file. You  must have already called openWrite.\
\
The raw array must be a FloatArray or Signal, with all values between -1 and 1 to avoid clipping during playback.\
\
Example:\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 (\
f = \cf2 SoundFile\cf0 .new.headerFormat_(\cf3 "AIFF"\cf0 ).sampleFormat_(\cf3 "int16"\cf0 ).numChannels_(1);\
f.openWrite(\cf3 "sounds/sfwrite.aiff"\cf0 );\
	\cf4 // sawtooth\cf0 \
b = \cf2 Signal\cf0 .sineFill(100, (1..20).reciprocal);\
	\cf4 // write multiple cycles (441 * 100 = 1 sec worth)\cf0 \
441.do(\{ f.writeData(b) \});\
f.close;\
)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 \

\f0\b isOpen
\f2\b0 \
answers if the file is open\
\

\f0\b close
\f2\b0 \
closes the file\
\

\f0\b duration
\f2\b0 \
the duration in seconds of the file\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 \ul Normalizing
\f2\b0\fs24 \ulnone \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 *normalize(path, outPath, newHeaderFormat, newSampleFormat, startFrame, numFrames, maxAmp, linkChannels, chunkSize)\
\
normalize(outPath, newHeaderFormat, newSampleFormat, startFrame, numFrames, maxAmp, linkChannels, chunkSize)\

\f2\b0 \
\pard\tx1440\tx2880\tx4320\tx5760\tx7200\ql\qnatural
\cf0 Normalizes a soundfile to a level set by the user. The normalized audio will be written into a second file. \
\

\f0\b Note:
\f2\b0  While the normalizer is working, there is no feedback to the user. It will look like SuperCollider is hung, but it will eventually complete the operation.\
\
Arguments:\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li580\fi-580\ql\qnatural

\f0\b \cf0 path:
\f2\b0  a path to the source file\

\f0\b outPath:
\f2\b0  a path to the destination file\

\f0\b newHeaderFormat:
\f2\b0  the desired header format of the new file; if not specified, the header format of the source file will be used\

\f0\b newSampleFormat:
\f2\b0  the desired sample format of the new file; if not specified, the sample format of the source file will be used\

\f0\b startFrame:
\f2\b0  an index to the sample frame to start normalizing (default 0)\

\f0\b numFrames:
\f2\b0  the number of sample frames to copy into the destination file (default nil, or entire soundfile)\

\f0\b maxAmp:
\f2\b0  the desired maximum amplitude. Provide a floating point number or, if desired, an array to specify a different level for each channel. The default is 1.0.\

\f0\b linkChannels:
\f2\b0  a Boolean specifying whether all channels should be scaled by the same amount. The default is 
\f0\b true
\f2\b0 , meaning that the peak calculation will be based on the largest sample in any channel. If false, each channel's peak will be calculated independently and all channels will be scaled to maxAmp (this would alter the relative loudness of each channel).\

\f0\b chunkSize:
\f2\b0  how many samples to read at once (default is 4194304, or 16 MB) \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
Using the class method (SoundFile.normalize) will automatically open the source file for you. You may also openRead the SoundFile yourself and call normalize on it. In that case, the source path is omitted because the file is already open.\
\
The normalizer may be used to convert a soundfile from one sample format to another (e.g., to take a floating point soundfile produced by SuperCollider and produce an int16 or int24 soundfile suitable for use in other applications).\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 \ul Instance Variables
\f2\b0\fs24 \ulnone \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 <path
\f2\b0 \
\
Get the pathname of the file. This variable is set via the openRead or openWrite calls.\
\

\f0\b <>headerFormat
\f2\b0 \
\
This is a String indicating the header format which was read by openRead and will be written by openWrite. In order to write a file with a certain header format you set this variable.\
\
	Sound File Format symbols:\
		header formats:\
			read/write formats:\
				"AIFF", 	- Apple's AIFF\
				"WAV","RIFF" 	- MicrosSoft .WAV\
				"Sun", 	- NeXT/Sun\
				"IRCAM", 	- old IRCAM format\
				"none"	- no header = raw data\
			A huge number of other formats are supported read only.
\f1\fs18 \cf4 \
			\

\f2\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f4 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 <>sampleFormat
\f2\b0 \
\
A String indicating the format of the sample data which was read by openRead and will be written by openWrite. Not all header formats support all sample formats. The possible header formats are:\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f4 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 		sample formats:\
			"int8", "int16", "int24", "int32"\
			"mulaw", "alaw",\
			"float32"\
			\
		not all header formats support all sample formats.
\f1\fs18 \cf4 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f4\fs24 \cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 <numFrames
\f2\b0 \
\
The number of sample frames in the file.\
\

\f0\b <numChannels
\f2\b0 \
\
The number of channels in the file.\
\

\f0\b <>sampleRate
\f2\b0 \
\
The sample rate of the file.\
\
}