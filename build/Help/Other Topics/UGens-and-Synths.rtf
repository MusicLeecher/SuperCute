{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red191\green0\blue0;\red0\green0\blue0;
\red191\green0\blue0;\red0\green0\blue191;\red96\green96\blue96;\red96\green96\blue96;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 Unit Generators and Synths\

\f1\b0\fs24 \
A unit generator is an object that processes or generates sound. There are many classes of unit generators, all of which derive from the class 
\f0\b UGen
\f1\b0 .\
\
Unit generators in SuperCollider can have many inputs, but always have a single output. Unit generator classes which would naturally have several outputs such as a panner, return an array of unit generators when instantiated. The convention of having only a single output per unit generator allows the implementation of multiple channels by using arrays of unit generators. (See 
\f0\b MultiChannel 
\f1\b0 for more details.)\
\

\f0\b\fs28 Instantiation. Audio Rate, Control Rate
\fs24 \

\f1\b0 \
A unit generator is created by sending the 'ar' or 'kr' message to the unit generator's class object. The 'ar' message creates a unit generator that runs at audio rate. The 'kr' message creates a unit generator that runs \
at control rate. Control rate unit generators are used for low frequency or slowly changing control signals. Control rate unit generators produce only a single sample per control cycle and therefore use less processing power than audio rate unit generators.\
\
The input parameters for a unit generator are given in the documentation for that class. \
\

\f2\fs18 \cf2 FSinOsc\cf0 .ar(800, 0.0, 0.2); \cf3 // create a sine oscillator at 800 Hz, phase 0.0, amplitude 0.2
\fs24 \

\f1 \cf0 \
A unit generator's signal inputs can be other unit generators, scalars, or arrays of unit generators and scalars.\
\

\f0\b\fs28 SynthDefs and Synths
\fs24 \

\f1\b0 \
In order to play a unit generator one needs to compile it in a 
\f0\b SynthDef
\f1\b0  and play it on the server in a 
\f0\b Synth
\f1\b0 . A synth node is a container for one or more unit generators that execute together. A SynthDef is like a kind of pattern for creating synth nodes on the server.\

\f2\fs18 \cf2 \
\cf4 s.boot; \cf5 // boot the local server\cf4 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf5 // compile and send this def\cf4 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf6 SynthDef\cf4 .new(\cf7 "FSinOsc-test"\cf4 , \{ \cf6 Out\cf4 .ar(0, \cf6 FSinOsc\cf4 .ar(800, 0, 0.2)) \}).send(s); \cf5 // out channel 0
\fs24 \cf4 \
\

\fs18 \cf5 // now create a Synth object which represents a synth node on the server\cf4 \
x = \cf6 Synth\cf4 .new(\cf8 "FSinOsc-test"\cf4 );\
\
\cf5 // free the synth\cf4 \
x.free;\cf0 \

\fs24 \

\f1 The synth node created above could also be created using 'messaging style', thus saving the overhead of a clientside Synth object:\

\f2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs18 \cf4 n = s.nextNodeID;\
s.sendMsg(\cf7 "/s_new"\cf4 , \cf7 "FSinOsc-test"\cf4 , n);\
s.sendMsg(\cf7 "/n_free"\cf4 , n);
\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 \
See 
\f0\b NodeMessaging
\f1\b0  for more detail.\
\
As a convenience the 'play' method of class 
\f0\b Function
\f1\b0  will compile a SynthDef and create and play a synth using the function for you. With this method an 
\f0\b Out
\f1\b0  ugen will be created for you if you do not do so explicitly.\
\

\fs18 \{ 
\f2 \cf2 FSinOsc\cf0 .ar(800, 0, 0.2) \}.play; \cf3 // create and play a sine oscillator at 800 Hz
\fs24 \
\cf0 \

\f0\b\fs28 Building Patches
\fs24 \

\f1\b0 \
You can do math operations on unit generators and the result will be another unit generator. Doing math on unit generators is not doing any signal calculation itself - it is building the network of unit generators that will execute once they are played in a Synth. This is the essential thing to understand: Synthesis networks, or in other words signal flow graphs are created by executing expressions of unit generators. The following expression creates a flow graph whose root is an instance of 
\f0\b BinaryOpUGen
\f1\b0  which performs the '+' operation. Its inputs are the 
\f0\b FSinOsc
\f1\b0  and 
\f0\b BrownNoise
\f1\b0  unit generators.\
\

\f2\fs18 \cf6 FSinOsc\cf4 .ar(800, 0.0, 0.2) + \cf6 BrownNoise\cf4 .ar(0.2); \cf5 // press enter and look at the post window
\fs24 \cf4 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs18 \cf4 \{\cf6 FSinOsc\cf4 .ar(800, 0.0, 0.2) + \cf6 BrownNoise\cf4 .ar(0.2)\}.play; \cf5 // play it
\fs24 \cf0 \
}