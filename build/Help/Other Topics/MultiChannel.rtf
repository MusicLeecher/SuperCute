{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
\f3\fswiss\fcharset77 Helvetica-Oblique;}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue191;\red96\green96\blue96;
\red0\green115\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 Multichannel Expansion\

\f1\b0\fs24 \
Multiple channels of audio are represented as Arrays.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 s.boot;\cf2 \
// one channel\
\cf0 \{ \cf3 Blip\cf0 .ar(800,4,0.1) \}.play;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // two channels\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \{ [ \cf3 Blip\cf0 .ar(800,4,0.1), \cf3 WhiteNoise\cf0 .ar(0.1) ] \}.play;
\fs24 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 Each channel of output will go out a different speaker, so your limit here is two for a stereo output. If you have a supported multi channel audio interface or card then you can output as many channels as the card supports.\
\
All UGens have only a single output. This uniformity facilitates the use of array operations to perform manipulation of multi channel structures.\
\
In order to implement multichannel output, UGens create a separate UGen known as an 
\f0\b OutputProxy
\f1\b0  for each output. An OutputProxy is just a place holder for the output of a multichannel UGen. OutputProxies are created internally, you never need to create them yourself, but it is good to be aware that they exist so you'll know what they are when you run across them.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf2 // look at the outputs of Pan2:
\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf3 Pan2\cf0 .ar(\cf3 PinkNoise\cf0 .ar(0.1), \cf3 FSinOsc\cf0 .kr(3)).dump;\
\
play(\{ \cf3 Pan2\cf0 .ar(\cf3 PinkNoise\cf0 .ar(0.1), \cf3 FSinOsc\cf0 .kr(1)); \});
\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 \
When an 
\f0\b Array
\f1\b0  is given as an input to a unit generator it causes an array of multiple copies of that unit generator to be made, each with a different value from the input array. This is called multichannel expansion. All but a few special unit generators perform multichannel expansion. Only Arrays are expanded, no other type of Collection, not even subclasses of Array.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs18 \cf0 \{ \cf3 Blip\cf0 .ar(500,8,0.1) \}.play \cf2 // one channel\
\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // the array in the freq input causes an Array of 2 Blips to be created :\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \{ \cf3 Blip\cf0 .ar([499,600],8,0.1) \}.play \cf2 // two channels\
\cf0 \
\cf3 Blip\cf0 .ar(500,8,0.1).postln \cf2 // one unit generator created.\
\cf0 \
\cf3 Blip\cf0 .ar([500,601],8,0.1).postln \cf2 // two unit generators created.
\fs24 \cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 Multichannel expansion will propagate through the expression graph. When a unit generator constructor is called with an array of inputs, it returns an array of instances. If that array is the input to another constructor, then another array is created, and so on.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \{ \cf3 RLPF\cf0 .ar(\cf3 Saw\cf0 .ar([100,250],0.05), \cf3 XLine\cf0 .kr(8000,400,5), 0.05) \}.play;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // the [100,250] array of frequency inputs to Saw causes Saw.ar to return \
// an array of two Saws, that array causes RLPF.ar to create two RLPFs.\
// Both RLPFs share a single instance of XLine.
\fs24 \cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 When a constructor is parameterized by two or more arrays, then the number of channels created is equal to the longest array, with parameters being pulled from each array in parallel. The shorter arrays will wrap.\
\
for example, the following:\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs18 \cf3 Pulse\cf0 .ar([400, 500, 600],[0.5, 0.1], 0.2)
\fs24 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 is equivalent to:\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs18 \cf0 [ \cf3 Pulse\cf0 .ar(400,0.5,0.2), \cf3 Pulse\cf0 .ar(500,0.1,0.2), \cf3 Pulse\cf0 .ar(600,0.5,0.2) ]
\fs24 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 A more complex example based on the Saw example above is given below. In this example, the XLine is expanded to two instances, one going from 8000 Hz to 400 Hz and the other going in the opposite direction from 500 Hz to 7000 Hz. These two XLines are 'married' to the two Saw oscillators and used to parameterize two copies of RLPF. So on the left channel a 100 Hz Saw is filtered from 8000 Hz to 400 Hz and on the right channel a 250 Hz Saw is filtered from 500 Hz to 7000 Hz.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs18 \cf0 \{ \cf3 RLPF\cf0 .ar(\cf3 Saw\cf0 .ar([100,250],0.05), \cf3 XLine\cf0 .kr([8000,500],[400,7000],5), 0.05) \}.play;
\fs24 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 Protecting arrays against expansion\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 Some unit generators such as 
\f0\b Klank
\f1\b0  require arrays of values as inputs. Since all arrays are expanded, you need to protect some arrays by a 
\f0\b Ref
\f1\b0  object. A Ref instance is an object with a single slot named 'value' that serves as a holder of an object. Ref.new(object) one way to create a Ref, but there is a syntactic shortcut. The backquote ` is a unary operator that is equivalent to calling Ref.new(something). So to protect arrays that are inputs to a Klank or similar UGens you write:\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf3 Klank\cf0 .ar(`[[400,500,600],[1,2,1]], z)
\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 \
You can still create multiple Klanks by giving it an array of Ref'ed arrays.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf3 Klank\cf0 .ar([ `[[400,500,600],[1,2,1]],  `[[700,800,900],[1,2,1]] ], z)
\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 \
is equivalent to:\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs18 \cf0 [ 
\f2 \cf3 Klank\cf0 .ar(`[[400,500,600],[1,2,1]], z),  \cf3 Klank\cf0 .ar(`[[700,800,900],[1,2,1]], z)]
\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 Reducing channel expansion with Mix\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 The 
\f0\b Mix
\f1\b0  object provides the means for reducing multichannel arrays to a single channel.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf3 Mix\cf0 .new([a, b, c]) \cf2 // array of channels
\fs24 \cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 is equivalent to:\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs18 \cf0 a + b + c  \cf2 // mixed to one
\fs24 \cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 Mix is more efficient than using + since it can perform multiple additions at a time. But the main advantage is that it can deal with situations where the number of channels is arbitrary or determined at runtime.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf2 // three channels of Pulse are mixed to one channel\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \{ \cf3 Mix\cf0 .new(  \cf3 Pulse\cf0 .ar([400, 501, 600], [0.5, 0.1], 0.1) ) \}.play
\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 \
Multi channel expansion works differently for Mix. Mix takes one input which is an array (one not protected by a Ref). That array does not cause copies of Mix to be made. All elements of the array are mixed together in a single Mix object. On the other hand if the array contains one or more arrays then multi channel expansion is \
performed one level down. This allows you to mix an array of stereo (two element) arrays resulting in one two channel array. For example:\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf3 Mix\cf0 .new( [ [a, b], [c, d], [e, f] ] ) \cf2 // input is an array of stereo pairs
\fs24 \cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 \
is equivalent to:\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf2 // mixed to a single stereo pair
\f1 \cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 [ \cf3 Mix\cf0 .new( [a, c, e] ), \cf3 Mix\cf0 .new( [b, d, f] ) ] 
\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 \
Currently it is not recursive. You cannot use Mix on arrays of arrays of arrays.\
\
Here's a final example illustrating multi channel expansion and Mix. By changing the variable 'n' you can change the number of voices in the patch. How many voices can your machine handle?\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 (\
\{\
	\cf3 var\cf0  n;\
	n = 8; \cf2 // number of 'voices'\
\cf0 	\cf3 Mix\cf0 .new( \cf2 // mix all stereo pairs down.\
\cf0 		\cf3 Pan2\cf0 .ar( \cf2 // pan the voice to a stereo position\
\cf0 			\cf3 CombL\cf0 .ar( \cf2 // a comb filter used as a string resonator\
\cf0 				\cf3 Dust\cf0 .ar( \cf2 // random impulses as an excitation function\
\cf0 					\cf2 // an array to cause expansion of Dust to n channels\
\cf0 					\cf2 // 1 means one impulse per second on average\
\cf0 					\cf3 Array\cf0 .fill(n, 1), \
					0.3 \cf2 // amplitude\
\cf0 				), \
				0.01, \cf2 // max delay time in seconds\
\cf0 				\cf2 // array of different random lengths for each 'string'\
\cf0 				\cf3 Array\cf0 .fill(n, \{0.004.rand+0.0003\}), \
				4 \cf2 // decay time in seconds\
\cf0 			),\
			\cf3 Array\cf0 .fill(n,\{1.0.rand2\}) \cf2 // give each voice a different pan position\
\cf0 		)\
	)\
\}.play;\
)
\fs24 \

\fs18 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 Using flop for multichannel expansion
\f1\b0 \
The method 
\f3\i flop
\f1\i0  swaps columns and rows, allowing to derive series of argument sets:
\f2\fs18 \
\
(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 SynthDef\cf0 (\cf4 "help_multichannel"\cf0 , \{ \cf3 |out=0, freq=440, mod=0.1, modrange=20|\cf0 \
	\cf3 Out\cf0 .ar(out,\
		\cf3 SinOsc\cf0 .ar(\
			\cf3 LFPar\cf0 .kr(mod, 0, modrange) + freq\
		) * \cf3 EnvGate\cf0 (0.1)\
	)\
\}).send(s);\
)\
\
(\
\cf3 var\cf0  freq, mod, modrange;\
\
freq = \cf3 Array\cf0 .exprand(8, 400, 5000);\
mod = \cf3 Array\cf0 .exprand(8, 0.1, 2);\
modrange = \cf3 Array\cf0 .rand(8, 0.1, 40);\
\
fork \{\
	[\cf5 \\freq\cf0 , freq, \cf5 \\mod\cf0 , mod, \cf5 \\modrange\cf0 , modrange].flop.do \{ \cf3 |args|\cf0 \
		args.postln;\
		\cf3 Synth\cf0 (\cf4 "help_multichannel"\cf0 , args);\
		0.3.wait;\
	\}\
\};\
)\
\
	\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 Similarly, 
\f0\b Function-flop
\f1\b0  returns an unevaluated function that will expand to its arguments when evaluated:
\f2\fs18 \
\
(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 SynthDef\cf0 (\cf4 "blip"\cf0 , \{ \cf3 |freq|\cf0  \cf3 Out\cf0 .ar(0, \cf3 Line\cf0 .ar(0.1, 0, 0.05, 1, 0, 2) \
	* \cf3 Pulse\cf0 .ar(freq * [1, 1.02])) \}).send(s);\
\
a = \{ \cf3 |dur=1, x=1, n=10, freq=400|\cf0 \
	fork \{ n.do \{\
			if(x.coin) \{ \cf3 Synth\cf0 (\cf4 "blip"\cf0 , [\cf5 \\freq\cf0 , freq]) \};\
			(dur / n).wait;\
	\} \}\
\}.flop;\
)\
\
a.value(5, [0.3, 0.3, 0.2], [12, 32, 64], [1000, 710, 700]);\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs24 \cf0 \
\
\
}