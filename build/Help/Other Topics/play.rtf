{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fnil\fcharset77 Monaco;\f2\fswiss\fcharset77 Helvetica;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red96\green96\blue96;\red0\green115\blue0;
\red191\green0\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 play
\f1\b0\fs18 \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 start a process
\f2\b0 \
\
\
this message is of common use in sc. Different objects respond to it in various\
ways, but the simple meaning is: start a process.\
It is usually implemented by objects in contributed libraries as well.\
\
play usually returns the playing object which might not be the same as the one\
the message was sent to.\
\
opposite: 
\f0\b stop
\f2\b0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 clock.play(stream)
\f2\b0 \
returns: the clock
\f1\fs18 \
	\
	(\
	r = \cf2 Routine\cf0 .new(\{ \cf3 "...playing"\cf0 .postln; 1.wait; \cf3 "ok, that was it"\cf0 .postln \});\
	\cf2 SystemClock\cf0 .play(r);\
	)\
\

\f0\b\fs24 routine.play(clock)
\f2\b0 \
returns: the routine\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 \
	\cf2 Routine\cf0 .new(\{ \cf3 "...playing"\cf0 .postln; 1.wait; \cf3 "ok, that was it"\cf0 .postln \}).play;\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 stream.play(clock)\

\f2\b0 returns the stream
\f1\fs18 \
	
\f2\fs24 the stream will loop until it returns nil\
	
\f1\fs18 \
	\cf2 FuncStream\cf0 (\{ \cf3 "ok, that was it"\cf0 .postln; 1 \}).play;\
	\
	\

\f0\b\fs24 pausestream.play(clock) / task.play(clock)
\f1\b0\fs18 \

\f2\fs24 returns the stream\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 \
	a = \cf2 PauseStream\cf0 .new(\cf2 FuncStream\cf0 .new(\{ \cf3 "ok, that was it"\cf0 .postln; 1 \}));\
	a.play;\
	a.stop;\
	a.play;\
	a.stop;\
	\
	a = \cf2 Task\cf0 .new(\{ loop(\{ \cf3 "ok, that was it"\cf0 .postln; 1.wait; \}) \});\
	a.play;\
	a.stop;\
	\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 pattern.play(clock, protoEvent)
\f2\b0 \
returns: an 
\f0\b EventStreamPlayer
\f2\b0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 \
	(\
	\cf2 Pseq\cf0 ([\
		\cf2 Pbind\cf0 (\cf4 \\freq\cf0 , \cf2 Pn\cf0 (500, 1)),\
		\cf2 Pbind\cf0 (\cf4 \\dur\cf0 , \cf2 Pn\cf0 (0.1, 1))\
	], 2).play;\
	)\
\
\
\
______________________________________________________\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 The following play messages both cause a 
\f0\b SynthDef
\f2\b0  to be written, send it to the server \
and start a synth with it there.\
\
they should not be used in quickly running automated processes,\
as there are more efficient alternatives (see 
\f0\b SynthDefsVsSynths)\

\f2\b0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 synthDef.play(target, args, addAction)
\f2\b0 \
returns: a 
\f0\b Synth
\f2\b0 \
	\
	note that you need an 
\f0\b out ugen
\f2\b0  to hear the result.\
	in sc3 synths can write to busses using an out ugen or they can also just run without any writing activity.\
	one example of a synth without an out ugen is 
\f0\b SendTrig
\f2\b0 , whereas you find different examples\
	of how to write to the busses in the helpfiles: 
\f0\b Out / ReplaceOut / XOut / OffsetOut\

\f2\b0 	as what is audible through the hardware busses must be written on them, one way or another\
	an out ugen is always needed.\
	some operations provide an out ugen 
\f0\b internally
\f2\b0 : see for example function.play, which plays out\
	to a bus number provided in the argument passed to .play\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 \
\
(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 x = SynthDef\cf0 (\cf3 "test"\cf0 , \{ arg out, amp=0.1;\
	\cf2 var\cf0  sound;\
	sound = \cf2 PinkNoise\cf0 .ar(amp * [1,1]);\
	\cf2 Out\cf0 .ar(out, sound);\
\}).play;\
)\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf5 //set the synth\cf0 \
x.set(\cf4 \\amp\cf0 , 0.2);\
\cf5 //free the synth\cf0 \
x.free;\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 note
\f2\b0 : Synth.play(function), is synonymous. for backwards compatibility with sc2
\f1\fs18 \
\
\

\f0\b\fs24 function.play(target, outbus, fadeTime)\

\f2\b0 returns: a 
\f0\b Synth
\f2\b0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 	
\f2\fs24 adds to tail by default\
	soft fade in and out.
\f1\fs18 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf5 //note that you can use Out ugens but you do not need to\cf0 \
\{ \cf2 PinkNoise\cf0 .ar(0.1*[1,1]) \}.play;\
\
\cf5 //mouse x controls level\cf0 \
\{ \cf2 XOut\cf0 .ar(0, \cf2 MouseX\cf0 .kr(0,1), \cf2 PinkNoise\cf0 .ar(0.1*[1,1])) \}.play;\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 the arguments of the function 
\f0\b are the same as in SynthDef.new
\f2\b0 , which means you cannot pass\
in any value - they are used to build Controls for the synth.\
\
you can set the controls in the running synth:\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 \
x = \{ \cf2 arg\cf0  freq=900; \cf2 Resonz\cf0 .ar(\cf2 PinkNoise\cf0 .ar([1,1]), freq, 0.01) \}.play(s, 0);\
x.set(\cf4 \\freq\cf0 , 1400);\
x.free;
\f2\fs24 \
\
which this is equivalent to:\

\f1\fs18 (\
x = \cf2 SynthDef\cf0 (\cf3 "nextrandomname"\cf0 , \{ \cf2 arg\cf0  freq=900; \
	\cf2 Out\cf0 .ar(0, \cf2 Resonz\cf0 .ar(\cf2 PinkNoise\cf0 .ar([1,1]), freq, 0.01))\
\}).play(s);\
)\
x.set(\cf4 \\freq\cf0 , 1400);\
x.free;
\f2\fs24 \
\
\
more modularity can be achieved by using 
\f0\b [Instr] 
\f2\b0 from the 
\f0\b CRUCIAL-LIBRARY
\f2\b0 .\
\
\
\
\

\f1\fs18 \
\
\
\
\
	}