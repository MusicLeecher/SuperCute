{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red191\green0\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf2 AbstractConstraint
\f1\b0\fs24 \cf0 \
\
subclasses:\
\cf2 Constraint\cf0 , \cf2 SeenBefore\cf0 ,  \cf2 IsIn\cf0 , \cf2 IsNotIn\cf0 , \cf2 Every\cf0 ,  \cf2 Not\cf0 , \cf2 Any\cf0 , \cf2 Xor\cf0 , \cf2 CountLimit\cf0 , \cf2 IsEven\cf0 , \cf2 IsOdd\cf0 , \cf2 IsNil\cf0 , \cf2 NotNil\cf0 \
\
\cf2 Constraints\cf0  let you specify conditions in an \cf2 OOP\cf0  fashion.\
\cf2 You\cf0  can perform logical operations on the constraint object itself to further \
filter or refine your query.\
\
\

\f2\fs20 (\
\cf3 // Create a constraint.\cf0 \
c = \
\cf2 	Constraint\cf0 (\{ \cf2 arg\cf0  obj; obj.even  \})\
		and: \cf2 Constraint\cf0 (\{ \cf2 arg\cf0  obj; obj % 4 == 0 \})\
		and: (\cf2 Constraint\cf0 (\{ \cf2 arg\cf0  obj; obj == 8 \}).not);\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 )\
	\
c is now a constraint object that can be used to validate that an input\
is even, divisible by 4 and is not the number 8.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 c.value(3)\
\
c.value(8)\
\
c.value(4)\
\
c.value(12)\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 This\cf0  can be used any place a function that returns \cf2 true\cf0 /\cf2 false\cf0  is required.\
eg. select, reject, every, any\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 (\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 // run numbers through it\cf0 \
50.do(\{\
	n = 40.rand;\
	[n,c.value(n)].postln\
\});\
)\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 It can be used in place of a function for \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 SequenceableCollections\cf0 , \cf2 Streams\cf0  and \cf2 Patterns\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 (\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 // filter a collection\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 Array\cf0 .fill(100,\{ 100.rand \})\
	.select(c) \cf3 // acts like a function\cf0 \
	.do(\{ \cf2 arg\cf0  num; num.postln; \});\
)\
\
\
(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 // Use to filter a Pattern\cf0 \
p = \cf2 Pseries\cf0 (0,1,100)\
	.select(c);\
)\
\
\cf3 // Unfiltered\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 Pseries\cf0 (0,1,100).asStream.all.do(\{\cf2 arg\cf0  num; num.postln;\})\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 // Filtered\cf0 \
p.asStream.all.do(\{ \cf2 arg\cf0  num; num.postln \});\
\
\
(\
\cf3 // and here is everybody that gets rejected by the constraint\cf0 \
p = \cf2 Pseries\cf0 (0,1,100)\
	.reject(c);\
)\
	\
p.asStream.all.do(\{ \cf2 arg\cf0  num; num.postln \});\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs20 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 The below example is expressed using only \cf2 Constraint\cf0 .\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs20 \cf0 (\
c = \
	\cf2 Constraint\cf0 (\{ \cf2 arg\cf0  obj; obj.even  \})\
		and: \cf2 Constraint\cf0 (\{ \cf2 arg\cf0  obj; obj % 4 == 0 \})\
		and: (\cf2 Constraint\cf0 (\{ \cf2 arg\cf0  obj; obj == 8 \}).not);
\fs18 \
)\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 It could also be expressed this way\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \
(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs20 \cf0 c = \
	\cf2 IsEven\cf0 .new and:  \cf2 Constraint\cf0 (\{ \cf2 arg\cf0  obj; obj % 4 == 0 \})\
		and: \cf2 Constraint\cf0 (\{ \cf2 arg\cf0  obj; obj != 8 \});
\fs18 \
)\
\
\

\f1\fs24 \cf2 Constraints\cf0  respond to\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 	.not\
	.or(aConstraint)\
	.and(aConstraint)\
	.xor(aConstraint)\
	.reject(aConstraint)\
	.select(aConstraint)\
	
\f1\fs24 \
by returning a new compound constraint that expresses that logic.\
\

\f2\fs18 (\
	c = \cf2 IsEven\cf0 .new;\
	d = \cf2 Constraint\cf0 (\{ \cf2 arg\cf0  num; num == 3 \});\
	\
	e = c or: d; \cf3 // if its even or it is the number 3\cf0 \
)\
(\
	c = \cf2 IsEven\cf0 .new;\
	d = \cf2 Constraint\cf0 (\{ \cf2 arg\cf0  num; num == 4 \});\
	\
	e = c.reject(d); \cf3 // if its even and also reject it if it is the number 4\cf0 \
)
\f1\fs24 \
\
\
	\
	
\f2\fs18 \
}