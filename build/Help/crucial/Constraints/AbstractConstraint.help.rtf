{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red0\green0\blue0;\red191\green0\blue0;
\red0\green0\blue191;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf2 AbstractConstraint
\f1\b0\fs24 \cf3 \
\
subclasses:\
\cf2 Constraint\cf3 , \cf2 SeenBefore\cf3 ,  \cf2 IsIn\cf3 , \cf2 IsNotIn\cf3 , \cf2 Every\cf3 ,  \cf2 Not\cf3 , \cf2 Any\cf3 , \cf2 Xor\cf3 , \cf2 CountLimit\cf3 , \cf2 IsEven\cf3 , \cf2 IsOdd\cf3 , \cf2 IsNil\cf3 , \cf2 NotNil\cf3 \
\
\cf2 Constraints\cf3  let you specify conditions in an \cf2 OOP\cf3  fashion.\
\cf2 You\cf3  can perform logical operations on the constraint object itself to further \
filter or refine your query.\
\
\

\f2\fs20 (\
\cf4 // Create a constraint.\cf3 \
c = \
\cf2 	Constraint\cf3 (\{ \cf2 arg\cf3  obj; obj.even  \})\
		and: \cf2 Constraint\cf3 (\{ \cf2 arg\cf3  obj; obj % 4 == 0 \})\
		and: (\cf2 Constraint\cf3 (\{ \cf2 arg\cf3  obj; obj == 8 \}).not);\

\f1\fs24 )\
	\
c is now a constraint object that can be used to validate that an input\
is even, divisible by 4 and is not the number 8.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf3 c.value(3)\
\
c.value(8)\
\
c.value(4)\
\
c.value(12)\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf3 \
\cf2 This\cf3  can be used any place a function that returns \cf2 true\cf3 /\cf2 false\cf3  is required.\
eg. select, reject, every, any\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf3 (\
\cf4 // run numbers through it\cf3 \
50.do(\{\
	n = 40.rand;\
	[n,c.value(n)].postln\
\});\
)\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 It\cf3  can be used in place of a function for \
\cf2 SequenceableCollections\cf3 , \cf2 Streams\cf3  and \cf2 Patterns\cf3 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf3 \
(\
\cf4 // filter a collection\cf3 \
\cf2 Array\cf3 .fill(100,\{ 100.rand \})\
	.select(c) \cf4 // acts like a function\cf3 \
	.do(\{ \cf2 arg\cf3  num; num.postln; \});\
)\
\
\
(\
\cf4 // Use to filter a Pattern\cf3 \
p = \cf2 Pseries\cf3 (0,1,100)\
	.select(c);\
)\
\
\cf4 // Unfiltered\cf3 \
\cf2 Pseries\cf3 (0,1,100).asStream.all.do(\{\cf2 arg\cf3  num; num.postln;\})\
\
\cf4 // Filtered\cf3 \
p.asStream.all.do(\{ \cf2 arg\cf3  num; num.postln \});\
\
\
(\
\cf4 // and here is everybody that gets rejected by the constraint\cf3 \
p = \cf2 Pseries\cf3 (0,1,100)\
	.reject(c);\
)\
	\
p.asStream.all.do(\{ \cf2 arg\cf3  num; num.postln \});\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs20 \cf3 \

\f1\fs24 \cf0 The below example is expressed using only \cf5 Constraint\cf0 .\
\

\f2\fs20 \cf3 (\
c = \
	\cf2 Constraint\cf3 (\{ \cf2 arg\cf3  obj; obj.even  \})\
		and: \cf2 Constraint\cf3 (\{ \cf2 arg\cf3  obj; obj % 4 == 0 \})\
		and: (\cf2 Constraint\cf3 (\{ \cf2 arg\cf3  obj; obj == 8 \}).not);
\fs18 \
)\
\

\f1\fs24 \cf0 It could also be expressed this way\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf3 \
(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs20 \cf3 c = \
	\cf2 IsEven\cf3 .new and:  \cf2 Constraint\cf3 (\{ \cf2 arg\cf3  obj; obj % 4 == 0 \})\
		and: \cf2 Constraint\cf3 (\{ \cf2 arg\cf3  obj; obj != 8 \});
\fs18 \
)\
\
\

\f1\fs24 \cf2 Constraints\cf3  respond to\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf3 	.not\
	.or(aConstraint)\
	.and(aConstraint)\
	.xor(aConstraint)\
	.reject(aConstraint)\
	.select(aConstraint)\
	
\f1\fs24 \
by returning a new compound constraint that expresses that logic.\
\

\f2\fs18 (\
	c = \cf2 IsEven\cf3 .new;\
	d = \cf2 Constraint\cf3 (\{ \cf2 arg\cf3  num; num == 3 \});\
	\
	e = c or: d; \cf4 // if its even or it is the number 3\cf3 \
)\
(\
	c = \cf2 IsEven\cf3 .new;\
	d = \cf2 Constraint\cf3 (\{ \cf2 arg\cf3  num; num == 4 \});\
	\
	e = c.reject(d); \cf4 // if its even and also reject it if it is the number 4\cf3 \
)
\f1\fs24 \
\
\
	\
	
\f2\fs18 \
}