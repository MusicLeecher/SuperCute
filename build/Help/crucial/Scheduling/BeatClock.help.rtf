{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red96\green96\blue96;\red191\green0\blue0;
\red0\green115\blue0;\red0\green0\blue0;\red0\green0\blue191;\red191\green0\blue0;\red96\green96\blue96;
}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 BeatClock
\f1\b0\fs24 \
\

\f0\b\fs28 superclass: Clock\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 \
A simple solution to playing Routines, where the value yielded is treated as the number of beats to wait.  BeatClock always uses the SystemClock for scheduling, and is subject to the same limitations with regard to Cocoa primitives.\
\
see [SystemClock] and [AppClock]\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 BeatClock.new(tempo)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 	if no Tempo object is supplied, it will use the default global Tempo object.\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 sched(beats,item)\
schedAbs(atBeat,item)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf2 Tempo\cf0 .bpm = 60;\
b = \cf2 BeatClock\cf0 .new;\
b.sched(4.0,\{ \cf3 "4 beats have passed"\cf0 .postln; \} );\
\
\cf2 \
Tempo\cf0 .bpm = 60;\
b.sched(4.0,\{\
	\cf3 "4 beats have passed, speeding up now..."\cf0 .postln;\
	\cf2 Tempo\cf0 .bpm = 600;\
	b.sched(4.0, \{\
		\cf3 "4 beats have passed"\cf0 .postln;\
	\});	\
\});\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 \
*sched(beats,item)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 	schedule using the global BeatClock (which uses the global Tempo)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 *schedAbs(atBeat,item)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 	schedule using the global BeatClock\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 *play(routine)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 	as for AppClock and SystemClock, but the float values you yield are beats.\
	the time in seconds is passed into the routine, not the beats. if you need beats,\
	simply use Tempo to convert it.\
	\
	(
\f2\fs18 \
	s = \cf2 Server\cf0 .local;\
	s.boot;\
\
	\cf2 Tempo\cf0 .bpm = 140;\
	d = \cf2 SynthDef\cf0 (\cf3 "help-BeatClock"\cf0 , \{ \cf2 arg\cf0  out=0,gate=0.0,freq=300;\
			\cf2 var\cf0  amp;\
			amp = \cf2 Decay2\cf0 .kr(gate,0.01,0.1).clip2(1.0);\
			\cf2 Out\cf0 .ar(out,\
				amp * \cf2 SinOsc\cf0 .ar(freq)\
			)\
		\});\
\
\
	\cf4 // might be too low if you are using laptop speakers\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 	l = 30; \cf4 // lo midi note\
\cf0 	h = 45; \cf4 // hi midi note\
\cf0 	\
	y = d.play;\
	\cf2 BeatClock\cf0 .play(\
		\cf2 Routine\cf0 (\{\
			60.do(\{ \cf2 arg\cf0  i;\
			 	\cf4 // note on\
\cf0 				y.set(\cf5 \\gate\cf0 ,rrand(0.1,0.6),\cf5 \\freq\cf0 ,rrand(l,h).midicps);\
				[0.125,0.25].choose.yield; \cf4 // wait by beats\
\cf0 				y.set(\cf5 \\gate\cf0 ,0.0); \cf4 // note off\
\cf0 				[0.125, 0.25,0.5,0.75,1.0].choose.yield; \cf4 // rest\
\cf0 			\});\
			y.free;\
		\})\
	);\
\
	\cf4 // tempo changes while playing will not maintain perfect sync\
\cf0 	\cf4 // but you might not care\
\cf0 	\cf2 Tempo\cf0 .bpm = 500; \
	\
	\cf2 Tempo\cf0 .bpm = 50; \
\
	\cf2 Tempo\cf0 .bpm = 140;\
	
\f1\fs24 )\
\
	\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf6 	(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf6 	
\f2\fs18 \cf6 	p = \cf7 Prand\cf6 ([0.25,0.5,1.0],100).asStream;\
		\cf7 BeatClock\cf6 .play(\
			\cf7 Routine\cf6 (\{\
				\cf7 var\cf6  dbeat,b,s;\
				\cf8 // wait till the next even beat to start playing\
\cf6 				dbeat = \cf7 OSCSched\cf6 .global.deltaTillNext(4.0);\
				dbeat.postln.wait;\
	\
				while(\{\
					(b = p.next).notNil\
				\},\{\
					\cf9 "boing"\cf6 .postln;\
					b.wait\
				\})\
			\})\
		);\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf6 	
\f1\fs24 \cf6 )\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
OSCSched has more sophisticated functionality, but is currently intended only for scheduling osc messages.\
}