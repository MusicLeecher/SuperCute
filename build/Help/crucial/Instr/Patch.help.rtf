{\rtf1\mac\ansicpg10000\cocoartf824\cocoasubrtf410
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fnil\fcharset77 Monaco;\f2\fnil\fcharset77 LucidaGrande;
\f3\fswiss\fcharset77 Helvetica;\f4\fnil\fcharset77 LucidaGrande-Bold;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red0\green115\blue0;\red191\green0\blue0;
\red96\green96\blue96;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 Patch
\f1\b0\fs18 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 A Patch connects an Instr function with input arguments to that function.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 \
	\cf2 Patch\cf0 (instr,args)\
\
(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 Instr\cf0 (\cf3 \\bubbles\cf0 , \{ \cf2 arg\cf0  amp=1.0;\
	\cf2 var\cf0  f, zout;\
	f = \cf2 LFSaw\cf0 .kr(0.4, 0, 24, \cf2 LFSaw\cf0 .kr([8,7.23], 0, 3, 80)).midicps;\
	zout = \cf2 CombN\cf0 .ar(\cf2 SinOsc\cf0 .ar(f, 0, 0.04), 0.2, 0.2, 4);\
	zout * amp\
\});\
\
p = \cf2 Patch\cf0 (\cf3 \\bubbles\cf0 );\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 // default server will be booted, def written and loaded\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 p.play;\
\
)\
\
\
\
p.stop;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 // command-. will also stop all sounds\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
p.play;\
\
p.run(\cf2 false\cf0 );\
\
p.run(\cf2 true\cf0 );\
\
p.insp; //inspect it\
\
p.gui;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 // close the window\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 // open it again\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 p.gui;\
\
\
\
	\
(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 Instr\cf0 (\cf3 \\bubbles\cf0 , \{ \cf2 arg\cf0  amp=1.0;\
	\cf2 var\cf0  f, zout;\
	f = \cf2 LFSaw\cf0 .kr(0.4, 0, 24, \cf2 LFSaw\cf0 .kr([8,7.23], 0, 3, 80)).midicps;\
	zout = \cf2 CombN\cf0 .ar(\cf2 SinOsc\cf0 .ar(f, 0, 0.04), 0.2, 0.2, 4);\
	zout * amp\
\});\
\
\cf2 Instr\cf0 (\cf3 \\rlpf\cf0 ,\{ \cf2 arg\cf0  audio=0,freq=500,rq=0.1;\
	\cf2 RLPF\cf0 .ar(audio, freq, rq)\
\});\
\
p = \cf2 Patch\cf0 (\cf3 \\rlpf\cf0 ,[\
	q = \cf2 Patch\cf0 (\cf3 \\bubbles\cf0 )\
]);\
\
p.gui\
\
)\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 \
Instr can be specified as \
\
an Instr	
\f1\fs18 \
(\
	i = \cf2 Instr\cf0 (\cf5 "help-Patch"\cf0 ,\{ \cf2 arg\cf0  freq=100,amp=1.0;\
			\cf2 SinOsc\cf0 .ar([freq,freq + 30],0,amp)\
		\});\
	p = \cf2 Patch\cf0 (i,[ 500,	0.3 ]);\
	p.gui\
)\

\f2\fs24 a Function\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 (\
	p = \cf2 Patch\cf0 (\{ \cf2 arg\cf0  freq=100,amp=1.0;\
		\cf2 SinOsc\cf0 .ar([freq,freq + 30],0,amp)\
	\},[\
		500,\
		0.3\
	]);\
	p.gui\cf2 \
)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs24 \cf0 or by the Instr name\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 // the Instr stores itself when created\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 (\
	\cf2 Instr\cf0 (\cf3 \\bubbles\cf0 , \{ \cf2 arg\cf0  amp=1.0;\
		\cf2 var\cf0  f, zout;\
		f = \cf2 LFSaw\cf0 .kr(0.4, 0, 24, \cf2 LFSaw\cf0 .kr([8,7.23], 0, 3, 80)).midicps;\
		zout = \cf2 CombN\cf0 .ar(\cf2 SinOsc\cf0 .ar(f, 0, 0.04), 0.2, 0.2, 4);\
		zout * amp\
	\});\
	\
	\cf4 // the patch retrieves it\
\cf0 	p = \cf2 Patch\cf0 (\cf3 \\bubbles\cf0 ,[0.4] );\
	p.gui\
)\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 \
Patch can be easily saved to disk, and can make use of a large library of Instr functions.  An Instr can produce many different possible SynthDefs, expanding the number of output channels or , varying in output rate or number of channels or internal structure.
\f3 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 Automatic Input Creation\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs24 \cf0 For any nil arguments, a default control will be created.  The spec returns this from the defaultControl method.\
\
ControlSpec :  KrNumberEditor\
StaticSpec    :  NumberEditor  (for quantities or max delay times etc.)\
EnvSpec       : EnvEditor\
SampleSpec : Sample\
\
see the implementations of defaultControl\
\
This gives the impression that Patch is "an automatic gui for an Instr / SynthDef".  If you do not supply arguments, it will make default ones, simple ones, 
\f4\b but the real power of Patch is to supply functions with complex and varied inputs
\f2\b0 .  Sitting there with 5 sliders on a 1 dimensional Instrument isn't really the height of synthesis.\
\
Most simple synth inputs (ControlSpec) will end up being KrNumberEditors.  Setting their values will control the playing synth.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 	aPatch.set( index, value)\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 \
\
I recommend experimenting with factory methods to create your patches, supplying them with inputs useful for what you are working on.\
If you use a certain physical controller or wacom :\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural
\cf0 buildPatch  = \{ \cf2 arg\cf0  instrName;\
	\cf2 var\cf0  i;\
	i = \cf2 Instr\cf0 .at(instrName);\
	\
	\cf2 Patch\cf0 (instrName,[\
	  \{ i.specAt(0).map( \cf2 JoyAxis\cf0 .kr(0,1,axis:5) ) \},\
	  \{ i.specAt(1).map( \cf2 JoyAxis\cf0 .kr(0,1,axis:5) ) \},\
	])\
\};\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
buildPatch.value( \cf3 \\boingboing\cf0  );\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 \
\pard\pardeftab720\ql\qnatural

\f3 \cf0 \
you can even keep your factories themselves in Instrument libraries:\
\

\f1\fs18 \cf2 Instr\cf0 (\cf3 \\joysticker\cf0 ,[ \cf2 arg\cf0  instrName;\
	\
	\cf2 var\cf0  i;\
	i = \cf2 Instr\cf0 .at(instrName);\
	\
	\cf2 Patch\cf0 (instrName,[\
	\'ca\'ca\{ i.specAt(0).map( \cf2 JoyAxis\cf0 .kr(0,1,axis:5) ) \},\
	\'ca\'ca\{ i.specAt(1).map( \cf2 JoyAxis\cf0 .kr(0,1,axis:5) ) \},\
	])\
\});\
\
\
patch = \cf2 Instr\cf0 (\cf3 \\joysticker\cf0 ).value( \cf3 \\simple\cf0  );
\f3\fs24 \
\
this Instr is not used for audio, its just used to build and return a Patch
\f2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
You could choose different controllers for different common inputs,\
you can query the argument name and the spec.\
Keep files in databases,  load other Patches or soundfiles from disk.\
You could flip coins and choose from soundfiles, audio in, other saved \
patches or randomly chosen net radio feeds.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 Patch inside Patch\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs18 \cf0 \
(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 // lets collect the cast...\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 Instr\cf0 (\cf3 \\bubbles\cf0 , \{ \cf2 arg\cf0  amp=1.0;\
	\cf2 var\cf0  f, zout;\
	f = \cf2 LFSaw\cf0 .kr(0.4, 0, 24, \cf2 LFSaw\cf0 .kr([8,7.23], 0, 3, 80)).midicps;\
	zout = \cf2 CombN\cf0 .ar(\cf2 SinOsc\cf0 .ar(f, 0, 0.04), 0.2, 0.2, 4);\
	zout * amp\
\});\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 // note that the same function will work as stereo or mono\
// depending on what gets put into it\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 Instr\cf0 (\cf3 \\rlpf\cf0 ,\{ \cf2 arg\cf0  audio=0,freq=500,rq=0.1;\
	\cf2 RLPF\cf0 .ar(audio, freq, rq)\
\});\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 // put bubbles into the filter\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 p = \cf2 Patch\cf0 (\cf3 \\rlpf\cf0 ,[\
	q = \cf2 Patch\cf0 (\cf3 \\bubbles\cf0 )\
]);\
\
)\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 // watch the ugen count in the default server window\
// and also the error window results\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
p.play;\
\
\
// randomize settings\
p.rand;\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 // stops the parent and the child q\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 p.stop;\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 // allocates new everything\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 p.play;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 // additional play\
// does not start an additional process\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 p.play;\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 // stop q, but the filter p is still reading from its old bus\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 q.stop;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 // should still have 9 ugens playing\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 // sent the play message, q defaults to play out of the main outputs\
// not through the filter p\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 q.play;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 // stopping p now still stops q because it is still a child of p\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 p.stop;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 // replaying the whole structures\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 p.play;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 // note the AudioPatchOut and the inputs: PatchIn classes\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 p.insp;\
q.insp;\
\
\
\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 Fixed Arguments\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\b0 \cf0 \
Floats and other scalar values including Envelopes, are transparently dealt with by Patch.  These items are passed to the Instr function, but not to the SynthDef or the Synth.  They are not modulateable.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf3 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 (\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 // fixing arguments\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 Instr\cf0 ([\cf3 \\jmcExamples\cf0 ,\cf3 'moto-rev'\cf0 ],\{ \cf2 arg\cf0  lfo=0.2,freq=1000,rq=0.1;\
	\cf2 RLPF\cf0 .ar(\cf2 LFPulse\cf0 .ar(\cf2 SinOsc\cf0 .kr(lfo, 0, 10, 21), [0,0.1], 0.1), freq, rq).clip2(0.4);\
\});\
\
q = \cf2 Patch\cf0 ([\cf3 \\jmcExamples\cf0 ,\cf3 'moto-rev'\cf0 ],[\
	0.2\
]);\
\
q.gui;\
\
)\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs24 \cf0 You can design Instr to take parameters that are used only in the building of the SynthDef. This can be used to select from different kinds of filters or to .\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 \
\pard\pardeftab720\ql\qnatural
\cf0 \
\cf2 Instr\cf0 (\cf3 \\upOrDown\cf0 , \{\cf2 arg\cf0  upDown=0;\
	\cf2 var\cf0  line;\
	if (upDown>0,\
		\{line = \cf2 Line\cf0 .kr(1,0,5)\}, \cf4 // upDown>0 ==> pitch goes up\cf0 \
		\{line = \cf2 Line\cf0 .kr(0,1,5)\}\'ca \cf4 // upDown 0 or less ==> pitch goes down\cf0 \
	);\
	\cf2 SinOsc\cf0 .ar(440*line,0,0.2);\
\},[\
	\cf2 StaticIntegerSpec\cf0 (0,1)\
]);\
\
\cf2 Patch\cf0 (\cf3 \\upOrDown\cf0 , [ 0]).play\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs24 \cf0 The upDown param acts as a switch between different synth def architectures.  If your Instr library is well designed you can acheive very sophisticated sound structures with automatic optimizations and code reuse.\
\
Note that the Patch would assume upDown to be a modulatable control input (with a default of 0.0) without the StaticIntegerSpec making it clear that its a static integer.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 \
\

\f0\b\fs36 Busses
\f1\b0\fs18 \
(\
\
s.boot;\
\
a = \cf2 Group\cf0 .new;\
\
b = \cf2 Group\cf0 .after(a);\
\
c = \cf2 Bus.audio(s,1);\
\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 p=Patch\cf0 (\{ \cf2 arg\cf0  in,ffreq;\
	// the Bus is passed in as In.ar(bus.index,bus.numChannels)\
	\cf2 LPF\cf0 .ar(in,ffreq)\
\},[\
	c,\
	\cf2 KrNumberEditor\cf0 (3000,[200,8000,\cf3 \\exp\cf0 ])\
]).play(group: b);\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 // play something onto this bus in a group before that of the filter\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 y = Patch\cf0 (\{	\cf2 Saw\cf0 .ar(400) * 0.1  \}).play(group: a, bus: c );\
\
\
\cf2 z = Patch\cf0 (\{	\cf2 Saw\cf0 .ar(500) * 0.1  \}).play(group: a, bus: c );\
z.stop;\
\
y.stop;\
\
)\
\
// you can make the bus play to a main audio output\
c.play\
\
//command-. to stop all\
\
\
(\
s.boot;\
\
a = \cf2 Group\cf0 .new;\
\
b = \cf2 Group\cf0 .after(a);\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 // no index, not yet allocated\cf0 \
c = \cf2 Bus\cf0 (\cf3 \\audio\cf0 ,\cf2 nil\cf0 ,2);\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 y = Patch\cf0 (\{ \cf2 arg\cf0  in,ffreq;\
	\cf2 LPF\cf0 .ar(in,ffreq)\
\},[\
	c, \cf4 // a proxy, the bus is yet to be allocated\cf0 \
	\cf2 KrNumberEditor\cf0 (3000,[200,8000,\cf3 \\exp\cf0 ])\
]).play(group: b);\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 // now that the patch has played, the bus allocated itself\cf0 \
c.insp\
\
\cf4 // play onto this bus in a group before that of the filter\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 z = Patch\cf0 (\{	\cf2 Saw\cf0 .ar([400,401]) * 0.1  \}).play(group: a, bus: c )\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 Mapping values
\f1\b0\fs18 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\f3\fs24 \cf0 you can use a spec to map a signal :
\f1\fs18 \
\
(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural
\cf2 var\cf0  spec;\
spec = [ 100,18000,\cf3 \\exp\cf0 ].asSpec;\
\{\
\
\cf2 SinOsc\cf0 .ar(\
  spec.map(  \cf2 SinOsc\cf0 .kr(0.1).range(0,1) )\
)\
\
\}.play\
\
)\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\f3\fs24 \cf0 you can use that as an input to a patch:
\f1\fs18 \
\
(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural
\cf2 var\cf0  spec;\
spec = [ 100,18000,\cf3 \\exp\cf0 ].asSpec;\
\
\cf2 Patch\cf0 (\{ \cf2 arg\cf0  freq;\
	\cf2 SinOsc\cf0 .ar(freq)\
\},[\
    spec.map( \{ \cf2 SinOsc\cf0 .kr(0.1).range(0,1) \} )\
]).play\
)\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\f3\fs24 \cf0 or map another player's output and then use that as an input to a patch :
\f1\fs18 \
\
(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural
\cf2 var\cf0  spec;\
spec = [ 100,18000,\cf3 \\exp\cf0 ].asSpec;\
\
\cf2 Patch\cf0 (\{ \cf2 arg\cf0  freq;\
	\cf2 SinOsc\cf0 .ar(freq)\
\},[\
    spec.map( \cf2 Patch\cf0 (\{ \cf2 SinOsc\cf0 .kr(0.1).range(0,1) \}) ).debug(\cf5 "i am a"\cf0 )\
]).play\
\
)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\f3\fs24 \cf0 \
so spec.map is taking the player (which is a kind of function :\
a potential piece of music once it is valued )\
and creating a BinaryOpFunction out of it.\
that is to say if you do math on functions you get another function.
\f1\fs18 \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 Spawning
\f1\b0\fs18 \
\
still wrong.  a should be playing already and b should just patch it in each time.\
(\cf4 //\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 //\cf0 \
\cf4 //a = Patch(\{\cf0 \
\cf4 //	SinOsc.ar(800,0.0)\cf0 \
\cf4 //\});\cf0 \
\cf4 //\cf0 \
\cf4 //c = Bus.audio;\cf0 \
\cf4 //a.play(bus: c);\cf0 \
\cf4 //\cf0 \
\cf4 //b = Patch(\{ arg tone;\cf0 \
\cf4 //	var gate;\cf0 \
\cf4 //	gate = Trig1.kr(1.0,0.25);\cf0 \
\cf4 //	tone = In.ar(tone,1);\cf0 \
\cf4 //	tone * EnvGen.kr(Env([0,1,0],[0.05,0.05],\\welch,1),gate,doneAction: 2)\cf0 \
\cf4 //\}[\cf0 \
\cf4 //	c.index\cf0 \
\cf4 //]);\cf0 \
\cf4 //\cf0 \
\cf4 //b.prepareForPlay(s);\cf0 \
\cf4 //\cf0 \
\cf4 //\cf0 \
\cf4 //Routine(\{\cf0 \
\cf4 //	1.0.wait;\cf0 \
\cf4 //	100.do(\{\cf0 \
\cf4 //		b.spawn(atTime: 0.1);\cf0 \
\cf4 //		0.25.wait\cf0 \
\cf4 //	\})\cf0 \
\cf4 //\}).play(SystemClock)\cf0 \
\cf4 //\cf0 \
)\
\
\
}