{\rtf1\mac\ansicpg10000\cocoartf824\cocoasubrtf410
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red0\green0\blue191;\red96\green96\blue96;
\red191\green0\blue0;\red0\green0\blue191;\red96\green96\blue96;\red191\green0\blue0;\red0\green115\blue0;
}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 Updater			
\fs24 \
\
superclass: Object\
\
Updater(model, updateFunction)\
\

\f1\b0 An Updater can be used to implement a simple Model-View-Controller architecture\
in situations where a full blown controller class is not needed.\
\
It adds itself as a dependant to the model.  When the model is issued a .changed message (after its state has been changed in some way) all of its dependants, including the Updater are sent the .update message.\
\
The Updater class then simply evalutes the updateFunction\
  \
see also: SimpleController
\f0\b \
\
\
Examples\
\

\f1\b0 The most common usage is to monitor a model for changes and to update a view.\

\f0\b \

\f1\b0 \cf2 (\
\cf3 Sheet\cf2 (\{ \cf3 arg\cf2  layout;\
\
		\cf3 var\cf2  bpmView, updater;\
		\
		bpmView= \cf3 CXLabel\cf2 (layout, \cf4 "tempo:_____"\cf2 );\
\
		updater = \cf3 Updater\cf2 (\cf3 Tempo\cf2 .default,\{ \cf5 // any change to Tempo\cf2 \
				bpmView.label_(\cf4 "tempo:"\cf2  + \cf3 Tempo\cf2 .bpm).refresh;\
			\});\
		\
		\cf5 // fire the function manually to initially set the bpmView label\cf2 \
		updater.update; \
		\
		\cf5 // tell the layout to .remove this updater when the layout and windows close\cf2 \
		layout.removeOnClose( updater );\
\});\
\
\cf5 // every time you set the Tempo it will issue itself a .changed message\cf2 \
\cf3 Tempo\cf2 .tempo = 0.4\
\
\cf3 Tempo\cf2 .tempo = 1.3\
\
\cf3 Tempo\cf2 .tempo = 1.0\
\
)		\
\cf0 \
The updater adds itself as a dependant to the model, so its important to at some point tell the updater to remove itself (as a dependant).  Otherwise it will stay in the model's dependant dictionary and will not get garbage collected.  It will also continue to respond to update messages.  If the window has closed this means it will try to change views that no longer exist and you will get errors.\

\f0\b \

\f1\b0  tell the layout to .remove this updater when the layout and windows close :\

\f0\b \
		layout.removeOnClose( updater );\
\
\
\
Update the client of messages from server\
\

\f1\b0 The commonly used NodeWatcher class watches server notifications and issues .changed messages to the Node objects.  Updater can be used to fire an updateFunction
\f0\b \
\
model -
\f1\b0  the node which you want to receive server notifications for.\

\f0\b updateFunction
\f1\b0  - 
\f2\fs18 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural
\cf0 \
(\
// prep\
s = \cf6 Server\cf0 .local;\
\
n = \cf6 SynthDef\cf0 (\cf7 "Updater-help"\cf0 , \{\cf6 |out, freq|\cf0 \
			\cf6 var\cf0  sin;\
			sin = \cf6 SinOsc\cf0 .ar(freq, 0.5)*\cf6 EnvGen\cf0 .kr(\cf6 Env\cf0 .triangle(4,1), doneAction:2);\
			\cf6 Out\cf0 .ar(out, sin);\
		\}).send(s);\
)\
\
(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural
\cf8 //create a new synth node on the server\cf0 \
n = \cf6 Synth\cf0 .new(\cf7 "Updater-help"\cf0 , [\cf9 \\out\cf0 , 0, \cf9 \\freq\cf0 , 220]);\
\
\cf8 //you need to register the synth with a NodeWatcher first\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural
\cf6 NodeWatcher\cf0 .register(n);\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural
\cf8 //update the client of \\n_end messages\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural
\cf6 Updater\cf0 (n, \{\cf6 |node, msg|\cf0 \
		if(msg==\cf9 \\n_end\cf0 , \{\
			\cf7 "synth has ended"\cf0 .postln;\
		\});\
	\});\
)\
\

\f1\fs24 \cf0 This could also be done using SimpleController, a related class that assumes that the second argument will be a symbol.
\f2\fs18 \cf0 \
\
(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural
\cf8 //create a new synth node on the server\cf0 \
n = \cf6 Synth\cf0 .new(\cf7 "Updater-help"\cf0 , [\cf9 \\out\cf0 , 0, \cf9 \\freq\cf0 , 220]);\
\
\cf8 //you need to register the synth with a NodeWatcher first\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural
\cf6 NodeWatcher\cf0 .register(n);\
\cf6 c = SimpleController\cf0 (n);\
\
// map \\n_end to an updateFunction\
c.put( \\n_end,\{ arg node;\
	\cf7 "synth has ended"\cf0 .postln;\
\});\
\
)\
\
\
\
}