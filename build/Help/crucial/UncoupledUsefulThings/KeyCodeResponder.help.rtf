{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red0\green0\blue0;\red0\green0\blue191;
\red191\green0\blue0;\red96\green96\blue96;\red96\green96\blue96;\red191\green0\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs52 \cf0 KeyCodeResponder
\f1\b0\fs20 \

\fs22 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs24 \cf0 \
Handles multiple registrations for keystroke and modifier combinations.  This object can be used as the keydown or keyup action for a view in place of a function.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 KeyCodes are hardware dependant, and change from machine to machine. 
\f1\b0  \
Its a simple way to hook up keys to respond, but it won't transfer to other people's computers.\
\
see [
\f0\b SCView]
\f1\b0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 Use this to post the keycodes\
(\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf2 KeyCodeResponder\cf0 .tester
\f1\fs24 \
\
)\

\f2\fs18 \
\
\
\
(\cf3 \
k = \cf4 KeyCodeResponder\cf3 .new;\
\
\cf5 // match single modifiers exclusively\cf3 \
k.normal( 36 -> \{  \cf6 "return"\cf3 .postln \});\
k.option( 36 -> \{ \cf6 "option return"\cf3 .postln \});\
k.shift( 36 -> \{ \cf6 "shift return"\cf3 .postln \});\
\cf5 // overwrites\cf3 \
k.shift( 36 -> \{ \cf6 "SHIFT RETURN only"\cf3 .postln; \});\
\
\cf5 // match multiple modifier combinations\cf3 \
	\cf5 //        shift caps opt   control\cf3 \
k.register( 36, \cf4 true\cf3 ,  \cf4 nil\cf3 ,  \cf4 true\cf3 , \cf4 false\cf3 , \{\
	\cf5 //         yes   either  yes   no\cf3 \
	\cf6 "return: shift-option regardless of CAPS"\cf3 .postln;\
\});\
\
\
k.registerKeycode(\cf4 KeyCodeResponder\cf3 .normalModifier, 52 , \{ \cf6 "enter"\cf3 .postln; \});\
\
\cf5 // arrow keys are considered function keys and must be bit ORd with function key modifier\cf3 \
k.registerKeycode(\cf4 KeyCodeResponder\cf3 .normalModifier | \cf4 KeyCodeResponder\cf3 .functionKeyModifier , 123 , \{ 	\cf6 "<-"\cf3 .postln; \
\});\
\
k.registerKeycode(\cf4 KeyCodeResponder\cf3 .controlModifier | \cf4 KeyCodeResponder\cf3 .functionKeyModifier , 123 , \{\
	\cf6 "control <-"\cf3 .postln; \
\});\
\
w = \cf4 SCWindow\cf3 .new.front;\
v = \cf4 SCSlider\cf3 .new(w,\cf4 Rect\cf3 (10,10,100,100));\
v.keyDownAction = k;\
v.focus;\
\
\cf0 )
\f1\fs24 \
\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 register(keycode, shift, caps, opt, cntl, function)\
	
\f1\b0 \
	for shift, caps,opt,cntl\
		
\f0\b true
\f1\b0  indicates a required modifier\
		
\f0\b false
\f1\b0  indicates an excluded modifier\
		
\f0\b nil
\f1\b0   expresses that you really don't care one way or the other
\f2\fs18 \
	\
\

\f0\b\fs24 normal(keycode -> function)\
normal(keycode -> fuction, keycode2 -> function2 , ... keycodeN -> functionN )\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs18 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 	note the association ( key  -> value )\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 shift(keycode -> function)\
shift(keycode -> fuction, keycode2 -> function2 , ... keycodeN -> functionN )\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs18 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 option(keycode -> function)\
option(keycode -> fuction, keycode2 -> function2 , ... keycodeN -> functionN )\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs18 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 control(keycode -> function)\
control(keycode -> fuction, keycode2 -> function2 , ... keycodeN -> functionN )\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs18 \cf0 \
\
\
\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 Any player's gui can have its keyDownAction set\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs18 \cf0 \
(\
\
p = Patch(\{ arg freq=440; SinOsc.ar(freq,mul: 0.1) \});\
g = p.gui;\
g.keyDownAction =  \{\
	"you touched me".postln;\
\};\
\
)\
focus on the slider.  notice that every key stroke is passed,\
the slider does not swallow them.\
\
\
or you can use KeyCodeResponder\
\
kcr = \cf2 KeyCodeResponder\cf0 .new;\
kcr.option( 36 -> \{ \cf7 "option 36"\cf0 .postln \});\
kcr.shift( 36 -> \{ \cf7 "shift 36"\cf0 .postln \});\
aPatchGui = aPatch.gui;\
aPatchGui.keyDownAction = kcr;\
\
This means that when ever the player is focused (any of its controls is in focus), these keys will be active providing that the view that is actually in focus doesn't handle the key event (it should have a nil keyDownAction function or pass nil).\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 You can concatenate KeyCodeResponders using ++
\f2\b0\fs18 \
\
\
\
\
global keydowns not yet tested....\
(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 KeyCodeResponder\cf0 .clear;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf8 /*\
this will fire on shift-'r'\
	shift must be held down\
	caps must NOT be down\
	cntl or opt status is irrelevant\
*/\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 KeyCodeResponder\cf0 .register(15,\cf2 true\cf0 ,\cf2 false\cf0 ,\cf2 nil\cf0 ,\cf2 nil\cf0 ,\{ \cf7 "shift, no caps"\cf0 .postcln \});\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf8 /*\
this will fire on shift-'r'\
	shift must be held down\
	caps may or may not be down\
	cntl or opt status is irrelevant\
*/\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 KeyCodeResponder\cf0 .register(15,\cf2 true\cf0 ,\cf2 nil\cf0 ,\cf2 nil\cf0 ,\cf2 nil\cf0 ,\{ \cf7 "shift, yes/no caps"\cf0 .postcln \});\
\cf2 Sheet\cf0 (\{ \cf2 arg\cf0  f; \cf2 ActionButton\cf0 (f).focus \});\
\
\
)\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
	\
This is very useful when using CAPS-LOCK to switch interface modes etc.\
\
Only one function per deny/require mask combination is possible per keycode:\
( // hit shift - r\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf2 KeyCodeResponder\cf0 .register(15,\cf2 true\cf0 ,\cf2 nil\cf0 ,\cf2 nil\cf0 ,\cf2 nil\cf0 ,\{ \cf7 "shift r"\cf0 .postcln \});\
\cf2 KeyCodeResponder\cf0 .register(15,\cf2 true\cf0 ,\cf2 nil\cf0 ,\cf2 nil\cf0 ,\cf2 nil\cf0 ,\{ \cf7 "overwrote the previous one"\cf0 .postcln \});\
\cf2 Sheet\cf0 (\{ \cf2 arg\cf0  f; \cf2 ActionButton\cf0 (f).focus \});\
\
)\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs26 \cf0 The simpler, older method is :\
\
	
\f2\b0\fs18 \cf2 KeyCodeResponder\cf0 .registerKeycode(2,28,\{      \});\cf8 // *\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 whereby that modifier and only that modifier will fire the funtion.\
see SCView for modifier values or use this :\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \
(\
\
	\cf2 KeyCodeResponder\cf0 .tester\
\
)\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf8 // using characters  \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 KeyCodeResponder\cf0 .registerChar(0,$q,\{  \}); \cf8 // q no modifier\
\cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 Gotcha
\f1\b0 : it is easy to forget that you registered a function with KeyCodeResponder\
that holds a reference to a large object.  Garbage Collection will not remove the object until\
you have released your reference.\
\
solution:\
	// place this at the top of your performance code to start with a clean \shad\shadx-40\shady-50\shadr123\shado85 \shadc3 slate\shad0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 	\cf2 KeyCodeResponder\cf0 .clear;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs22 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 		\
	}