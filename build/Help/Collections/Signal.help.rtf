{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 Signal						sampled audio buffer\
\

\fs24 Superclass: FloatArray\
\

\f1\b0 A Signal is a FloatArray that represents a sampled function of time buffer. \
Signals support math operations.
\
\
note:  the display methods on this page are not yet functioning.\
\

\f0\b\fs28 \ul Creation
\f1\b0\fs24 \ulnone \
\

\f0\b *sineFill(size, amplitudes, phases)\

\f1\b0 \
Fill a Signal of the given size with a sum of sines at the given amplitudes and phases.\
The Signal will be normalized.\

\f0\b size
\f1\b0  - the number of samples in the Signal.\

\f0\b amplitudes
\f1\b0  - an Array of amplitudes for each harmonic beginning with the fundamental.\

\f0\b phases
\f1\b0  - an Array of phases in radians for each harmonic beginning with the fundamental.\
\

\f2 Signal.sineFill(1000, 1.0/[1,2,3,4,5,6]).plot;\
\

\f1 \

\f0\b *chebyFill(size, amplitudes, phases)\

\f1\b0 \
Fill a Signal of the given size with a sum of Chebyshev polynomials at the given amplitudes\
for use in waveshaping by the Shaper ugen.\
The Signal will be normalized.\

\f0\b size
\f1\b0  - the number of samples in the Signal.\

\f0\b amplitudes
\f1\b0  - an Array of amplitudes for each Chebyshev polynomial beginning with order 1.\
\

\f2 Signal.chebyFill(1000, [1]).plot;\
\
Signal.chebyFill(1000, [0, 1]).plot;\
\
Signal.chebyFill(1000, [0, 0, 1]).plot;\
\
Signal.chebyFill(1000, [0.3, -0.8, 1.1]).plot;\
\
\

\f0\b *hanningWindow(size, pad)\

\f1\b0 \
Fill a Signal of the given size with a Hanning window.\

\f0\b size
\f1\b0  - the number of samples in the Signal.\

\f0\b pad
\f1\b0  - the number of samples of the size that is zero padding.\
\

\f2 Signal.hanningWindow(1024).plot;\
\
Signal.hanningWindow(1024, 512).plot;\
\

\f1 \

\f0\b *hammingWindow(size)\

\f1\b0 \
Fill a Signal of the given size with a Hamming window.\

\f0\b size
\f1\b0  - the number of samples in the Signal.\

\f0\b pad
\f1\b0  - the number of samples of the size that is zero padding.\
\

\f2 Signal.hammingWindow(1024).plot;\
\
Signal.hammingWindow(1024, 512).plot;\
\

\f1 \

\f0\b *welchWindow(size)\

\f1\b0 \
Fill a Signal of the given size with a Welch window.\

\f0\b size
\f1\b0  - the number of samples in the Signal.\

\f0\b pad
\f1\b0  - the number of samples of the size that is zero padding.\
\

\f2 Signal.welchWindow(1024).plot;\
\
Signal.welchWindow(1024, 512).plot;\

\f1 \

\f2 \

\f0\b *rectWindow(size)\

\f1\b0 \
Fill a Signal of the given size with a rectangular window.\

\f0\b size
\f1\b0  - the number of samples in the Signal.\

\f0\b pad
\f1\b0  - the number of samples of the size that is zero padding.\
\

\f2 Signal.rectWindow(1024).plot;\
\
Signal.rectWindow(1024, 512).plot;\

\f1 \

\f2 \

\f0\b\fs28 \ul Instance Methods\

\f1\b0\fs24 \ulnone \

\f0\b plot(name, bounds)\

\f1\b0 \
Plot the Signal in a window. The arguments are not required and if not given defaults will be used.\

\f0\b name
\f1\b0  - a String, the name of the window.\

\f0\b bounds
\f1\b0  - a Rect giving the bounds of the window.\
\

\f2 Signal.sineFill(512, [1]).plot;\
\
Signal.sineFill(512, [1]).plot("Signal 1", Rect.newBy(50, 50, 150, 450));\
\

\f1 \

\f0\b play(sampleRate, name, loop)\

\f1\b0 \
Plays the Signal in a Mixer channel.\

\f0\b sampleRate
\f1\b0  - the sample rate of the signal.\

\f0\b name
\f1\b0  - a Symbol or String giving the name of the mixer channel.\

\f0\b loop
\f1\b0  - A Boolean whether to loop the entire signal or play it once. Default is to loop.\
\

\f2 Signal.sineFill(512, [1]).play;\
\
Signal.sineFill(512, [1]).play(44100, "Signal 1");\
\
// Synth.collect returns a Signal\
//Synth.collect(\{ PinkNoise.ar(XLine.kr(0.001, 0.2, 2)) \}, 2).play;\
not yet implemented\

\f1 \

\f0\b waveFill(function, start, end)\

\f1\b0 \
Fill the Signal with a function evaluated over an interval.\

\f0\b function
\f1\b0  - a function that should calculate the value of a sample.\
The function is called with two arguments.\
	
\f0\b x
\f1\b0  - the value along the interval.\
	
\f0\b i
\f1\b0  - the sample index.\

\f0\b start
\f1\b0  - the starting value of the interval\

\f0\b end
\f1\b0  - the ending value of the interval.\
	\

\f2 (\
s = Signal.newClear(512);\
s.waveFill(\{ arg x, i; sin(x).max(0) \}, 0, 3pi);\
// s.plot;\
)\
\

\f0\b asWavetable\

\f1\b0 \
Convert the Signal into a Wavetable.\
\

\f2 Signal.sineFill(512, [1]).asWavetable;//.plot;\
\

\f1 \

\f0\b fill(val)\

\f1\b0 \
Fill the Signal with a value.\
\

\f2 Signal.newClear(512).fill(0.2);//.plot;\
\

\f1 \

\f0\b scale(scale)\

\f1\b0 \
Scale the Signal by a factor 
\f0\b in place
\f1\b0 .\
\
\cf2 //(\
//s = 
\f2 Synth.collect(\{ WhiteNoise.ar \}, 0.01);\
////SignalWindow.new(signals: [s, s.copy.scale(0.2)]);\
//)\
\cf0 \
\

\f0\b offset(offset)\

\f1\b0 \
Offset the Signal by a value 
\f0\b in place
\f1\b0 .\
\
\cf2 //(\
//s = 
\f2 Synth.collect(\{ WhiteNoise.ar(0.2) \}, 0.01);\
//SignalWindow.new(signals: [s, s.copy.offset(0.2)]);\
//)\
\cf0 \

\f0\b peak\

\f1\b0 \
Return the peak absolute value of a Signal.\
\
\cf2 //(\
//s = 
\f2 Synth.collect(\{ PinkNoise.ar(0.1, -0.3) \}, 0.01);\
//s.peak.postln;\
//s.plot;\
//)\
\cf0 \
\

\f0\b normalize\

\f1\b0 \
Normalize the Signal 
\f0\b in place
\f1\b0  such that the maximum absolute peak value is 1.\
\
\cf2 //(\
//s = 
\f2 Synth.collect(\{ PinkNoise.ar(0.1) \}, 0.01);\
//SignalWindow.new(signals: [s, s.copy.normalize]);\
//)\
\cf0 \
\

\f0\b normalizeTransfer\

\f1\b0 \
Normalizes a transfer function so that the center value of the table is offset to zero\
and the absolute peak value is 1. Transfer functions are meant to be used in the \
Shaper ugen.\
\

\f2 \
\

\f0\b invert\

\f1\b0 \
Invert the Signal 
\f0\b in place
\f1\b0 .\
\
(\
s = 
\f2 Signal.sineFill(512, [1]);\
SignalWindow.new(signals: [s, s.copy.invert]);\
)\
\
\

\f0\b reverse(beginSamp, endSamp)\

\f1\b0 \
Reverse a subrange of the Signal 
\f0\b in place
\f1\b0 .\
\
(\
s = 
\f2 Signal.sineFill(512, [1]);\
SignalWindow.new(signals: [s, s.copy.reverse(128, 384)]);\
)\
\
\

\f0\b fade(beginSamp, endSamp, beginLevel, endLevel)\

\f1\b0 \
Fade a subrange of the Signal 
\f0\b in place
\f1\b0 .\
\
(\
s = 
\f2 Synth.collect(\{ ClipNoise.ar(0.5) \}, 0.02);\
SignalWindow.new(signals: [s, s.copy.fade(0, 300, 0, 1)]);\
)\
\
\

\f0\b integral\

\f1\b0 \
Return the integral of a signal.\
\

\f2 Synth.collect(\{ PinkNoise.ar(0.1) \}, 0.01).integral.postln;\
\
\

\f0\b overDub(aSignal, index)\

\f1\b0 \
Add a signal to myself starting at the index.\
If the other signal is too long only the first part is overdubbed.\
\
(\
s = 
\f2 Synth.collect(\{ BrownNoise.ar(0.3) \}, 0.05);\

\f1 t = 
\f2 Synth.collect(\{ FSinOsc.ar(800, 0.3) \}, 0.02);\
s.overDub(t, 1000).plot;\
)\
\
\

\f0\b overWrite(aSignal, index)\

\f1\b0 \
Write a signal to myself starting at the index.\
If the other signal is too long only the first part is overdubbed.\
\
(\
s = 
\f2 Synth.collect(\{ BrownNoise.ar(0.3) \}, 0.05);\

\f1 t = 
\f2 Synth.collect(\{ FSinOsc.ar(800, 0.3) \}, 0.02);\
s.overWrite(t, 1000).plot;\
)\
\
\

\f0\b blend(aSignal, blend)\

\f1\b0 \
Blend two signals by some proportion.\
\

\f2 (\
s = Synth.collect(\{ LFPulse.ar(1300, 0.2) \}, 0.01);\
t = Synth.collect(\{ FSinOsc.ar(400) \}, 0.01);\
SignalWindow.new(signals: Array.fill(6, \{ arg i; s.blend(t, i/5) \}));\
) \
\

\f0\b\fs28 \ul Fourier Transform:\
\

\fs24 \ulnone fftCosTable(size)\

\f1\b0 \
Fill a Signal with the cosine table needed by the FFT methods.\
\

\f0\b\fs28 \ul \

\fs24 \ulnone fft(imag, cosTable)\

\f1\b0 \
Perform an FFT on a real and imaginary signal 
\f0\b in place
\f1\b0 .\
\

\f2 (\
var real, imag, table;\
real = Synth.collect(\{ \
		LFPulse.ar(800, 0.2)\
	\}, 4096/Synth.sampleRate) * Signal.hanningWindow(4096);\
imag = Signal.newClear(4096);\
table = Signal.fftCosTable(4096);\
(fft(real, imag, table)/100).plot;\
)\
\
(\
var real, imag, table,complex;\
real = Synth.collect(\{ \
		LFPulse.ar(800, 0.2)\
	\}, 4096/Synth.sampleRate) * Signal.hanningWindow(4096);\
imag = Signal.newClear(4096);\
table = Signal.fftCosTable(4096);\
complex=(fft(real, imag, table)/100);\
complex.real.plot;\
complex.imag.plot;\
)\
\
\

\f0\b ifft(imag, cosTable)\

\f1\b0 \
Perform an inverse FFT on a real and imaginary signal 
\f0\b in place
\f1\b0 .\
\

\f2 (\
var real, imag, table;\
real = Synth.collect(\{ \
		LFSaw.ar(100, 0.2)\
	\}, 4096/Synth.sampleRate);\
imag = Signal.newClear(4096);\
table = Signal.fftCosTable(4096);\
fft(real, imag, table);	// forward transform\
ifft(real, imag, table);	// inverse transform\
real.plot;	// returns the original\
)\

\f1 \

\f0\b\fs28 \ul Unary Messages:\

\f1\b0\fs24 \ulnone \
Signal will respond to unary operators by returning a new Signal.\
\

\f0\b neg, abs, sign, squared, cubed, sqrt\
exp, log, log2, log10, sin, cos, tan, asin, acos, atan, sinh, cosh, tanh, \
distort, softclip, nyqring, isPositive, isNegative,\
isStrictlyPositive\
\

\f2\b0 (\
s = Signal.sineFill(512, [0,0,0,1]);\
SignalWindow.new(signals: \
	[s, s.neg, s.abs, s.sign, s.squared, s.cubed, \
	s.asin.normalize, s.exp.normalize, s.distort, s.nyqring]);\
)\
\

\f1 \
\

\f0\b\fs28 \ul Binary Messages:\

\f1\b0 \ulnone \

\fs24 Signal will respond to binary operators by returning a new Signal.\
\

\f0\b +, -, *, /, div, %, **, min, max, ring1, ring2, ring3, ring4, \
difsqr, sumsqr, sqrdif, absdif, amclip,\
scaleneg, clip2, excess, <!\
\

\f2\b0 (\
s = Synth.collect(\{ WhiteNoise.ar \}, 0.01);\
t = Synth.collect(\{ FSinOsc.ar(400) \}, 0.01);\
SignalWindow.new(signals: \
	[s, t, (s + t) * 0.5, s * t, min(s, t), max(s, t) ]\
);\
) }