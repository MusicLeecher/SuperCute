<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<title></title>
<meta name="Generator" content="Cocoa HTML Writer">
<meta name="CocoaVersion" content="824.42">
<style type="text/css">
p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 18.0px Helvetica}
p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; min-height: 14.0px}
p.p3 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica}
p.p4 {margin: 0.0px 0.0px 0.0px 0.0px; font: 14.0px Helvetica}
p.p5 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco}
p.p6 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Monaco; min-height: 16.0px}
p.p7 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; min-height: 12.0px}
p.p8 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #a71e12}
span.s1 {color: #0019b7}
span.s2 {color: #326f17}
span.s3 {color: #0000ff}
span.s4 {color: #a71e12}
span.s5 {color: #000000}
span.s6 {text-decoration: underline}
span.Apple-tab-span {white-space:pre}
</style>
</head>
<body>
<p class="p1"><b>ArrayedCollection</b></p>
<p class="p2"><br></p>
<p class="p3"><b>Superclass: SequenceableCollection</b></p>
<p class="p2"><br></p>
<p class="p3">ArrayedCollection is an abstract class, a subclass of SequenceableCollections whose elements are held in a vector of slots. Instances of ArrayedCollection have a fixed maximum size beyond which they may not grow.</p>
<p class="p2"><br></p>
<p class="p3">Its principal subclasses are Array (for holding objects), and RawArray, from which Int8Array, FloatArray, Signal etc. inherit.</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p4"><b><i>Class Methods</i></b></p>
<p class="p2"><br></p>
<p class="p3"><b>*with(... args)</b></p>
<p class="p2"><br></p>
<p class="p3">Create a new ArrayedCollection whose slots are filled with the given arguments.</p>
<p class="p2"><br></p>
<p class="p5"><span class="s1">Array</span>.with(7, <span class="s2">'eight'</span>,<span class="Apple-converted-space">  </span>9).postln;</p>
<p class="p2"><br></p>
<p class="p3"><b>*series(size, start, step)</b></p>
<p class="p2"><br></p>
<p class="p3">Fill an ArrayedCollection with an arithmetic series.</p>
<p class="p2"><br></p>
<p class="p5"><span class="s1">Array</span>.series(5, 10, 2).postln;</p>
<p class="p2"><br></p>
<p class="p3"><b>*geom(size, start, grow)</b></p>
<p class="p2"><br></p>
<p class="p3">Fill an ArrayedCollection with a geometric series.</p>
<p class="p2"><br></p>
<p class="p5"><span class="s1">Array</span>.geom(5, 1, 3).postln;</p>
<p class="p6"><br></p>
<p class="p3"><b>*iota(...sizes)</b></p>
<p class="p2"><br></p>
<p class="p3">Fills an ArrayedCollection with a counter. See <a href="../Language/J_concepts_in_SC.html"><span class="s3">J_concepts_in_SC</span></a> for more examples.</p>
<p class="p2"><br></p>
<p class="p5"><span class="s1">Array</span>.iota(2, 3);</p>
<p class="p5"><span class="s1">Array</span>.iota(2, 3, 4);</p>
<p class="p6"><br></p>
<p class="p3"><b>*fill2D(rows, cols, function)</b></p>
<p class="p2"><br></p>
<p class="p3">Creates a 2 dimensional ArrayedCollection of the given sizes. The items are determined by evaluation of the supplied function. The function is passed row and column indexes as arguments. See <a href="../Language/J_concepts_in_SC.html"><span class="s3">J_concepts_in_SC</span></a></p>
<p class="p2"><br></p>
<p class="p5"><span class="s1">Array</span>.fill2D(2, 4, 0);</p>
<p class="p5"><span class="s1">Array</span>.fill2D(3, 4, { <span class="s1">arg</span> r, c; r*c+c; });</p>
<p class="p6"><br></p>
<p class="p3"><b>*fill3D(planes, rows, cols, function)</b></p>
<p class="p2"><br></p>
<p class="p3">Creates a 3 dimensional ArrayedCollection of the given sizes. The items are determined by evaluation of the supplied function. The function is passed plane, row and column indexes as arguments. See <a href="../Language/J_concepts_in_SC.html"><span class="s3">J_concepts_in_SC</span></a></p>
<p class="p2"><br></p>
<p class="p5"><span class="s1">Array</span>.fill3D(2, 3, 4, { <span class="s1">arg</span> p, r, c; p; });</p>
<p class="p7"><br></p>
<p class="p3"><b>*fillND(dimensions, function)</b></p>
<p class="p2"><br></p>
<p class="p3">Creates a N dimensional ArrayedCollection where N is the size of the array <b>dimensions</b>. The items are determined by evaluation of the supplied function. The function is passed N number of indexes as arguments.</p>
<p class="p7"><br></p>
<p class="p5"><span class="s1">Array</span>.fillND([4, 4], { <span class="s1">arg</span> a, b; a+b; });<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s4">//2d</span></p>
<p class="p5"><span class="s1">Array</span>.fillND([4, 4, 4], { <span class="s1">arg</span> a, b, c; a+b*c; });<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s4">//3d</span></p>
<p class="p5"><span class="s1">Array</span>.fillND([1, 2, 3, 4], { <span class="s1">arg</span> a, b, c, d; b+d; });<span class="Apple-tab-span">	</span><span class="s4">//4d</span></p>
<p class="p7"><br></p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p4"><b><i>Instance Methods</i></b></p>
<p class="p6"><br></p>
<p class="p3"><b>at(index)</b></p>
<p class="p2"><br></p>
<p class="p3">Return the <b>item</b> at <b>index</b>.</p>
<p class="p2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p3"><b>clipAt(index)</b></p>
<p class="p2"><br></p>
<p class="p3">Same as <b>at</b>, but values for <b>index</b> greater than the size of the ArrayedCollection will be clipped to the last index.</p>
<p class="p2"><br></p>
<p class="p5">y = [ 1, 2, 3 ];</p>
<p class="p5">y.clipAt(13).postln;</p>
<p class="p2"><span class="Apple-converted-space"> </span></p>
<p class="p3"><b>wrapAt(index)</b></p>
<p class="p2"><br></p>
<p class="p3">Same as <b>at</b>, but values for <b>index</b> greater than the size of the ArrayedCollection will be wrapped around to 0.</p>
<p class="p2"><br></p>
<p class="p5">y = [ 1, 2, 3 ];</p>
<p class="p8"><span class="s5">y.wrapAt(3).postln; </span>// this returns the value at index 0</p>
<p class="p8"><span class="s5">y.wrapAt(4).postln; </span>// this returns the value at index 1</p>
<p class="p2"><br></p>
<p class="p3"><b>foldAt(index)</b></p>
<p class="p2"><br></p>
<p class="p3">Same as <b>at</b>, but values for <b>index</b> greater than the size of the ArrayedCollection will be folded back.</p>
<p class="p2"><br></p>
<p class="p5">y = [ 1, 2, 3 ];</p>
<p class="p8"><span class="s5">y.foldAt(3).postln; </span>// this returns the value at index 1</p>
<p class="p8"><span class="s5">y.foldAt(4).postln; </span>// this returns the value at index 0</p>
<p class="p8"><span class="s5">y.foldAt(5).postln; </span>// this returns the value at index 1</p>
<p class="p2"><br></p>
<p class="p3"><b>swap(i, j)</b></p>
<p class="p2"><br></p>
<p class="p3">Swap the values at indices i and j.</p>
<p class="p2"><br></p>
<p class="p5">[ 1, 2, 3 ].swap(0, 2).postln;</p>
<p class="p2"><br></p>
<p class="p3"><b>put(index, item)</b></p>
<p class="p2"><br></p>
<p class="p3">Put <b>item</b> at <b>index</b>, replacing what is there.</p>
<p class="p2"><br></p>
<p class="p3"><b>clipPut(index, item)</b></p>
<p class="p2"><br></p>
<p class="p3">Same as <b>put</b>, but values for <b>index</b> greater than the size of the ArrayedCollection will be clipped to the last index.</p>
<p class="p2"><span class="Apple-converted-space"> </span></p>
<p class="p3"><b>wrapPut(index, item)</b></p>
<p class="p2"><br></p>
<p class="p3">Same as <b>put</b>, but values for <b>index</b> greater than the size of the ArrayedCollection will be wrapped around to 0.</p>
<p class="p2"><br></p>
<p class="p3"><b>foldPut(index)</b></p>
<p class="p2"><br></p>
<p class="p3">Same as <b>put</b>, but values for <b>index</b> greater than the size of the ArrayedCollection will be folded back.</p>
<p class="p2"><br></p>
<p class="p3"><b>removeAt(index)</b></p>
<p class="p2"><br></p>
<p class="p3">Remove and return the element at <b>index</b>, shrinking the size of the ArrayedCollection.</p>
<p class="p2"><br></p>
<p class="p5">y = [ 1, 2, 3 ];<span class="Apple-converted-space"> </span></p>
<p class="p5">y.removeAt(1);<span class="Apple-converted-space"> </span></p>
<p class="p5">y.postln;</p>
<p class="p2"><br></p>
<p class="p3"><b>takeAt(index)</b></p>
<p class="p2"><br></p>
<p class="p3">Same as <b>removeAt</b>, but reverses the order of the items following those that which was taken.</p>
<p class="p6"><br></p>
<p class="p5">y = [ 1, 2, 3, 4 ];<span class="Apple-converted-space"> </span></p>
<p class="p5">y.takeAt(1);<span class="Apple-converted-space"> </span></p>
<p class="p5">y.postln;</p>
<p class="p6"><br></p>
<p class="p3"><b>takeThese(function)</b></p>
<p class="p2"><br></p>
<p class="p3">Removes all items in the receiver for which the <b>function</b> answers true. The function is passed two arguments, the item and an integer index. Note that order is not preserved. See <b>takeAt</b>.</p>
<p class="p6"><br></p>
<p class="p5">y = [ 1, 2, 3, 4 ];</p>
<p class="p5">y.takeThese({ <span class="s1">arg</span> item, index; item.odd; });<span class="Apple-tab-span">	</span><span class="s4">//remove odd items</span></p>
<p class="p5">y.postln;</p>
<p class="p6"><br></p>
<p class="p3"><b>add(item)</b></p>
<p class="p2"><br></p>
<p class="p3">Adds an item to an ArrayedCollection if there is space. If there is not any space left in the object then this method returns a new ArrayedCollection. For this reason, you should always assign the result of add to a variable - never depend on add changing the receiver.</p>
<p class="p2"><br></p>
<p class="p5">(</p>
<p class="p8">// z and y are the same object</p>
<p class="p5"><span class="s1">var</span> y, z;</p>
<p class="p5">z = [1, 2, 3];</p>
<p class="p5">y = z.add(4);</p>
<p class="p5">z.postln;</p>
<p class="p5">y.postln;</p>
<p class="p5">)</p>
<p class="p6"><br></p>
<p class="p5">(</p>
<p class="p8">// in this case a new object is returned</p>
<p class="p5"><span class="s1">var</span> y, z;</p>
<p class="p5">z = [1, 2, 3, 4];</p>
<p class="p5">y = z.add(5);</p>
<p class="p5">z.postln;</p>
<p class="p5">y.postln;</p>
<p class="p5">)</p>
<p class="p6"><br></p>
<p class="p3"><b>addAll(aCollection)</b></p>
<p class="p2"><br></p>
<p class="p3">Adds all the elements of aCollection to the contents of the receiver, possibly returning a new collection.</p>
<p class="p2"><br></p>
<p class="p5">(</p>
<p class="p8">// in this case a new object is returned</p>
<p class="p5"><span class="s1">var</span> y, z;</p>
<p class="p5">z = [1, 2, 3, 4];</p>
<p class="p5">y = z.addAll([7, 8, 9]);</p>
<p class="p5">z.postln;</p>
<p class="p5">y.postln;</p>
<p class="p5">)</p>
<p class="p2"><br></p>
<p class="p3"><b>extend(size, item)</b></p>
<p class="p2"><br></p>
<p class="p3">Extends the receiver to match <b>size</b> by adding a number of <b>item</b>s. If <b>size</b> is less than receiver size then truncate.</p>
<p class="p2"><br></p>
<p class="p5">(</p>
<p class="p5"><span class="s1">var</span> y, z;</p>
<p class="p5">z = [1, 2, 3, 4];</p>
<p class="p8"><span class="s5">y = z.extend(10, 9);<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>//fill up with 9 until the size equals 10</p>
<p class="p5">z.postln;</p>
<p class="p5">y.postln;</p>
<p class="p5">)</p>
<p class="p2"><br></p>
<p class="p3"><b>fill(value)</b></p>
<p class="p2"><br></p>
<p class="p3">Inserts the item into the contents of the receiver, possibly returning a new collection. Note the difference between this and Collection's *fill.</p>
<p class="p2"><br></p>
<p class="p5">(</p>
<p class="p5"><span class="s1">var</span> z;</p>
<p class="p5">z = <span class="s1">List</span>[1, 2, 3, 4];</p>
<p class="p5">z.fill(4).postln;</p>
<p class="p5">z.fill([1,2,3,4]).postln;</p>
<p class="p5">)</p>
<p class="p2"><br></p>
<p class="p3"><b>insert(index, item)</b></p>
<p class="p2"><br></p>
<p class="p3">Inserts the item into the contents of the receiver, possibly returning a new collection.</p>
<p class="p2"><br></p>
<p class="p5">(</p>
<p class="p8">// in this case a new object is returned</p>
<p class="p5"><span class="s1">var</span> y, z;</p>
<p class="p5">z = [1, 2, 3, 4];</p>
<p class="p5">y = z.insert(1, 999);</p>
<p class="p5">z.postln;</p>
<p class="p5">y.postln;</p>
<p class="p5">)</p>
<p class="p6"><br></p>
<p class="p3"><b>addFirst(item)</b></p>
<p class="p2"><br></p>
<p class="p3">Inserts the item before the contents of the receiver, possibly returning a new collection.</p>
<p class="p2"><br></p>
<p class="p5">(</p>
<p class="p8">// in this case a new object is returned</p>
<p class="p5"><span class="s1">var</span> y, z;</p>
<p class="p5">z = [1, 2, 3, 4];</p>
<p class="p5">y = z.addFirst(999);</p>
<p class="p5">z.postln;</p>
<p class="p5">y.postln;</p>
<p class="p5">)</p>
<p class="p6"><br></p>
<p class="p3"><b>pop</b></p>
<p class="p2"><br></p>
<p class="p3">Remove and return the last element of the ArrayedCollection.</p>
<p class="p2"><br></p>
<p class="p5">(</p>
<p class="p5"><span class="s1">var</span> z;</p>
<p class="p5">z = [1, 2, 3, 4];</p>
<p class="p5">z.pop.postln;</p>
<p class="p5">z.postln;</p>
<p class="p5">)</p>
<p class="p2"><br></p>
<p class="p3"><b>grow(sizeIncrease)</b></p>
<p class="p2"><br></p>
<p class="p3">Increase the size of the ArrayedCollection by <b>sizeIncrease </b>number of slots,<span class="Apple-converted-space">  </span>possibly returning a new collection.</p>
<p class="p2"><br></p>
<p class="p3"><b>copyRange(start, end)</b></p>
<p class="p2"><br></p>
<p class="p3">Return a new ArrayedCollection which is a copy of the indexed slots of the receiver from start to end.</p>
<p class="p6"><br></p>
<p class="p5">(</p>
<p class="p5"><span class="s1">var</span> y, z;</p>
<p class="p5">z = [1, 2, 3, 4, 5];</p>
<p class="p5">y = z.copyRange(1,3);</p>
<p class="p5">z.postln;</p>
<p class="p5">y.postln;</p>
<p class="p5">)</p>
<p class="p7"><br></p>
<p class="p3"><b>copySeries(first, second, last)</b></p>
<p class="p2"><br></p>
<p class="p3">Return a new ArrayedCollection consisting of the values starting at <b>first</b>, then every step of the distance between <b>first</b> and <b>second</b>, up until <b>last</b>.</p>
<p class="p3">x.copySeries(a, b, c) can also be written as <b>x[a, b..c]</b></p>
<p class="p6"><br></p>
<p class="p5">(</p>
<p class="p5"><span class="s1">var</span> y, z;</p>
<p class="p5">z = [1, 2, 3, 4, 5, 6];</p>
<p class="p5">y = z.copySeries(0, 2, 5);</p>
<p class="p5">y.postln;</p>
<p class="p5">)</p>
<p class="p7"><br></p>
<p class="p3"><b>putSeries(first, second, last, value)</b></p>
<p class="p2"><br></p>
<p class="p3">Put <b>value</b> at every index starting at <b>first</b>, then every step of the distance between <b>first</b> and <b>second</b>, up until <b>last</b>.</p>
<p class="p3">x.putSeries(a, b, c, val) can also be written as <b>x[a, b..c] = val</b></p>
<p class="p6"><br></p>
<p class="p5">(</p>
<p class="p5"><span class="s1">var</span> y, z;</p>
<p class="p5">z = [1, 2, 3, 4, 5, 6];</p>
<p class="p5">y = z.putSeries(0, 2, 5, "foo");</p>
<p class="p5">y.postln;</p>
<p class="p5">)</p>
<p class="p6"><br></p>
<p class="p3"><b>++ aCollection</b></p>
<p class="p6"><br></p>
<p class="p3">Concatenate the contents of the two collections into a new ArrayedCollection.</p>
<p class="p2"><br></p>
<p class="p5">(</p>
<p class="p5"><span class="s1">var</span> y, z;</p>
<p class="p5">z = [1, 2, 3, 4];</p>
<p class="p5">y = z ++ [7, 8, 9];</p>
<p class="p5">z.postln;</p>
<p class="p5">y.postln;</p>
<p class="p5">)</p>
<p class="p6"><br></p>
<p class="p3"><b>reverse</b></p>
<p class="p2"><br></p>
<p class="p3">Return a new ArrayedCollection whose elements are reversed.</p>
<p class="p2"><br></p>
<p class="p5">(</p>
<p class="p5"><span class="s1">var</span> y, z;</p>
<p class="p5">z = [1, 2, 3, 4];</p>
<p class="p5">y = z.reverse;</p>
<p class="p5">z.postln;</p>
<p class="p5">y.postln;</p>
<p class="p5">)</p>
<p class="p6"><br></p>
<p class="p3"><b>do(function)</b></p>
<p class="p2"><br></p>
<p class="p3">Iterate over the elements in order, calling the function for each element. The function is passed two arguments, the element and an index.</p>
<p class="p2"><br></p>
<p class="p5">[<span class="s2">'a'</span>, <span class="s2">'b'</span>, <span class="s2">'c'</span>].do({ <span class="s1">arg</span> item, i; [i, item].postln; });</p>
<p class="p6"><br></p>
<p class="p3"><b>reverseDo(function)</b></p>
<p class="p2"><br></p>
<p class="p3">Iterate over the elements in reverse order, calling the function for each element. The function is passed two arguments, the element and an index.</p>
<p class="p2"><br></p>
<p class="p5">[<span class="s2">'a'</span>, <span class="s2">'b'</span>, <span class="s2">'c'</span>].reverseDo({ <span class="s1">arg</span> item, i; [i, item].postln; });</p>
<p class="p6"><br></p>
<p class="p3"><b>windex</b></p>
<p class="p2"><br></p>
<p class="p3">Interprets the array as a list of probabilities which should sum to 1.0 and returns a random index value based on those probabilities.</p>
<p class="p6"><br></p>
<p class="p5">(</p>
<p class="p5"><span class="s1">Array</span>.fill(10, {</p>
<p class="p5"><span class="Apple-tab-span">	</span>[0.1, 0.6, 0.3].windex;</p>
<p class="p5">}).postln;</p>
<p class="p5">)</p>
<p class="p6"><br></p>
<p class="p3"><b>normalizeSum</b></p>
<p class="p2"><br></p>
<p class="p3">Returns the Array resulting from :<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p5">(<span class="s1">this</span> / <span class="s1">this</span>.sum)</p>
<p class="p6"><br></p>
<p class="p3">so that the array will sum to 1.0.</p>
<p class="p2"><br></p>
<p class="p3">This is useful for using with windex or wchoose.</p>
<p class="p6"><br></p>
<p class="p5">[1, 2, 3].normalizeSum.postln;</p>
<p class="p6"><br></p>
<p class="p3"><b>normalize(min, max)</b></p>
<p class="p2"><br></p>
<p class="p3">Returns a new Array with the receiver items normalized between <b>min</b> and <b>max</b>.</p>
<p class="p6"><br></p>
<p class="p5">[1, 2, 3].normalize;<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s4">//default min=0, max= 1</span></p>
<p class="p5">[1, 2, 3].normalize(-20, 10);</p>
<p class="p6"><br></p>
<p class="p3"><b>perfectShuffle</b></p>
<p class="p2"><br></p>
<p class="p3">Returns a copy of the receiver with its items split into two equal halves, then reconstructed by interleaving the two halves. Note: use an even number of item pairs in order to not loose any items in the shuffle.</p>
<p class="p6"><br></p>
<p class="p5">(</p>
<p class="p5"><span class="s1">var</span> y, z;</p>
<p class="p5">z = [ 1, 2, 3, 4, 5, 6 ];</p>
<p class="p5">y = z.perfectShuffle;</p>
<p class="p5">z.postln;</p>
<p class="p5">y.postln;</p>
<p class="p5">)</p>
<p class="p6"><br></p>
<p class="p3"><b>performInPlace(selector, from, to, argList)</b></p>
<p class="p2"><br></p>
<p class="p3">performs a method in place, within a certain region [from..to], returning the same array.</p>
<p class="p2"><br></p>
<p class="p5">a = (0..10);</p>
<p class="p5">a.performInPlace(\normalizeSum, 3, 6);<span class="Apple-converted-space"> </span></p>
<p class="p7"><br></p>
<p class="p2"><br></p>
<p class="p3"><b>find(anotherArray)</b></p>
<p class="p2"><br></p>
<p class="p3">finds the starting index of a number of elements contained in the array.</p>
<p class="p2"><br></p>
<p class="p5">a = (0..10);</p>
<p class="p5">a.find([4, 5, 6]);<span class="Apple-converted-space"> </span></p>
<p class="p7"><br></p>
<p class="p7"><br></p>
<p class="p3"><b>replace(anotherArray)</b></p>
<p class="p2"><br></p>
<p class="p3">return a new array in which a number of elements have been replaced by another<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p5">a = (0..10) ++ (0..10);</p>
<p class="p5">a.replace([4, 5, 6], 100);<span class="Apple-converted-space"> </span></p>
<p class="p5">a.replace([4, 5, 6], [1734, 1985, 1860]);</p>
<p class="p7"><br></p>
<p class="p3">this method is inherited by String:</p>
<p class="p7"><br></p>
<p class="p5">a = "hello world";</p>
<p class="p5">a.replace("world", "word");</p>
<p class="p7"><br></p>
<p class="p7"><br></p>
<p class="p3"><b>asRandomTable</b></p>
<p class="p2"><br></p>
<p class="p3">return an integral table that can be used to generate random numbers with a specified distribution.</p>
<p class="p3">(see<span class="s6"> [Randomness] </span>helpfile for a more detailed example)</p>
<p class="p2"><br></p>
<p class="p5">(</p>
<p class="p5">a = (0..100) ++ (100..50) / 100; // distribution</p>
<p class="p5">a = a.asRandomTable;</p>
<p class="p5">)</p>
<p class="p7"><br></p>
<p class="p7"><br></p>
<p class="p3"><b>tableRand</b></p>
<p class="p2"><br></p>
<p class="p3">returns a new random number from a random table.</p>
<p class="p2"><br></p>
<p class="p5">(</p>
<p class="p5">a = (0..100) ++ (100..50) / 100; // distribution</p>
<p class="p5">a = a.asRandomTable;</p>
<p class="p5">20.do { a.tableRand.postln };</p>
<p class="p5">)</p>
<p class="p7"><br></p>
<p class="p7"><br></p>
<p class="p3"><b>msgSize</b></p>
<p class="p2"><br></p>
<p class="p3">return the size of an osc message in bytes</p>
<p class="p2"><br></p>
<p class="p5">a = ["/s_new", "default", -1, "freq", 440];</p>
<p class="p5">a.msgSize;</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p3"><b>bundleSize</b></p>
<p class="p2"><br></p>
<p class="p3">return the size of an osc bundle in bytes</p>
<p class="p2"><br></p>
<p class="p5">a = [["/s_new", "default", -1, "freq", 440], ["/s_new", "default", -1, "freq", 220]];</p>
<p class="p5">a.bundleSize;</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
</body>
</html>
