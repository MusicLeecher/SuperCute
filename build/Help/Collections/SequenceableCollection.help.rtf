{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 SequenceableCollection
\f1\b0\fs24 \
\

\f0\b Superclass: Collection\

\f1\b0 \
SequenceableCollection is a class of Collections whose elements can be indexed by an Integer.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 \ul Class Methods\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 \ulnone \

\f0\b *series(size, start, step)\

\f1\b0 \
Fill a SequenceableCollection with an arithmetic series.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 Array.series(5, 10, 2).postln;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 \

\f0\b *geom(size, start, grow)\

\f1\b0 \
Fill a SequenceableCollection with a geometric series.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 Array.geom(5, 1, 3).postln;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 *rand(size, minVal, maxVal)\

\f1\b0 \
Fill a SequenceableCollection with random values in the range minVal to maxVal.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 Array.rand(8, 1, 100).postln;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 *rand2(size, val)\

\f1\b0 \
Fill a SequenceableCollection with random values in the range -val to +val.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 Array.rand2(8, 100).postln;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 *linrand(size, minVal, maxVal)\

\f1\b0 \
Fill a SequenceableCollection with random values in the range minVal to maxVal with a linear\
distribution.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 Array.linrand(8, 1, 100).postln;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 \ul Instance Methods
\f2\b0\fs24 \ulnone \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 first
\f1\b0 \
\
Return the first element of the collection,\
\

\f0\b last
\f1\b0 \
\
Return the first element of the collection,\
\
\

\f0\b indexOf(item)\

\f1\b0 \
	Return the index of item in the collection, or nil if not found.\
\

\f0\b indexIn(val)
\f1\b0 \
	\
	returns the closest index of the value in the collection (collection must be sorted)\
	\
	
\f2\fs18 [2, 3, 5, 6].indexIn(5.2)\
	
\f1\fs24 \

\f0\b indexInBetween(val)
\f1\b0 \
\
	returns a linearly interpolated float index for the value (collection must be sorted)\
	inverse operation is 
\f0\b blendAt
\f1\b0 \
	\
	
\f2\fs18 x = [2, 3, 5, 6].indexInBetween(5.2)\
	[2, 3, 5, 6].blendAt(x)
\f1\fs24 \
\
\

\f0\b blendAt(floatIndex)\
\

\f1\b0 	returns a linearly interpolated value between the two closest indices\
	inverse operation is 
\f0\b indexInBetween\
	
\f2\b0\fs18 x = [2, 5, 6].blendAt(0.4)
\f1\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 nearest(val)
\f1\b0 \
\
	returns the value in the collection closest to val\
	\
	
\f2\fs18 (\
		l = [0, 0.5, 0.9, 1];\
		(0, 0.05..1).collect \{ |i| l.nearest(i) \}\
	)\

\f1\fs24 \
\

\f0\b nearestInScale(val, stepsPerOctave)
\f1\b0 \
\
	returns the value in the collection closest to val, assuming an octave repeating table of note values.\
	stepsPerOctave is 12 by default\
	\
	
\f2\fs18 (\
		l = [0, 1, 5, 9, 11]; \cf2 // pentatonic scale\cf0 \
		(60, 61..76).collect \{ |i| l.nearestInScale(i, 12) \}\
	)
\f1\fs24 \
	
\f2 \
\

\f0\b copyRange(start, end)\

\f1\b0 \
Return a new ArrayedCollection which is a copy of the indexed slots of the receiver from start to end.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 \
(\
var y, z;\
z = [1, 2, 3, 4, 5];\
y = z.copyRange(1,3);\
z.postln;\
y.postln;\
)\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 remove(item)\

\f1\b0 \
Remove item from collection.\
\

\f0\b flat
\f1\b0 \
\
Returns a collection from which all nesting has been flattened.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 [[1, 2, 3],[[4, 5],[[6]]]].flat.postln;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 flatten(numLevels)
\f1\b0 \
\
Returns a collection from which numLevels of nesting has been flattened.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 [[1, 2, 3],[[4, 5],[[6]]]].flatten(1).asCompileString.postln;\
\
[[1, 2, 3],[[4, 5],[[6]]]].flatten(2).asCompileString.postln;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 flop
\f1\b0 \
\
Invert rows and columns in a two dimensional collection.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 [[1, 2, 3, 4],[5, 6, 7, 8],[9, 10, 11, 12]].flop.asCompileString.postln;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 choose
\f1\b0 \
\
Choose an element from the collection at random.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 [1, 2, 3, 4].choose.postln;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 \

\f0\b wchoose
\f1\b0 \
\
Choose an element from the collection at random using a list of probabilities or weights.\
The weights must sum to 1.0.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 [1, 2, 3, 4].wchoose([0.1, 0.2, 0.3, 0.4]).postln;
\f1 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 sort(function)\

\f1\b0 \
Sort the contents of the collection using the comparison function argument.\
The function should take two elements as arguments and return true if the first\
argument should be sorted before the second argument.\
If the function is nil, the following default function is used.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 \{ arg a, b; a < b \}\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs18 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 [6, 2, 1, 7, 5].sort.postln;\
\
[6, 2, 1, 7, 5].sort(\{ arg a, b; a > b \}).postln; // reverse sort\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 \

\f0\b swap(i, j)\

\f1\b0 \
Swap two elements in the collection at indices i and j.\
\

\f0\b doAdjacentPairs(function)\

\f1\b0 \
Calls function for every adjacent pair of elements in the SequentialCollection.\
The function is passed the two adjacent elements and an index.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 [1, 2, 3, 4, 5].doAdjacentPairs(\{ arg a, b; [a, b].postln; \});\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 \

\f0\b separate(function)\

\f1\b0 \
Separates the collection into sub-collections by calling the function for each adjacent pair of elements.\
If the function returns true, then a separation is made between the elements.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0  [1, 2, 3, 5, 6, 8, 10].separate(\{ arg a, b; (b - a) > 1 \}).asCompileString.postln;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 clump(groupSize)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 Separates the collection into sub-collections by separating every groupSize elements.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 [1, 2, 3, 4, 5, 6, 7, 8].clump(3).asCompileString.postln;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 clumps(groupSizeList)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 Separates the collection into sub-collections by separating elements into groupings whose size\
is given by integers in the groupSizeList.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 [1, 2, 3, 4, 5, 6, 7, 8].clumps([1,2]).asCompileString.postln;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 curdle(probability)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 Separates the collection into sub-collections by separating elements according to the\
given probability.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 [1, 2, 3, 4, 5, 6, 7, 8].curdle(0.3).asCompileString.postln;\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 \ul Math Support\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 \ulnone \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 \ul Unary Messages:\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 \ulnone \
All of the following messages send the message performUnaryOp to the receiver with the\
unary message selector as an argument.\
\

\f0\b neg, reciprocal, bitNot, abs, asFloat, asInt, ceil, floor, frac, sign, squared, cubed, sqrt\
exp, midicps, cpsmidi, midiratio, ratiomidi, ampdb, dbamp, octcps, cpsoct, log, log2,\
log10, sin, cos, tan, asin, acos, atan, sinh, cosh, tanh, rand, rand2, linrand, bilinrand,\
sum3rand, distort, softclip, nyqring, coin, even, odd, isPositive, isNegative,\
isStrictlyPositive, real, imag, magnitude, magnitudeApx, phase, angle, rho, theta,\
asFloat, asInteger\

\f1\b0 \

\f0\b performUnaryOp(selector)\

\f1\b0 \
Creates a new collection of the results of applying the selector to all elements in the receiver.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 \
[1, 2, 3, 4].neg.postln;\
\
[1, 2, 3, 4].reciprocal.postln;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 \ul Binary Messages:\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 \ulnone \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs24 \cf0 All of the following messages send the message performBinaryOp to the receiver with the\
binary message selector and the second operand as arguments.\
\

\f0\b +, -, *, /, div, %, **, min, max, <, <=, >, >=, &, |, bitXor, lcm, gcd, round, trunc, atan2, \
hypot, >>, +>>, fill, ring1, ring2, ring3, ring4, difsqr, sumsqr, sqrdif, absdif, amclip,\
scaleneg, clip2, excess, <!, rrand, exprand\

\f1\b0 \

\f0\b performBinaryOp(selector, theOperand)\

\f1\b0 \
Creates a new collection of the results of applying the selector with the operand to all elements \
in the receiver.\
If the operand is a collection then elements of that collection are paired with elements of\
the receiver.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 ([1, 2, 3, 4] * 10).postln;\
\
([1, 2, 3, 4] * [4, 5, 6, 7]).postln;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 \
}