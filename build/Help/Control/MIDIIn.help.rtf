{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fnil\fcharset77 Monaco;\f2\fswiss\fcharset77 Helvetica;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red0\green0\blue191;\red191\green0\blue0;
\red2\green2\blue2;\red96\green96\blue96;\red0\green115\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf2 MIDIIn
\f1\b0\fs18 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf2 A\cf0  popular 80s technology\
\

\f2\b0 This document explains technical details of the MIDI hardware interface class, MIDIIn. See the 
\f0\b [UsingMIDI]
\f2\b0  helpfile for practical considerations and techniques for using MIDI in SC.\

\f0\b \
\
MIDIIn 
\f2\b0 links MIDI input received from the operating system to a set of user defined functions.\
Only one set of MIDI input handling functions can be active at a time, they are stored in the\
following class variables:\
\
	noteOff, noteOn, polytouch, control, program, touch, bend, sysex, sysrt, smpte\

\f0\b \

\f2\b0 The first argument these functions receive is an unique identifier that specifies the source of the data.\

\f0\b \
Quick start for 1 port:\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs18 \cf0 \
(\
	\cf3 MIDIIn\cf0 .connect; 	\cf4 // init for one port midi interface\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 // register functions:	\cf0 \
	\cf3 MIDIIn\cf0 .noteOff = \{ \cf3 arg\cf0  src, chan, num, vel; 	[chan,num,vel / 127].postln; \};\
	\cf3 MIDIIn\cf0 .noteOn = \{ \cf3 arg\cf0  src, chan, num, vel; 	[chan,num,vel / 127].postln; \};\
	\cf3 MIDIIn\cf0 .polytouch = \{ \cf3 arg\cf0  src, chan, num, vel; 	[chan,num,vel / 127].postln; \};\
	\cf3 MIDIIn\cf0 .control = \{ \cf3 arg\cf0  src, chan, num, val; 	[chan,num,val].postln; \};\
	\cf3 MIDIIn\cf0 .program = \{ \cf3 arg\cf0  src, chan, prog; 		[chan,prog].postln; \};\
	\cf3 MIDIIn\cf0 .touch = \{ \cf3 arg\cf0  src, chan, pressure; 	[chan,pressure].postln; \};\
	\cf3 MIDIIn\cf0 .bend = \{ \cf3 arg\cf0  src, chan, bend; 			[chan,bend - 8192].postln; \};\
	\cf3 MIDIIn\cf0 .sysex = \{ \cf3 arg\cf0  src, sysex; 			sysex.postln; \};\
	\cf3 MIDIIn\cf0 .sysrt = \{ \cf3 arg\cf0  src, chan, val; 			[chan,val].postln; \};\
	\cf3 MIDIIn\cf0 .smpte = \{ \cf3 arg\cf0  src, chan, val; 			[chan,val].postln; \};\
)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 \
Quick start for 2 or more ports:\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs18 \cf3 (\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 	\cf3 var\cf0  inPorts = 2;\
	\cf3 var\cf0  outPorts = 2;\
	\cf3 MIDIClient\cf0 .init(inPorts,outPorts);			\cf4 // explicitly intialize the client\
\cf0 	inPorts.do(\{ arg i; \
	\cf3 	MIDIIn\cf0 .connect(i, \cf3 MIDIClient\cf0 .sources.at(i));\
	\});\
)\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 \ul class methods:\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs18 \cf0 \ulnone 	 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 *noteOn_(function)\
	function 
\f2\b0 is evaluated whenever a MIDI noteOn message is received, it is passed the following arguments:\

\f0\b 	
\f2\b0 uid						unique identifier of the MIDI port\
	MIDIchannel				ranges from 0 to 15		\
	keyNumber				0 - 127\
	velocity					0 - 127	
\f0\b \
*noteOff_(function)\
	
\f2\b0 uid						unique identifier of the MIDI port\
	MIDIchannel				ranges from 0 to 15		\
	keyNumber				0 - 127\
	velocity					0 - 127,	typically 64 unless noteOff velocity is supported
\f0\b \

\f2\b0 		\

\f0\b *polytouch_(function)\
	
\f2\b0 uid						unique identifier of the MIDI port\
	MIDIchannel				ranges from 0 to 15		\
	keyNumber				0 - 127\
	pressure					0 - 127
\f0\b \
*control_(function)\
	
\f2\b0 uid						unique identifier of the MIDI port\
	MIDIchannel				ranges from 0 to 15		\
	controllerNumber			0 - 127\
	value					0 - 127
\f0\b \
*program_(function)\
	
\f2\b0 uid						unique identifier of the MIDI port\
	MIDIchannel				ranges from 0 to 15		\
	programNumber			0 - 127\

\f0\b *touch_(function)\
	
\f2\b0 uid						unique identifier of the MIDI port\
	MIDIchannel				ranges from 0 to 15		\
	pressure					0 - 127
\f0\b \
*bend_(function)\
	
\f2\b0 uid						unique identifier of the MIDI port\
	MIDIchannel				ranges from 0 to 15		\
	bend		
\f0\b 			
\f2\b0 0..16384,   the  midpoint is 8192\

\f0\b *sysex_(function)\
	
\f2\b0 uid						unique identifier of the MIDI port\
	system exclusive data		an Int8Array (includes f0 and f7) \
							see manufacturer references for details\
	note: The current implementation  assembles a complete system exclusive packet\
 before evaluating the function.\

\f0\b *sysrt_(function)\
	
\f2\b0 uid						unique identifier of the MIDI port\
	index					ranges from 0 to 15		\
	data						0 - 127\
	
\f0\b \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf5 	index		data			message\

\f2\b0 	2			14bits		song pointer	\
	3 			7bits			song select\
	8						midiclock\
	10						start\
	11						continue\
	12						stop
\f0\b \cf0 \
\
*smpte\
	
\f2\b0 uid						unique identifier of the MIDI port\
	index					ranges from 0 to 7	\
	data						4 bits\
	\
	Over MIDI, SMPTE is transmitted at 1/4 frame intervals four times faster than the frame rate.\
		index				data\
		0					frames low nibble\
		1					frames hi nibble\
		2					seconds low nibble\
		3					seconds hi nibble\
		4					minutes low nibble\
		5					minutes hi nibble\
		6					hours low nibble\
		7					hours hi 
\f0\b bit
\f2\b0  OR'ed with frameRate\
							0 -> 24fps\
							2 -> 25 fps\
							4 -> 30 fps drop frame\
							6 -> 30 fps\
		Nibbles are sent in ascending order, \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 	\
\
(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 MIDIIn\cf0 .connect;\
s = \cf3 Server\cf0 .local;\
s.boot;\
s.latency = 0;\
\
\cf3 SynthDef\cf0 (\cf6 "sik-goo"\cf0 , \{ \cf3 arg\cf0  freq=440,formfreq=100,gate=0.0,bwfreq=800;\
	\cf3 var\cf0  x;\
	x = \cf3 Formant\cf0 .ar(\
			\cf3 SinOsc\cf0 .kr(0.02, 0, 10, freq), \
			formfreq,\
			bwfreq\
			);\
	x = \cf3 EnvGen\cf0 .kr(\cf3 Env\cf0 .adsr, gate,\cf3 Latch\cf0 .kr(gate,gate)) * x;\
	\cf3 Out\cf0 .ar(0, x);\
\}).send(s);\
\
x = \cf3 Synth\cf0 (\cf6 "sik-goo"\cf0 );\
\
\cf4 //set the action:\cf0 \
\cf3 MIDIIn\cf0 .noteOn = \{\cf3 arg\cf0  src, chan, num, vel;\
				x.set(\cf7 \\freq\cf0 , num.midicps / 4.0);\
				x.set(\cf7 \\gate\cf0 , vel / 200 );\
				x.set(\cf7 \\formfreq\cf0 , vel / 127 * 1000);\
			\};\
\cf3 MIDIIn\cf0 .noteOff = \{ \cf3 arg\cf0  src,chan,num,vel;\
				x.set(\cf7 \\gate\cf0 , 0.0);\
			\};\
\cf3 MIDIIn\cf0 .bend = \{ \cf3 arg\cf0  src,chan,val;\
				\cf4 //(val * 0.048828125).postln;\cf0 \
				x.set(\cf7 \\bwfreq\cf0 , val * 0.048828125 );\
			\};\
)\
\
\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf4 //i used this and got acceptable latency for triggering synths live.\cf0 \
\cf4 //The latency might actually be less than sc2, but i haven't used it enough\cf0 \
\cf4 //to tell for sure yet.\cf0 \
\cf4 //Powerbook G4, 512mb ram.\cf0 \
- matrix6k@somahq.com\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 \
\
writing to the bus rather than directly to the synth\
\
s = \cf3 Server\cf0 .local;\
s.boot;\
\
(\
s.latency = 0;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 SynthDef\cf0 (\cf6 "moto-rev"\cf0 , \{ \cf3 arg\cf0  ffreq=100;\
	\cf3 var\cf0  x;\
	x = \cf3 RLPF\cf0 .ar(\cf3 LFPulse\cf0 .ar(\cf3 SinOsc\cf0 .kr(0.2, 0, 10, 21), [0,0.1], 0.1),\
			 ffreq, 0.1)\
			 .clip2(0.4);\
	\cf3 Out\cf0 .ar(0, x);\
\}).send(s);\
\
b = \cf3 Bus\cf0 .control(s);\
\
x = \cf3 Synth\cf0 (\cf6 "moto-rev"\cf0 );\
\
\cf4 // map the synth's first input (ffreq) to read\cf0 \
\cf4 // from the bus' output index\cf0 \
x.map(0,b.index);\
\
\
\cf3 MIDIIn\cf0 .connect;\
\cf4 //set the action:\cf0 \
\cf3 MIDIIn\cf0 .noteOn = \{\cf3 arg\cf0  src, chan, num, vel;\
				b.value = num.midicps.postln;\
			\};\
\
\cf3 MIDIIn\cf0 .control = \{\cf3 arg\cf0  src, chan, num, val;\
				[chan,num,val].postln;\
			\};\
\cf3 MIDIIn\cf0 .bend = \{\cf3 arg\cf0  src, chan, val;\
				val.postln;\
			\};\
)\
\
\cf4 // cleanup\cf0 \
x.free;\
b.free;\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf3 Keyboard\cf0  \cf3 Split\cf0  for two voices\
pbend to cutoff, mod to rez, 7 to amp\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0 \cf4 // - matrix6k@somahq.com
\f1\fs18 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs20 \cf0 prepare
\f1\b0\fs18 \
s.boot;\
(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 SynthDef\cf0 (\cf6 "funk"\cf0 ,\{ \cf3 arg\cf0  freq = 700, amp = 0.2, gate = 1, cutoff = 20000, rez = 1, lfospeed=0;\
     \cf3 var\cf0  e,x,env,range,filterfreq;\
	e = \cf3 Env\cf0 .new([0, 0.1, 0.1, 0], [0, 0.1, 0.1], \cf7 'linear'\cf0 , 2);\
	env=\cf3 Env\cf0 .adsr(0.3,1,1,1);\
	range = cutoff -1;\
	filterfreq = \cf3 SinOsc\cf0 .kr(lfospeed,0, range, cutoff).abs;\
	x = \cf3 RLPF\cf0 .ar(\cf3 Mix\cf0 .ar([\
			\cf3 Mix\cf0 .arFill(2, \{\cf3 Saw\cf0 .ar(freq *2 + 0.2.rand2, amp)\}),\
			\cf3 Mix\cf0 .arFill(2, \{\cf3 Saw\cf0 .ar(freq *4+ 0.2.rand2, amp)\})\
			]),\
			\cf3 EnvGen\cf0 .kr(env,gate)*filterfreq,\
			rez);\
     \cf3 Out\cf0 .ar([0,1],x * \cf3 EnvGen\cf0 .kr(e, gate, doneAction: 2))\
\
\}).send(s);\
\
\cf3 SynthDef\cf0 (\cf6 "strings"\cf0 ,\{ \cf3 arg\cf0  freq = 700, amp = 0.2, gate = 1;\
     \cf3 var\cf0  x,enve;\
	enve = \cf3 Env\cf0 .new([0, 0.1, 0.1, 0], [2, 0.1, 1], \cf7 'linear'\cf0 , 2);\
	x = \cf3 RLPF\cf0 .ar(\cf3 Mix\cf0 .ar([\
					\cf3 Mix\cf0 .arFill(2, \{\cf3 Saw\cf0 .ar(freq +2.rand2,0.6)\}),\
					\cf3 Mix\cf0 .arFill(2, \{\cf3 Saw\cf0 .ar(freq *0.5 + 2.rand2,0.6)\})\
			]),\
			6000,1);\
     \cf3 Out\cf0 .ar([0,1],x * \cf3 EnvGen\cf0 .kr(enve, gate, doneAction: 2))\
\
\}).send(s);\
\
)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs20 \cf0 then...\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs18 \cf0 (\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 var\cf0  keys, cutspec, cutbus, rezspec, rezbus, lfospec, lfobus;\
keys = \cf3 Array\cf0 .newClear(128);\
\
\cf3 MIDIClient\cf0 .init;\
\cf3 MIDIIn\cf0 .connect(0, \cf3 MIDIClient\cf0 .sources.at(0));\
\
g = \cf3 Group\cf0 .new;\
\
cutspec = \cf3 ControlSpec\cf0 (100,10000,\cf7 \\linear\cf0 ,0.001);\
cutbus = \cf3 Bus\cf0 .new(\cf7 \\control\cf0 ,1,1,s);\
cutbus.value = 10000;\
\
rezspec = \cf3 ControlSpec\cf0 (1,0,\cf7 \\linear\cf0 ,0.001);\
rezbus = \cf3 Bus\cf0 .new(\cf7 \\control\cf0 ,2,1,s);\
rezbus.value = 1.0;\
\
lfospec = \cf3 ControlSpec\cf0 (0,50,\cf7 \\linear\cf0 ,0.001);\
lfobus = \cf3 Bus\cf0 .new(\cf7 \\control\cf0 ,3,1,s);\
\
\cf3 MIDIIn\cf0 .control = \{\cf3 arg\cf0  src, chan, num, val;\
			if(num == 1,\{\
				rezbus.value = rezspec.map(val/127.0);\
			\});\
			if(num == 7,\{\
				lfobus.value = lfospec.map(val/127.0).postln;\
			\});\
			\};\
\cf3 MIDIIn\cf0 .bend = \{\cf3 arg\cf0  src, chan, val;\
			cutbus.value = cutspec.map(val/16383.0);\
			\};\
\
\cf3 MIDIIn\cf0 .noteOn = \{\cf3 arg\cf0  src, chan, num, vel;\
	\cf3 var\cf0  node;\
	if(num < 60, \{\
		node = \cf3 Synth\cf0 .tail(g, \cf6 "funk"\cf0 , [\cf7 \\freq\cf0 , num.midicps, \cf7 \\amp\cf0 , vel/255]);\
		node.map(\cf6 "cutoff"\cf0 ,1,\cf6 "rez"\cf0 ,2,\cf6 "lfospeed"\cf0 ,3);\
\cf4 //		node = Synth.basicNew("funk",s);\cf0 \
\cf4 //		s.sendBundle(nil,\cf0 \
\cf4 //			node.addToTailMsg(g,[\\freq, num.midicps, \\amp, vel/255]),\cf0 \
\cf4 //			node.mapMsg("cutoff",1,"rez",2,"lfospeed",3)\cf0 \
\cf4 //		);\cf0 \
		keys.put(num, node)\
	\},\{ \
		node = \cf3 Synth\cf0 .tail(g, \cf6 "strings"\cf0 , [\cf7 \\freq\cf0 , num.midicps, \cf7 \\amp\cf0 , vel/255]);\
		keys.put(num, node)\
	\});\
\};\
\
\cf3 MIDIIn\cf0 .noteOff = \{\cf3 arg\cf0  src, chan, num, vel;\
    \cf3 var\cf0  node;\
    node = keys.at(num);\
    if (node.notNil, \{\
        keys.put(num, \cf3 nil\cf0 );\
        s.sendMsg(\cf6 "/n_set"\cf0 , node.nodeID, \cf6 "gate"\cf0 , 0);\
        \cf4 // or node.release\cf0 \
        \cf4 // then free it ... or get the NodeWatcher to do it\cf0 \
    \});\
\};\
\
)\
\
\
\
\
\
\
\
\
\
\
}