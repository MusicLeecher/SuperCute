{\rtf1\mac\ansicpg10000\cocoartf824\cocoasubrtf230
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue191;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 NodeWatcher		
\fs24 notify sc-lang side node objects of their server sided state
\fs36 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs26 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs24 \cf0 Node instances (Synths and Groups) can be registered with the NodeWatcher.  \
It watches for server node status messages:
\fs26 \
	
\f2\fs18 	\
		n_go \
		n_end\
		n_off\
		n_on\
		
\f1\fs26 \

\fs24 \
and sets the isPlaying and isRunning variables on the Node instance accordingly.  A Node that ends is unregistered at that time.
\fs26 \
\

\fs24 In some cases this can be an invaluable service.  The use of an independant object to maintain the state keeps the implementation of the Node classes simple. \
Note that server notification should be on. (this is default. see: aServer.notify)
\f2\fs18 \
\
	
\f0\b\fs24 the most common use: \
		
\f1\b0 NodeWatcher.register(aNode);
\f2\fs18 \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs26 \cf0 	*new(server)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 		create a new instance listening to the server's address\
\
	
\f0\b *newFrom(server)
\f1\b0 \
		 create a new instance listening to the server's address\
		 if there is one present already return that one\
	\
	
\f0\b *register(aNode, assumePlaying)
\f1\b0 \
		aNode can be a Group or a Synth.\
		the NodeWatcher is created internally\
		
\f0\b assumePlaying: 
\f1\b0 if true, the node's 
\f0\b isPlaying
\f1\b0  field is set to true\
	\
	
\f0\b *unregister(aNode)
\f1\b0 \
		remove the node from the list of nodes.\
		this happens also when a node is freed.\
	
\f2\fs18 \
	
\f0\b\fs26 start
\f1\b0 \
		add the OSCresponderNode to listen to the address\
	\
	
\f0\b stop
\f1\b0 \
		remove the OSCresponderNode to stop listen to the address 
\f2\fs18 \
	\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // example:\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
	(\
	b = s.makeBundle(\cf3 false\cf0 , \{\
		a = \cf3 Group\cf0 .new(s); \cf2 //create a node object\cf0 \
		\cf3 NodeWatcher\cf0 .register(a); \cf2 // register before creating on the server\cf0 \
	\});\
	)\
	a.isPlaying;\
	s.listSendBundle(nil, b); \cf2 //start the node on the server\cf0 \
	a.isPlaying;\
	a.isRunning;\
	a.run(\cf3 false\cf0 );\
	a.isRunning;\
	s.freeAll; \cf2 //free all nodes\cf0 \
	a.isPlaying;\
	a.isRunning;\
	\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 DebugNodeWatcher\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs18 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs26 \cf0 	for debugging, it can be useful to see every node start and end\
	it doesn't require registration, reacts to each message.
\f2\fs18 \

\f1\fs26 \
	
\f2\fs18 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // example:\cf0 \
	n = \cf3 DebugNodeWatcher\cf0 (s);\
	n.start;\
	x = \cf3 Group\cf0 (s);\
	x.run(\cf3 false\cf0 );\
	x.free;\
	n.stop;\
	\
	\
\
}