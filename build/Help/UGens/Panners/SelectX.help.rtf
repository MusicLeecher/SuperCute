{\rtf1\mac\ansicpg10000\cocoartf824\cocoasubrtf410
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fnil\fcharset77 Monaco;\f2\fswiss\fcharset77 Helvetica;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red191\green0\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 SelectX				
\fs24 mix one output from many sources
\f1\b0\fs18 \cf2 \
\

\f2\fs24 \cf0 \
superclass: Object\
\
The output is mixed from an array of inputs, linearly interpolating from two adjacent channels. \

\f1\fs18 \cf2 \

\f0\b\fs24 \cf0 	SelectX.ar(which, array)\
	SelectX.kr(which, array)\

\f1\b0\fs18 \cf2 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 // examples \cf0 \
(\
\{\
	\cf2 var\cf0  a;\
	a = [\
			\cf2 SinOsc\cf0 .ar,\
			\cf2 Saw\cf0 .ar(300),\
			\cf2 Pulse\cf0 .ar(230)\
		];\
	\
	\cf2 SelectX\cf0 .ar(\cf2 MouseX.kr(0, 1) * a.size\cf0 , a) * 0.2\
\}.play;\
)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 	\

\f2\fs24 \cf0 Note: all the ugens are continously running. This may not be the most efficient way if each input is  cpu-expensive. The array is fixed at the time of writing the SynthDef, and the whole array is embedded in the SynthDef file itself.  For small arrays this is more efficient than reading from a buffer.\

\f1\fs18 \cf2 \
\

\f2\fs24 \cf0 (by adc)}