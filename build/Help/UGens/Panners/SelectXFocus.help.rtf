{\rtf1\mac\ansicpg10000\cocoartf824\cocoasubrtf410
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fnil\fcharset77 Monaco;\f2\fswiss\fcharset77 Helvetica;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red191\green0\blue0;\red0\green0\blue0;
\red0\green0\blue191;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 SelectXFocus				
\fs24 mix one output from many sources
\f1\b0\fs18 \cf2 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 \
superclass: Object\
\
The output is mixed from an array of inputs, linearly interpolating from a number of adjacent channels.\
A focus argument allows to control how many adjacent sources are mixed. (by adc)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 	SelectXFocus.ar(which, array, focus)\
	SelectXFocus.kr(which, array, focus)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs18 \cf2 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 // examples \cf0 \
(\
\{\
	\cf2 var\cf0  a;\
	a = [\
			\cf2 Saw\cf0 .ar(\cf2 LFSaw\cf0 .kr(3 * [1, 1.01], 0, 100, 230)),\
			\cf2 SinOsc\cf0 .ar,\
			\cf2 Pulse\cf0 .ar(\cf2 LFPulse\cf0 .kr(3 * [1, 1.02], 0, 0.4, 100, 230)),\
			\cf2 SinOsc\cf0 .ar(\cf2 SinOsc\cf0 .kr(4 * [1, 1.03], 0, 200, 300))\
		];\
	\
	\cf2 SelectXFocus\cf0 .ar(\cf2 MouseX\cf0 .kr(0, 1) * a.size, a, \cf2 MouseY\cf0 .kr(0, a.size)) * 0.2\
\}.play;\
)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 Note: all the ugens are continously running. This may not be the most efficient way if each input is  cpu-expensive. The array is fixed at the time of writing the SynthDef, and the whole array is embedded in the SynthDef file itself.  For small arrays this is more efficient than reading from a buffer.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 \
\
// radio tuner\
// (jrh) (cc 2006)\cf0 \
(\cf4 \
\{\
	\cf5 var\cf4  a, n, mx, my, mwrap;\
	n = 8;\
	mx = \cf5 MouseX\cf4 .kr(0, 1, 0, 0.1);\
	my = \cf5 MouseY\cf4 .kr;\
	mwrap = \{ \cf5 |pmin, pmax, min, max|\cf4  sin(mx * \cf5 ExpRand\cf4 (pmin, pmax)) + 1 * 0.5 * \cf5 ExpRand\cf4 (min, max) \};\
	a = \{\
		\cf5 var\cf4  freq, fmul, phase;\
		freq = mwrap.(10, 40, 200, 5000) + \cf5 ExpRand\cf4 (200, 3000);\
		fmul = \cf5 LFNoise0\cf4 .kr(\cf5 ExpRand\cf4 (0.1, 8)).round(1/6).exprange(1, \cf5 Rand\cf4 (1, 1.2));\
		phase = \cf5 LFNoise2\cf4 .ar(mwrap.(1, 20, 10, 1000), \cf5 Rand\cf4 (2, 5));\
		\cf5 SinOsc\cf4 .ar(freq * fmul, phase)\
	\} ! n;\
	a = a.add(\
		\cf5 SinOsc\cf4 .ar(\cf5 LFDNoise0\cf4 .kr(11, \cf5 SetResetFF\cf4 .kr(*\cf5 Dust\cf4 .kr([1, 2] * 0.3))).range(0, 700) + 220)\
	);\
	\cf5 SelectXFocus\cf4 .ar(mx * n, a, my * n) * 0.2 + \cf5 OnePole\cf4 .ar(\cf5 PinkNoise\cf4 .ar(0.5 ! 2), 0.4) \
	* \cf5 Line\cf4 .kr(0, 1, 3);\
\}.play;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 )\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 // jimmy played harmonica in the pub where I was born\cf0 \
\cf3 // (hh) (jrh) (cc 2006)\cf0 \
(\
\{\
	\cf2 var\cf0  blas, zieh, mx, my, trig, which, amp, u, schnauf;\
	\cf2 var\cf0  del = 9, det = 0.1;\
	schnauf = 0.3;\
	mx = \cf2 MouseX\cf0 .kr;\
	my = \cf2 MouseY\cf0 .kr(0.1, 2, 1);\
	\
	blas = [0, 12, 24] +.x [60, 64, 67] ++ [60+36];\
	zieh = [62, 67, 71,   74, 77, 81, 83,   86, 89, 93];\
\
	trig = \cf2 Dust\cf0 .kr(1);\
	which = \cf2 ToggleFF\cf0 .kr(\cf2 TDelay\cf0 .kr(trig, schnauf));\
	amp = \cf2 EnvGen\cf0 .kr(\cf2 Env\cf0 ([1, 0, 1], [schnauf, schnauf]), trig);\
	blas = \cf2 Select\cf0 .kr(which, [blas, zieh]);\
	u = \cf2 SelectXFocus\cf0 .ar(\
		mx * blas.size,	\
		blas.collect \{\cf2 |f|\cf0 \
			\cf2 Pulse\cf0 .ar((\cf2 Rand\cf0 (-0.04, 0.09) + f).midicps * 0.5, \cf2 0.48\cf0  + \cf2 LFNoise1\cf0 .kr(0.06, 0.1), 0.2)\
		\},\
		my\
	) * \cf2 Slope\cf0 .kr(mx + my).abs.lag2(2) * amp;\
	u = \cf2 Pan2\cf0 .ar(\cf2 OnePole\cf0 .ar(u, -0.3), mx * 2 - 1);\
	\cf2 DelayL\cf0 .ar(\cf2 BPF\cf0 .ar(u * 2, 1500, 0.3), del + det, \cf2 LFNoise2\cf0 .kr(0.2, det, del)) + u\
\}.play;\
);\
\
\
}