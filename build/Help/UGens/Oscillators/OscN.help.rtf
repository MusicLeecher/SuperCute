{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue0;\red0\green0\blue191;
\red96\green96\blue96;\red0\green115\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 OscN			noninterpolating wavetable oscillator\
\

\fs24 OscN.ar(table, freq, phase, mul, add)\

\f1\b0 \
Noninterpolating wavetable lookup oscillator with frequency and phase modulation inputs.\
It is usually better to use the interpolating oscillator.\

\f0\b buffer
\f1\b0  - buffer index.  the buffer size must be a power of 2.  The buffer should NOT be filled using Wavetable format (b_gen commands should set wavetable flag to false.  Raw signals (not converted with asWavetable) can be saved to disk and loaded into the buffer.\

\f0\b freq
\f1\b0  - frequency in Hertz\

\f0\b phase
\f1\b0  - phase offset or modulator in radians\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf2 // compare examples below with interpolating Osc examples.\
\cf3 \
(\
s = \cf4 Server\cf3 .local;\
b = \cf4 Buffer\cf3 .new(s,512,1);\
b.sine1(1.0/[1,2,3,4,5,6],\cf4 true\cf3 ,\cf4 false\cf3 ,\cf4 true\cf3 );\
\
\cf4 SynthDef\cf3 (\cf5 "help-OscN"\cf3 ,\{ \cf4 arg\cf3  out=0,bufnum=0;\
	\cf4 Out\cf3 .ar(out, \
		\cf4 OscN\cf3 .ar(bufnum, 500, 0, 0.5)\
	)\
\}).play(s,[0,0,1,b.bufnum]);\
\
)\
\
\
\
\
(\
\cf2 // noninterpolating - there are noticeable artifacts\
// modulate freq\
\cf3 \
s = \cf4 Server\cf3 .local;\
b = \cf4 Buffer\cf3 .new(s,512,1);\
b.sine1(1.0/[1,2,3,4,5,6].squared,\cf4 true\cf3 ,\cf4 false\cf3 ,\cf4 true\cf3 );\
\
\cf4 SynthDef\cf3 (\cf5 "help-OscN"\cf3 ,\{ \cf4 arg\cf3  out=0,bufnum=0;\
	\cf4 Out\cf3 .ar(out, \
		\cf4 OscN\cf3 .ar(bufnum, \cf4 XLine\cf3 .kr(2000,200), 0, 0.5)\
	)\
\}).play(s,[\cf6 \\out\cf3 ,0,\cf6 \\bufnum\cf3 ,b.bufnum]);\
\
)\
\
( \cf2 // sounds very different than the Osc example\
\cf3 s = \cf4 Server\cf3 .local;\
b = \cf4 Buffer\cf3 .new(s, 512, 1);\
b.sine1([1.0], \cf4 true\cf3 , \cf4 true\cf3 , \cf4 true\cf3 );\
\
\cf4 SynthDef\cf3 (\cf5 "help-OscN"\cf3 ,\{ \cf4 arg\cf3  out=0,bufnum=0;\
	\cf4 Out\cf3 .ar(out,\
		\cf4 OscN\cf3 .ar(bufnum, \
			\cf4 OscN\cf3 .ar(bufnum,\
				\cf4 XLine\cf3 .kr(1,1000,9),\
				0,\
				200,\
				800), \
			0, \
			0.25)\
	)\
\}).play(s,[\cf6 \\out\cf3 , 0, \cf6 \\bufnum\cf3 , b.bufnum]);\
\
)\
\
(\cf2 // modulate phase\
\cf3 s = \cf4 Server\cf3 .local;\
b = \cf4 Buffer\cf3 .new(s, 512, 1);\
b.sine1([1.0], \cf4 true\cf3 , \cf4 true\cf3 , \cf4 true\cf3 );\
\
\cf4 SynthDef\cf3 (\cf5 "help-OscN"\cf3 ,\{ \cf4 arg\cf3  out=0,bufnum=0;\
	\cf4 Out\cf3 .ar(out,\
		\cf4 OscN\cf3 .ar(bufnum, \
				800, \
				\cf4 OscN\cf3 .ar(bufnum,\
						\cf4 XLine\cf3 .kr(20,8000,10),\
						0,\
						2pi), \
				0.25)\
	)\
\}).play(s,[\cf6 \\out\cf3 , 0, \cf6 \\bufnum\cf3 , b.bufnum]);\
)\
\
\
\
(\cf2 // change the buffer while its playing\
\cf3 s = \cf4 Server\cf3 .local;\
b = \cf4 Buffer\cf3 .new(s, 4096, 1);\
b.sine1(1.0/[1,2,3,4,5,6], \cf4 true\cf3 , \cf4 true\cf3 , \cf4 true\cf3 );\
\
\cf4 SynthDef\cf3 (\cf5 "help-OscN"\cf3 ,\{ \cf4 arg\cf3  out=0,bufnum=0;\
	\cf4 Out\cf3 .ar(out,\
		\cf4 OscN\cf3 .ar(bufnum, [80,80.2], 0, 0.2)\
	)\
\}).play(s,[\cf6 \\out\cf3 , 0, \cf6 \\bufnum\cf3 , b.bufnum]);\
)\
\
(\
\cf4 Routine\cf3 (\{\
	\cf4 var\cf3  n = 32;\
	50.do(\{\
		b.sine1(\cf4 Array\cf3 .rand(n,0,1).cubed, \cf4 true\cf3 , \cf4 true\cf3 , \cf4 true\cf3 );\
		0.25.wait;\
	\});\
\}).play;\
)\
\
}