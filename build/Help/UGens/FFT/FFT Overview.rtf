{\rtf1\mac\ansicpg10000\cocoartf824\cocoasubrtf410
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
\f3\fswiss\fcharset77 Helvetica-Oblique;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red96\green96\blue96;\red191\green0\blue0;
\red0\green115\blue0;\red0\green0\blue0;\red0\green0\blue191;\red0\green25\blue183;\red96\green96\blue96;
\red191\green0\blue0;\red0\green115\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 FFT Overview
\f1\b0\fs24 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 FFT and IFFT
\f1\b0\fs24 \
\
SuperCollider implements a number of UGens supporting FFT based processing. The most basic of these are 
\f0\b [\ul FFT\ulnone ]
\f1\b0  and 
\f0\b [\ul IFFT\ulnone ] 
\f1\b0 which convert data between the time and frequency domains:\
\
	
\f0\b FFT(buffer, input)\
	IFFT(buffer)
\f1\b0 \
\
FFT stores spectral data in a local buffer (see 
\f0\b [\ul Buffer\ulnone ]
\f1\b0 ) in the following order: DC, nyquist, real 1f, imag 1f, real 2f, imag 2f, ... real (N-1)f, imag (N-1)f, where f is the frequency corresponding to the window size, and N is the window size / 2.\
\
The buffer's size must correspond to a power of 2. The window size is equivalent to the buffer size, and the window overlap is fixed at 2. Both FFT and IFFT use a Welch window, the combination of which (i.e. Welch
\fs16 \super 2
\fs24 \nosupersub ) is a Hanning window.\
\

\f0\b\fs28 Phase Vocoder UGens and Spectral Processing
\f1\b0\fs24 \
\
In between an FFT and an IFFT one can chain together a number of Phase Vocoder UGens (i.e. 'PV_...') to manipulate blocks of spectral data before reconversion. The process of buffering the appropriate amount of audio, windowing, conversion, overlap-add, etc. is handled for you automatically.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 	s = \cf2 Server\cf0 .local.boot;\
	b = \cf2 Buffer.alloc\cf0 (s,2048,1);\
	\
	(\
	\{ \cf2 var\cf0  in, chain;\
		in = \cf2 WhiteNoise\cf0 .ar(0.8);\
		chain = \cf2 FFT\cf0 (b.bufnum, in);\
		chain = \cf2 PV_RandComb\cf0 (chain, 0.95, \cf2 Impulse\cf0 .kr(0.4)); \
		\cf2 IFFT\cf0 (chain);\
	\}.play(s);\
	)\
	b.free;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
PV Ugens write their output data 
\f3\i in place
\f1\i0 , i.e. back into the same buffer from which they read. PV UGens which require two buffers write their data into the first buffer, usually called 'bufferA'.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \
	(\
	b = \cf2 Buffer\cf0 .alloc(s,2048,1);\
	c = \cf2 Buffer\cf0 .alloc(s,2048,1);\
	d = \cf2 Buffer\cf0 .read(s,\cf3 "sounds/a11wlk01.wav"\cf0 );\
	)\
	\
	(\
	\{ \cf2 var\cf0  inA, chainA, inB, chainB, chain;\
		inA = \cf2 LFSaw\cf0 .ar([100, 150], 0, 0.2);\
		inB = \cf2 PlayBuf\cf0 .ar(1, d.bufnum, \cf2 BufRateScale\cf0 .kr(d.bufnum), loop: 1);\
		chainA = \cf2 FFT\cf0 (b.bufnum, inA);\
		chainB = \cf2 FFT\cf0 (c.bufnum, inB);\
		chain = \cf2 PV_MagMul\cf0 (chainA, chainB); \cf4 // writes into bufferA\cf0 \
		0.1 * \cf2 IFFT\cf0 (chain);\
	\}.play(s);\
	)\
	[b, c, d].do(_.free);
\f1\fs24 \
\
Because each PV UGen overwrites the output of the previous one, it is necessary to copy the data to an additional buffer at the desired point in the chain in order to do parallel processing of input without using multiple FFT UGens. 
\f0\b [\ul PV_Copy\ulnone ]
\f1\b0  allows for this.\
\

\f2\fs18 	(\
	b = \cf2 Buffer\cf0 .alloc(s,2048,1);\
	c = \cf2 Buffer\cf0 .alloc(s,2048,1);\
	)\
	\
	\cf4 //// proof of concept\cf0 \
	(\
	x = \{ \cf2 var\cf0  inA, chainA, inB, chainB, chain;\
		inA = \cf2 LFClipNoise\cf0 .ar(100);\
		chainA = \cf2 FFT\cf0 (b.bufnum, inA);\
		chainB = \cf2 PV_Copy\cf0 (chainA, c.bufnum);  \
		\cf2 IFFT\cf0 (chainA) - \cf2 IFFT\cf0 (chainB); \cf4 // cancels to zero so silent!\cf0 \
	\}.play(s);\
	)\
	x.free;\
\cf4 	// IFFTed frames contain the same windowed output data\cf0 \
	b.plot(\cf5 \\b\cf0 , \cf2 Rect\cf0 (200, 430, 700, 300)); c.plot(\cf5 \\c\cf0 , \cf2 Rect\cf0 (200, 100, 700, 300));\
	[b, c].do(_.free);\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
Note that PV UGens convert as needed between cartesian (complex) and polar representations, therefore when using multiple PV UGens it may be impossible to know in which form the values will be at any given time. FFT produces complex output (see above), so while the following produces a reliable magnitude plot:\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab160\ql\qnatural

\f2\fs18 \cf0 	b = \cf2 Buffer\cf0 .alloc(s,1024);\
	a = \{ \cf2 FFT\cf0 (b.bufnum, \cf2 LFSaw\cf0 .ar(4000)); 0.0 \}.play;\
	(\
	b.getn(0, 1024, \{ \cf2 arg\cf0  buf;\
		\cf2 var\cf0  z, x;\
		z = buf.clump(2).flop;\
		z = [\cf2 Signal\cf0 .newFrom(z[0]), \cf2 Signal\cf0 .newFrom(z[1])];\
		x = \cf2 Complex\cf0 (z[0], z[1]);\
		\{x.magnitude.plot\}.defer\
	\})\
	)\
	a.free; b.free;
\f1 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs24 \cf0 \
any Synth using PV UGens might not.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 Multichannel Expansion with FFT UGens
\f1\b0\fs24 \
\
\pard\pardeftab720\ql\qnatural
\cf0 Care must be taken when using multichannel expansion with FFT UGens, as they require separate buffers. Code such as this can be deceptive:\
\
\pard\pardeftab720\ql\qnatural

\f2\fs18 \cf6 chain = \cf7 FFT\cf6 (bufnum, \cf0 \{\cf2 WhiteNoise\cf0 .ar(0.2)\}.dup\cf6 );
\f1\fs24 \cf0 \
\
The above may seem to work, but does not. It does result in two FFT UGens, but as they both write to the same buffer, the second simply overwrites the data from the first, thus wasting CPU and accomplishing nothing.\
\
When using multichannel expansion with FFT UGens it is necessary to ensure that each one writes to a different buffer. Here's an example of one way to do this:\
\
\pard\pardeftab720\ql\qnatural

\f2\fs18 \cf0 b = \{\cf8 Buffer\cf0 .alloc(s,2048,1)\}.dup;
\f1\fs24 \

\f2\fs18 \
(
\f1\fs24 \cf6 \
\pard\pardeftab720\ql\qnatural

\f2\fs18 \cf7 SynthDef\cf6 (\cf9 "help-multichannel FFT"\cf6 , \{ \cf7 arg\cf6  out=0, bufnum= #[0, 1]; \cf10 // bufnum is an array
\f1\fs24 \cf6 \
	
\f2\fs18 \cf7 var\cf6  in, chain;
\f1\fs24 \
	
\f2\fs18 in = [\cf7 SinOsc\cf6 .ar(0.2), \cf7 WhiteNoise\cf6 .ar(0.2)];
\f1\fs24 \
	
\f2\fs18 chain = \cf7 FFT\cf6 (bufnum, in); \cf10 // each FFT has a different buffer\cf6 \
	\cf10 // now we can multichannel expand as normal
\f1\fs24 \cf6 \
	
\f2\fs18 chain = \cf7 PV_BrickWall\cf6 (chain, \cf7 SinOsc\cf6 .kr(0.1));
\f1\fs24 \
	
\f2\fs18 \cf7 Out\cf6 .ar(out, \cf7 IFFT\cf6 (chain));
\f1\fs24 \

\f2\fs18 \}).play(s,[\cf11 \\out\cf6 , 0, \cf11 \\bufnum\cf6 , b.collect(\cf7 _\cf6 .bufnum)]);
\f1\fs24 \
\pard\pardeftab720\ql\qnatural

\f2\fs18 \cf0 )
\f1\fs24 \
\
Note that dup on a UGen just makes a reference to that UGen, because UGen defines -copy to simply return the receiver. (See 
\f0\b [\ul UGen\ulnone ]
\f1\b0  for more detail.)\
\

\f2\fs18 a = SinOsc.ar;
\f1\fs24 \

\f2\fs18 a.dup[1] === a
\f1\fs24 \

\f2\fs18 \
true
\f1\fs24 \
\
Code like 
\f2\fs18 \cf7 IFFT\cf6 (chain).dup
\f1\fs24 \cf0  is found throughout the PV help files , and is just a convenient way to copy a mono signal to stereo, without further computation.\
\
See also 
\f0\b [\ul MultiChannel\ulnone ]
\f1\b0 .\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 PV and FFT UGens in the Standard Library
\f1\b0\fs24 \
\
The following PV UGens are included in the standard SC distribution:\
\pard\tx560\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl264\slmult1\ql\qnatural
\cf0 \
	[\ul FFT\ulnone ]	Fast Fourier Transform\
	[\ul IFFT\ulnone ]	Inverse Fast Fourier Transform\
	[\ul PV_Add\ulnone ]	complex addition\
	[\ul PV_BinScramble\ulnone ]	scramble bins\
	[\ul PV_BinShift\ulnone ]	shift and stretch bin position\
	[\ul PV_BinWipe\ulnone ]	combine low and high bins from two inputs\
	[\ul PV_BrickWall\ulnone ]	zero bins\
	[\ul PV_ConformalMap\ulnone ]	complex plane attack \
	[\ul PV_Copy\ulnone ]	copy an FFT buffer\
	[\ul PV_CopyPhase\ulnone ]	copy magnitudes and phases\
	[\ul PV_Diffuser\ulnone ]	random phase shifting\
	[\ul PV_HainsworthFoote\ulnone ]\
	[\ul PV_JensenAndersen\ulnone ]\
	[\ul PV_LocalMax\ulnone ]	pass bins which are a local maximum\
	[\ul PV_MagAbove\ulnone ]	pass bins above a threshold\
	[\ul PV_MagBelow\ulnone ]	pass bins below a threshold\
	[\ul PV_MagClip\ulnone ]	clip bins to a threshold\
	[\ul PV_MagFreeze\ulnone ]	freeze magnitudes\
	[\ul PV_MagMul\ulnone ]	multiply magnitudes\
	[\ul PV_MagNoise\ulnone ]	multiply magnitudes by noise\
	[\ul PV_MagShift\ulnone ]	shift and stretch magnitude bin position\
	[\ul PV_MagSmear\ulnone ]	average magnitudes across bins\
	[\ul PV_MagSquared\ulnone ]	square magnitudes\
	[\ul PV_Max\ulnone ]	maximum magnitude\
	[\ul PV_Min\ulnone ]	minimum magnitude\
	[\ul PV_Mul\ulnone ]	complex multiply\
	[\ul PV_PhaseShift\ulnone ]	shift phase of all bins\
	[\ul PV_PhaseShift270\ulnone ]	shift phase by 270 degrees\
	[\ul PV_PhaseShift90\ulnone ]	shift phase by 90 degrees\
	[\ul PV_RandComb\ulnone ]	pass random bins\
	[\ul PV_RandWipe\ulnone ]	crossfade in random bin order\
	[\ul PV_RectComb\ulnone ]	make gaps in spectrum\
	[\ul PV_RectComb2\ulnone ]	make gaps in spectrum\
\
}