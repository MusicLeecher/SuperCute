{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red0\green0\blue191;\red191\green0\blue0;
}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 \
Pitch						autocorrelation pitch follower\

\fs24 \
#freq, hasFreq = Pitch.kr(bufnum, in, initFreq, minFreq, maxFreq, execFreq,\
					maxBinsPerOctave, median, ampThreshold, \
					peakThreshold, downSample)\

\f1\b0 			\
This is a pretty robust pitch follower, far better than ZeroCrossing, but more costly of CPU. \
For most purposes the default settings can be used and only 
\f0\b in
\f1\b0  needs to be supplied. \
Pitch returns two values (via an Array of OutputProxys, see the OutputProxy help file), \
a 
\f0\b freq
\f1\b0  which is the pitch estimate and 
\f0\b hasFreq
\f1\b0 , which tells whether a pitch was found. \
Some vowels are still problematic, for instance a wide open mouth sound somewhere \
between a low pitched short 'a'  sound as in 'sat', and long 'i' sound as in 'fire', contains \
enough overtone energy to confuse the algorithm. \
\

\f0\b Example:
\f1\b0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf2 (\
s = \cf3 Server\cf2 .local;\
b = \cf3 Buffer\cf2 .alloc(s,10000,1);\
)\
(\
\cf3 Synth\cf2 .play(\{\
	\cf3 var\cf2  in, amp, freq, hasFreq, out;\
	in = \cf3 Mix\cf2 .ar(\cf3 AudioIn\cf2 .ar([1,2]));\
	amp = \cf3 Amplitude\cf2 .kr(in, mul: 0.4);\
	# freq, hasFreq = \cf3 Pitch\cf2 .kr(b.bufnum, in);\
	out = \cf3 Mix\cf2 .ar( \cf3 LFTri\cf2 .ar(freq * [0.5, 1, 2]) ) * amp;\
	6.do(\{ \
		out = \cf3 AllpassN\cf2 .ar(out, 0.040, [0.040.rand,0.040.rand], 2) \
	\});\
	out\
\})\
)
\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 \
The Buffer needs to be at least\
	(sampleRate / minFreq) << 1\
so for the default settings:\
	(44100.0 / 60).asInteger << 1\

\f0\b 1470 ?\
\
How it works:\

\f1\b0 The pitch follower executes periodically at the rate specified by 
\f0\b execFreq
\f1\b0 . \
First it detects whether the input peak to peak amplitude is above the 
\f0\b ampThreshold
\f1\b0 . \
If it is not then no pitch estimation is performed, 
\f0\b hasFreq
\f1\b0  is set to zero and 
\f0\b freq
\f1\b0  is held\
at its previous value.\
It performs an autocorrelation on the input and  looks for the first peak after the peak around\
the lag of zero that is above 
\f0\b peakThreshold
\f1\b0  times the amplitude of the peak at lag zero.\
Using a peakThreshold of one half does a pretty good job of eliminating overtones, and\
finding the first peak above that threshold rather than the absolute maximum peak does a \
good job of eliminating estimates that are actually multiple periods of the wave. \
The autocorrelation is done coarsely at first using a maximum of 
\f0\b maxBinsPerOctave
\f1\b0 \
lags until the peak is located. Then a fine resolution search is performed until the peak is found.\
(Note that maxBinsPerOctave does NOT affect the final pitch resolution, a fine resolution\
search is always performed. Setting maxBinsPerOctave larger will cause the coarse\
search to take longer, and setting it smaller will cause the fine search to take longer.)\
The three values around the peak are used to find a fractional lag value for the pitch.\
If the pitch frequency is higher than 
\f0\b maxFreq
\f1\b0 , or if no peak is found above 
\f0\b minFreq
\f1\b0 , \
then 
\f0\b hasFreq
\f1\b0  is set to zero and 
\f0\b freq
\f1\b0  is held at its previous value.\
It is possible to put a median filter of length 
\f0\b median
\f1\b0  on the output estimation so that outliers and jitter\
can be eliminated. This will however add latency to the pitch estimation for new pitches, because the \
median filter will have to become half filled with new values before the new one becomes the\
median value. If median is set to one then that is equivalent to no filter, which is the default.\
When an in range peak is found, it is inserted into the median filter, a new pitch is read out of the\
 median filter and output as 
\f0\b freq
\f1\b0 , and 
\f0\b hasFreq
\f1\b0  is set to one.\
It is possible to down sample the input signal by an integer factor 
\f0\b downSample 
\f1\b0 in order to reduce CPU \
overhead. This will also reduce the pitch resolution.\
Until Pitch finds a pitch for the first time, it will output 
\f0\b initFreq
\f1\b0 .\
None of these settings are time variable.\
\

\f0\b Default Argument values:\

\f1\b0 	initFreq = 440.0\
	minFreq = 60.0\
	maxFreq = 4000.0\
	execFreq = 100.0\
	maxBinsPerOctave = 16\
	median = 1\
	ampThreshold = 0.01\
	peakThreshold = 0.5\
	downSample = 1\
\cf2 \
\cf4 /*\
The following shows a similar autocorrelation process that may be helpful in visualizing the algorithm.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf4 (\
// autocorrelation pitch following\
// This shows how the autocorrelator pitch follower, Pitch, works.\
// Turn off the speaker the volume.\
var fftsize = 2048;\
Synth.scope(\{\
	var cosineTable, src, fft, ifft, wind, view, scopeBuf1, scopeBuf2, scope;\
	var filename, sound, signal, z, w;\
		\
	cosineTable = Signal.fftCosTable(fftsize);		// make cosine table required for FFT\
	\
	src = Mix.ar(AudioIn.ar([1,2]));	 // input wave\
\
	fft =  FFT.ar(fftsize, 0, cosineTable, nil, nil, src, 0.0);\
	\
	z = fft * fft.conjugate; // multiply by complex conjugate\
	\
	ifft = IFFT.ar(fftsize, 0, cosineTable, nil, nil, z.real, z.imag);\
\
	w = Normalizer.ar(ifft.real, 1, 2 * fftsize/44100); // Normalize for ease of viewing\
	\
	p = w.thresh(0.5);	// Pitch looks for the first peak greater than 0.5 * the zero lag value\
\
	[\
		src, 	// the input signal\
		w, 	// the autocorrelation\
		p	// the thresholded autocorrelation\
	]\
\}, fftsize/Synth.sampleRate);\
)\
*/\cf2 \
}