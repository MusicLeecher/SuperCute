{\rtf1\mac\ansicpg10000\cocoartf824\cocoasubrtf410
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue191;\red96\green96\blue96;
\red0\green115\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 FreeSelfWhenDone			
\fs26 free the enclosing synth when a UGen is finished
\fs36 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs24 \cf0 FreeSelfWhenDone.kr(src)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 \
Some UGens, such as PlayBuf, RecordBuf, Line, XLine, EnvGen, Linen, BufRd, BufWr, DbufRd, and the Buffer delay UGens set a 'done' flag when they are finished playing. FreeSelfWhenDone will free the enclosing synth when this flag is set to true. Note that many of these UGens have doneActions, which are another way of accomplishing the same thing. See 
\f0\b [\ul UGen-doneActions\ulnone ]
\f1\b0  for more detail. 
\f0\b N.B.
\f1\b0  One must be careful when using binary operations on UGens with done flags, as these will return a 
\f0\b [\ul BinaryOpUGen\ulnone ]
\f1\b0 , and thus prevent the done flag from being accessible. See example below.\
 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 src
\f1\b0  - the UGen to check for done.\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 s.boot;\
\
\cf2 // simple example\cf0 \
(\
\{ \cf3 var\cf0  env;\
env = \cf3 Line\cf0 .kr(0, 1, 1);\
\cf3 FreeSelfWhenDone\cf0 .kr(env); \cf2 // free synth at end of line\cf0 \
\cf3 SinOsc\cf0 .ar(200, 0, 0.5) * env \
\}.play;\
)\
\
\cf2 // the previous example works, because FreeSelfWhenDone operates on the Line\cf0 \
\cf2 // this version won't work\cf0 \
(\
\{ \cf3 var\cf0  env, output;\
env = \cf3 Line\cf0 .kr(0, 1, 1);\
output = \cf3 SinOsc\cf0 .ar(200, 0, 0.5) * env;\
output.postln; \cf2 // output is a BinaryOpUGen, which has no 'done' flag\cf0 \
\cf3 FreeSelfWhenDone\cf0 .kr(output); \cf2 // won't ever be done\cf0 \
output\
\}.play;\
)\
\
\cf2 // record for four seconds\cf0 \
b = \cf3 Buffer\cf0 .alloc(s, 44100 * 4.0, 1);\
(\
\cf3 SynthDef\cf0 (\cf4 "help-RecordBuf"\cf0 ,\{ \cf3 arg\cf0  out=0,bufnum=0;\
	\cf3 var\cf0  formant, recbuf;\
	formant = \cf3 Formant\cf0 .ar(\cf3 XLine\cf0 .kr(400,1000, 4), 2000, 800, 0.125);\
	recbuf = \cf3 RecordBuf\cf0 .ar(formant, bufnum, recLevel: \cf3 Line\cf0 .kr(1, 1), loop: 0);\
	\cf2 // The RecordBuf doesn't loop, so you can check it for 'done' status\cf0 \
	\cf3 FreeSelfWhenDone\cf0 .kr(recbuf);\
\}).play(s,[\cf5 \\out\cf0 , 0, \cf5 \\bufnum\cf0 , b.bufnum]);\
)\
\
\cf2 // play it back\cf0 \
(\
\cf3 SynthDef\cf0 (\cf4 "help-RecordBuf play"\cf0 ,\{ \cf3 arg\cf0  out=0,bufnum=0;\
	\cf3 var\cf0  playbuf;\
	playbuf = \cf3 PlayBuf\cf0 .ar(1,bufnum);\
	\cf3 FreeSelfWhenDone\cf0 .kr(playbuf); \cf2 // frees the synth when the PlayBuf is finished\cf0 \
	\cf3 Out\cf0 .ar(out, playbuf);\
\}).play(s,[\cf5 \\out\cf0 , 0, \cf5 \\bufnum\cf0 , b.bufnum]);\
)\
}