{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fnil\fcharset77 Monaco;\f2\fnil\fcharset77 LucidaGrande;
\f3\fnil\fcharset77 LucidaGrande-Bold;}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue191;\red96\green96\blue96;
}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 Functions and .scope messages\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs18 \cf0 \
An easy way to audition synthesis processes is to test them within a function. To do this, append a .scope or a .play message to a function. The .scope message, which works only with the internal server, displays a visual representation of a sound wave. \
\
\cf2 ////////////////////////////////////////////////////////////////////////////////////////////////////\cf0 \
\
Boot (turn on) the internal server \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 Server\cf0 .internal.boot;\
\
Run this example, and look at the scope window.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // test a synthesis process in a function\cf0 \
(\
	\{ \
	\cf3 	SinOsc\cf0 .ar([440.067, 441.013], 0, 1) \
		* \
		\cf3 SinOsc\cf0 .ar([111, 109], 0, 0.2) \
	\}.scope;\
)\
\
\cf2 ////////////////////////////////////////////////////////////////////////////////////////////////////\cf0 \
\
Code can be transfered from a test function into a synthdef. In the following example, the code from the function (above) is the second argument to the Out ugen.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 (\
SynthDef\cf0 (\cf4 "ringMod"\cf0 , \{ \
	\cf3 Out\cf0 .ar(\
		0,\
		\cf3 SinOsc\cf0 .ar([440.067, 441.013], 0, 1) \
		* \
		\cf3 SinOsc\cf0 .ar([111, 109], 0, 0.2) \
	)\
\}).load(s);\
)\
\
\cf3 Synth\cf0 (\cf4 "ringMod"\cf0 )\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 ////////////////////////////////////////////////////////////////////////////////////////////////////\cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 Multi-channel expansion\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs18 \cf0 \
Expand a ugen to two channels with an array in any of the argument (control) slots.\
\
\{ \cf3 Saw\cf0 .ar([500, 933], 0.1) \}.scope;\
\
Another (longer) way to write the same thing is \
\
\{ [ \cf3 Saw\cf0 .ar(500, 0.1), \cf3 Saw\cf0 .ar(933, 0.1)] \}.scope;\
\
Expand a ugen to three channels by adding values to the array.\
\
\{ \cf3 Saw\cf0 .ar([500, 933, 2033], 0.1) \}.scope;\
\
\cf2 // 4 channels\cf0 \
\
\{ \cf3 Saw\cf0 .ar([500, 933, 2033, 895], 0.1) \}.scope;\
\
	\
\cf2 ////////////////////////////////////////////////////////////////////////////////////////////////////\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 go to 
\f3\b 8_UnaryOp_synthesis
\f1\b0\fs18 \
}