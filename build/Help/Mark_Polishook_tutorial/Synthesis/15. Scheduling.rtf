{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fnil\fcharset77 Monaco;}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red96\green96\blue96;\red0\green0\blue191;
\red0\green115\blue0;\red0\green0\blue0;\red191\green0\blue0;\red0\green0\blue191;\red96\green96\blue96;
}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 15.\
\
Routines and clocks
\f1\b0\fs18 \
\
Clocks provide the mechanisms in SuperCollider that you use to create automated, algorithmic scheduling. Among the things that clocks play are routines, tasks, and patterns. \
\
Patterns and tasks are built from routines.\
\
The first argument (and usually the only argument) to a routine is a function.\
\
Here's a function;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // to evaluate a function, send it a .value message\cf0 \
f = \{ \cf3 "hello, world"\cf0  \};\
f.value;\
\
Here's the function placed inside a routine. A .yield message will evaluate the expression in the function and return, or "hand over," a value.\
\
r = \cf4 Routine\cf0 (\{ \cf3 "hello, world"\cf0 .yield.postln \});\
\
To run the routine, evaluate,\
\
\cf2 // to evaluate a routine, send a .next message\cf0 \
r.next;\
\
Do it again.\
\
r.next;\
\
This shows that once a routine "yields" and there's no additional code after the .yield message, the routine is then finished, over, and done - unless it's given a reset message and, in that case, it can start over again.\
\
r.reset;\
r.next\
\
\cf2 ////////////////////////////////////////////////////////////////////////////////////////////////////\cf0 \
\
In this excerpt, the .next message, when sent to the routine, causes it to yield each of the 3 expressions (the strings) successively. For example, a next message is sent, a string is yielded, a next message is sent, a string is yielded, etc. \
(\
r = \cf4 Routine\cf0 (\{ \
	\cf3 "hello, world"\cf0 .yield;\
	\cf3 "what a world"\cf0 .yield;\
	\cf3 "i am a world"\cf0 .yield;\
\});\
)\
\
\
\
The last .next message in the example above will return nil. This is because once the last expression in a routine has yielded, routines always return nil until they're reset.\
\
r.next;\
r.next;\
r.next;\
r.next;\
\
\cf2 ////////////////////////////////////////////////////////////////////////////////////////////////////\cf0 \
\
Rewrite the previous routine with a .do message, to make a loop.\
\
(\
r = \cf4 Routine\cf0 (\{ \
\
	\cf4 var\cf0  array;\
	array = [ \cf3 "hello, world"\cf0 , \cf3 "what a world"\cf0 , \cf3 "i am a world"\cf0  ];\
\
	3.do(\{ array.choose.yield \})\
	\
\});\
)\
\
Run the do loop 1 more time than the loop in the routine. As in the previous example, the routine returns 3 strings and then nil.\
\
4.do(\{ r.next.postln \});\
\
\cf2 ////////////////////////////////////////////////////////////////////////////////////////////////////\cf0 \
\
Next, re-write the routine so that it includes a .wait message. The .wait message will pause a clock that "plays" the routine for an amount of time represented in seconds.\
\
(\
r = \cf4 Routine\cf0 (\{ \
\
	\cf4 var\cf0  array;\
	array = [ \cf3 "hello, world"\cf0 , \cf3 "what a world"\cf0 , \cf3 "i am a world"\cf0  ];\
\
	3.do(\{ 1.wait; array.choose.postln; \})\
	\
\});\
)\
\
Append a .reset message to the routine, as shown in the code below. In this way, the routine is always ready to start again. Then, play the routine with a clock.\
\
The code below shows the 3 clocks that SuperCollider uses to schedule events.\
\
\cf4 SystemClock\cf0 .play(r.reset);		\cf2 // the most accurate\cf0 \
\cf4 AppClock\cf0 .play(r.reset);			\cf2 // for use with GUIs\cf0 \
\cf4 TempoClock\cf0 .new.play(r.reset);	\cf2 // mostly used to schedule in beat\cf0 \
\
\cf2 ////////////////////////////////////////////////////////////////////////////////////////////////////\cf0 \
\
Or, as an abbreviation, use TempoClock as a default.\
\
r.reset.play\
\
\cf2 ////////////////////////////////////////////////////////////////////////////////////////////////////\cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 Scheduling synths with routines\

\f1\b0\fs18 \
Enclose synths within routines. Be sure the synthdef used in the synth has an envelope with its doneAction parameter set to 2. This will deallocate the memory needed for the synth after its envelope has finished playing\
\
(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 SynthDef\cf0 (\cf3 "fm2"\cf0 , \{ \
	\cf4 arg\cf0  bus = 0, freq = 440, carPartial = 1, modPartial = 1, index = 3, mul = 0.2, ts = 1;\
\
	\cf2 // index values usually are between 0 and 24\cf0 \
	\cf2 // carPartial :: modPartial => car/mod ratio\cf0 \
	\
	\cf4 var\cf0  mod;\
	\cf4 var\cf0  car;\
	\
	mod = \cf4 SinOsc\cf0 .ar(\
		freq * modPartial, \
		0, \
		freq * index * \cf4 LFNoise1\cf0 .kr(5.reciprocal).abs\
	);\
		\
	car = \cf4 SinOsc\cf0 .ar(\
		(freq * carPartial) + mod, \
		0, \
		mul\
	);\
	\
	\cf4 Out\cf0 .ar(\
		bus,\
		car * \cf4 EnvGen\cf0 .kr(\cf4 Env\cf0 .sine(1), doneAction: 2, timeScale: ts)\
	)\
\}).load(s);\
)\
\
(\
r = \cf4 Routine\cf0 (\{\
\
	12.do(\{\
		\cf4 Synth\cf0 (\cf3 "fm2"\cf0 , [\cf5 \\freq\cf0 , 400.0.rrand(1200), \cf5 \\carPartial\cf0 , 0.5.rrand(2), \cf5 \\ts\cf0 , 0.1.rrand(4)]);\
		2.wait;\
	\})\
\});\
)\
r.reset.play;\
\
\cf2 ////////////////////////////////////////////////////////////////////////////////////////////////////\cf0 \
\
Play synths spawned in a routine through a echo effects unit that runs outside of the routine. \
\
(\
\cf4 SynthDef\cf0 (\cf3 "echoplex"\cf0 , \{\
	\cf4 ReplaceOut\cf0 .ar(\
		0,\
		\cf4 CombN\cf0 .ar(\
			\cf4 In\cf0 .ar(0, 1),\
			0.35,\
			[\cf4 Rand\cf0 (0.05, 0.3), \cf4 Rand\cf0 (0.05, 0.3)], \
			\cf2 // generate random values every time a synth is created\cf0 \
			7,\
			0.5\
		)\
	)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf6 \}).load(s);\
\
\cf7 // attach a ~source group to the head of the rootnode and \cf6 \
\cf7 // an ~effects group to the tail of the rootenode\cf6 \
~source = \cf8 Group\cf6 .head(s);\
~effect = \cf8 Group\cf6 .tail(s);\
\
r = \cf8 Routine\cf6 (\{\
\
	\cf7 // loop is the same as inf.do, eg, create an infinite loop that runs forever\cf6 \
	loop(\{\
		\cf8 Synth\cf6 .head(	\cf7 // attach the synth to the head of the ~source group\cf6 \
			~source,\
			\cf9 "fm2"\cf6 , \
		\cf0 	[\
				\cf5 \\outbus\cf0 , 0, \cf5 \\freq\cf0 , 400.0.rrand(1200), \cf5 \\modPartial\cf0 , 0.3.rrand(2.0),\
				\cf5 \\carPartial\cf0 , 0.5.rrand(11), \cf5 \\ts\cf0 , 0.1.rrand(0.2)]\
		);\
		2.wait;\
	\})\
\});\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // 2 echoplexes - attach them, successively as the heads of the ~effects group \cf0 \
\cf4 Synth\cf0 .head(~effect, \cf3 "echoplex"\cf0 );\
\cf4 Synth\cf0 .head(~effect, \cf3 "echoplex"\cf0 );\
)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf7 // play the routine\
\cf0 r.reset.play;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 ////////////////////////////////////////////////////////////////////////////////////////////////////\cf0 \
}