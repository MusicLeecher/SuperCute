{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fnil\fcharset77 Monaco;\f2\fswiss\fcharset77 Helvetica;
}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue191;\red96\green96\blue96;
\red0\green115\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 9. \
\
Binary ops
\fs18 \

\f1\b0 \
Binary operations, in which a ugen is followed by an operator and an operand, usually lead to synthesis processes that are more complex than those created by unary operations.\
\
Examples of binary operations include addition, multiplication, subtraction, and division, to name only a few.\
\
The general pattern is\
\
	OBJECT OPERATOR OPERAND\
	\
combined such that\
\
	2 * 3\
	\
is an object, a binary operator, and an operand. \
\
See the documents in the SuperCollider help system in Help/BinaryOps for a list of many of the binary operations that can be applied to ugens.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 ////////////////////////////////////////////////////////////////////////////////////////////////////\cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 Mixing = addition\

\f1\b0\fs18 \
Mix 2 or more ugens through addition.\
\
(\
	\cf2 // mix 2 sawtooth waves\cf0 \
	\{ \
		\cf3 Saw\cf0 .ar(500, 0.05)				\cf2 // object\cf0 \
		+							\cf2 // operator\cf0 \
		\cf3 Saw\cf0 .ar(600, 0.06)				\cf2 // operand\cf0 \
	\}.scope;\
)\
\
The result of the addition is a BinaryOpUGen.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 \
////////////////////////////////////////////////////////////////////////////////////////////////////\cf0 \
\
The next example shows what happens then 3 UGens are combined through addition: the 1st two ugens combine into a BinaryOpUGen. That result is then followed by an addition operator and another ugen (an operand) which creates yet another BinaryOpUGen.\
\
(\
	\{ \
	\cf2 	// the 1st 2 ugens combine into a BinaryOp ugen\cf0 \
		\cf3 Saw\cf0 .ar(500, 0.05)\
		+\
		\cf3 Saw\cf0 .ar(600, 0.06)\
		+\
	\cf2 	// this ugen is an operand to a BinaryOp ugen and a '+' operator\cf0 \
		\cf3 Saw\cf0 .ar(700, 0.07)\
	\}.scope;\
)\
\
\cf2 ////////////////////////////////////////////////////////////////////////////////////////////////////\cf0 \
\
Use the Mix ugen to produce the same result as the previous example.\
\
(\
\{ \
	\cf2 // put the ugens that you want to mix into an array\cf0 \
	\cf3 Mix\cf0 .ar(\
		[ \
			\cf3 Saw\cf0 .ar(500, 0.05),\
			\cf3 Saw\cf0 .ar(600, 0.06), \
			\cf3 Saw\cf0 .ar(700, 0.06) \
		]\
	) \
\}.scope\
)\
\
\cf2 ////////////////////////////////////////////////////////////////////////////////////////////////////\cf0 \
\
Or use Mix.arFill to create the same result. Every time the function is evaluated, the argument i is incremented. So i equals 0 the 1st time the function is evaluated, 1 the 2nd time, 2, the 3rd time, and so on.\
\
\{ \cf3 Mix\cf0 .arFill(3, \{ \cf3 arg\cf0  i; \cf3 Saw\cf0 .ar(500 + (i * 100), 0.05) \}) \}.scope;\
\
\cf2 ////////////////////////////////////////////////////////////////////////////////////////////////////\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs24 \cf0 Scaling = multiplication
\f1\b0 \

\fs18 \
The next example, which uses a low frequency oscillator, applies an envelope to a WhiteNoise generator. It demonstrates that multiplying a ugen with another ugen scales them both.\
\
\{ \cf3 WhiteNoise\cf0 .ar(0.1) * \cf3 SinOsc\cf0 .kr(1, 1) \}.scope;\
\
The next example shows how 2 noise-producing ugens can be scaled with sinewaves to produce BinaryOpUGens which are then added to get yet another BinaryOpUGen.\
\
(\
	\cf2 // ... imitates a train?\cf0 \
	\{ \
		(\cf3 WhiteNoise\cf0 .ar(0.1) * \cf3 SinOsc\cf0 .kr(1, 1))\
		+\
		(\cf3 BrownNoise\cf0 .ar(0.1) * \cf3 SinOsc\cf0 .kr(2, 1))\
	\
	\}.scope;\
)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 \
////////////////////////////////////////////////////////////////////////////////////////////////////\cf0 \
\cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 Envelopes\

\f1\b0\fs18 \
Use envelopes to dynamically modulate any aspect of a ugen, for example, it's frequency, phase, or amplitude.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // modulate amplitude\cf0 \
\{ \cf3 SinOsc\cf0 .ar(440, 0, 0.1) * \cf3 EnvGen\cf0 .kr(\cf3 Env\cf0 .sine(1), doneAction: 2) \}.scope;\
\
Set the doneAction argument (control) to 2 insure that SuperCollider releases the memory required to maintain the instances of the SinOsc and the EnvGen. Notice that the argument is stated in keyword style. This means that the name of the argument is followed by a colon, eg, ':'. The colon is then followed by a value. \
\
Keywords make code easier to read. And, they allow arguments to be presented in any order.\
\cf2 \
////////////////////////////////////////////////////////////////////////////////////////////////////\cf0 \
\cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 Use the timeScale argument (control) in EnvGen to modulate the duration of an envelope.\
\
(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 SynthDef\cf0 (\cf4 "timeScale"\cf0 , \{ \cf3 arg\cf0  ts = 1;\
	\cf3 Out\cf0 .ar(\
		0,\
		\cf3 SinOsc\cf0 .ar(440, 0, 0.4) * \cf3 EnvGen\cf0 .kr(\cf3 Env\cf0 .sine(1), doneAction: 2, timeScale: ts)\
	)\
\}).load(s);\
)\
\
\cf3 Synth\cf0 (\cf4 "timeScale"\cf0 , [\cf5 \\ts\cf0 , 0.1]); \cf2 // the timeScale control is the duration of the envelope\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 \
////////////////////////////////////////////////////////////////////////////////////////////////////\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 //  ... scale the duration of the envelope every time a synth is built\cf0 \
(\
r = \cf3 Routine\cf0 (\{\
	loop(\{\
		\cf3 Synth\cf0 (\cf4 "timeScale"\cf0 , [\cf5 \\ts\cf0 , 0.01.rrand(0.3)]);\
		0.5.wait;\
	\})\
\});\
)\
r.play\
\cf2 \
////////////////////////////////////////////////////////////////////////////////////////////////////\cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 Additive Synthesis\

\f1\b0\fs18 \
Additive synthesis is as its name says. Components are added (summed) together.\
\
(\
\{	\cf2 // evaluate the function 12 times\cf0 \
	\cf3 var\cf0  n = 12;\
	\cf3 Mix\cf0 .arFill(\
		n,\
		\{ \
			\cf3 SinOsc\cf0 .ar(\
				[67.0.rrand(2000), 67.0.rrand(2000)],\
				0, \
				n.reciprocal * 0.75\
			)\
		\}\
	)\
	*\
	\cf3 EnvGen\cf0 .kr(\cf3 Env\cf0 .perc(11, 6), doneAction: 2)\
\}.scope\
)\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 ////////////////////////////////////////////////////////////////////////////////////////////////////\cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 Putting an envelope on each component\

\f1\b0\fs18 \
The promise of additive synthesis has always been one can add sine waves to create or recreate any sound that can be imagined. \
\
The problem of additive synthesis, as a way of creating or recreating any sound, is that one needs to describe an exact number of sine wave, each of which is controlled, ideally, with an envelope.\
\
Either way, nuanced textures can be created by scaling sine components with envelopes.\
\
(\
\{	\cf3 var\cf0  n = 12;\
	\
	\cf3 Mix\cf0 .arFill(\
			n,									\cf2 // generate n sine waves\cf0 \
			\{ \
			\cf3 SinOsc\cf0 .ar(							\cf2 // each with a possible frequency between\cf0 \
				[67.0.rrand(2000), 67.0.rrand(2000)],	\cf2 // low.rrand(high) ... floating point values\cf0 \
				0, \
				n.reciprocal						\cf2 // scale the amplitude of each sine wave\cf0 \
												\cf2 // according to the value of n\cf0 \
			)\
			*\
			\cf3 EnvGen\cf0 .kr(							\cf2 // put an envelope on each of the sine waves\cf0 \
				\cf3 Env\cf0 .sine(2.0.rrand(17)), \
				doneAction: 0 					\cf2 // deallocate envelopes only when the\cf0 \
												\cf2 // entire sound is complete (why?)\cf0 \
			)\
		\}\
	)\
	*											\cf2 // put an envelope over the whole patch\cf0 \
	\cf3 EnvGen\cf0 .kr(\
		\cf3 Env\cf0 .perc(11, 6), \
		doneAction: 2, \
		levelScale: 0.75\
	) \
												\
\}.scope\
)\
\
(Or use the 
\f0\b\fs24 Klang
\f1\b0\fs18  ugen to produce a similar result).\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 ////////////////////////////////////////////////////////////////////////////////////////////////////\cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 Ring modulation
\f1\b0 \

\fs18 \
Multiply 2 UGens to create ring modulation\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // modulates the amplitude of a carrier with a low-frequency oscillator (lfo)\cf0 \
\{ \cf3 SinOsc.ar(440, 0, 0.571)\cf0  * \cf3 SinOsc\cf0 .kr(2.reciprocal) \}.scope\
\
\cf2 // put the frequency of the lfo into the audio range to create additional harmonic content\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \{ \cf3 SinOsc.ar(440, 0, 0.571)\cf0  * \cf3 SinOsc\cf0 .kr(880) \}.scope\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // use an lfo to modulate the amplitude of the modulator\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 (\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 	
\f1\fs18 \{ \

\f2\fs24 	
\f1\fs18 	\cf3 SinOsc\cf0 .ar(440, 0, 0.571) \

\f2\fs24 	
\f1\fs18 	* \

\f2\fs24 	
\f1\fs18 	(\cf3 SinOsc\cf0 .kr(880)					\cf2 // wrap the modulator and the lfo in parenthese\cf0 \

\f2\fs24 	
\f1\fs18 	* 								\cf2 // why ... ?\cf0 \

\f2\fs24 	
\f1\fs18 	\cf3 SinOsc\cf0 .kr([6.99, 8.01].reciprocal)\

\f2\fs24 	
\f1\fs18 	)\

\f2\fs24 	
\f1\fs18 \}.scope\
)\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 ////////////////////////////////////////////////////////////////////////////////////////////////////\cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 Amplitude modulation
\f1\b0 \

\fs18 \
Multiply 2 UGens and restrict the value of the modulator to positive values to create what Charles Dodge calls "classic" amplitude modulation.\
\
The modulator, if it is a low frequency oscillator either with its output restricted to positive values or not restricted to positive value will only appear to modulate amplitude. Use the .abs message to restrict a ugen to positive values\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // modulate the amplitude of a carrier with a low-frequency oscillator (lfo)\cf0 \
\{ \cf3 SinOsc.ar(440, 0, 0.571)\cf0  * \cf3 SinOsc\cf0 .kr(2.reciprocal).abs \}.scope\
\
\cf2 // use an lfo to modulate the amplitude of the modulator\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 (\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 	
\f1\fs18 \{ \

\f2\fs24 	
\f1\fs18 	\cf3 SinOsc\cf0 .ar(440, 0, 0.571) \

\f2\fs24 	
\f1\fs18 	* \

\f2\fs24 	
\f1\fs18 	(\cf3 SinOsc\cf0 .kr(880).abs				\cf2 // wrap the modulator and the lfo in parenthese\cf0 \

\f2\fs24 	
\f1\fs18 	* 								\cf2 // why ... ?\cf0 \

\f2\fs24 	
\f1\fs18 	\cf3 SinOsc\cf0 .kr([6.99, 8.01].reciprocal)\

\f2\fs24 	
\f1\fs18 	)\

\f2\fs24 	
\f1\fs18 \}.scope\
)\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 ////////////////////////////////////////////////////////////////////////////////////////////////////\cf0 \
\
Restricting the output of the modulator to positive values and raising the frequency of the low frequency oscillator significantly changes the timbre (by creating sidebands).\
\
\cf2 // put the frequency of the lfo into the audio range and apply the .abs message to the modulator\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \{ \cf3 SinOsc.ar(440, 0, 0.571)\cf0  * \cf3 SinOsc\cf0 .kr(880).abs \}.scope\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // compare the previous example to ring modulation (without the .abs message)\
// ... what's the difference?\cf0 \
\{ \cf3 SinOsc.ar(440, 0, 0.571)\cf0  * \cf3 SinOsc\cf0 .kr(880) \}.scope\
\
\cf2 ////////////////////////////////////////////////////////////////////////////////////////////////////\
}