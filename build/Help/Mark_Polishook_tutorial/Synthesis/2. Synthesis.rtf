{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fnil\fcharset77 Monaco;}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 2.\
\
Synthesis\

\f1\b0\fs18 \
We know that SuperCollider, with synthesis definition and synthesis scheduling, follows a client/server model. Let's focus now on synthesis definition. Which is to say, let's examine how to make the engines that synths use when they run on a server.\
\
There are 3 things to consider as we do this.\
\
First, we need to know some fundamental things about object-oriented programming. And we  need to have some knowledge of the grammar and syntax of the SuperCollider language. In theory, such knowledge is easy to acquire - all we have to do is to read the SuperCollider documentation and study some examples.\
\
Second, we need to have knowledge of digital signal processing. In theory, this too is easy knowledge to acquire. All we need is a good book, such as the "Computer Music Tutorial," by Curtis Roads.\
\
Third, we have to know what want to accomplish musically and aesthetically. We need to ask questions to gain this knowledge, such as why do we, as artists, use tools such as SuperCollider? What are we trying to express through the music or the art that we create?\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 ////////////////////////////////////////////////////////////////////////////////////////////////////}