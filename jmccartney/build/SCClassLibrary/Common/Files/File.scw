File : IOStream {	classvar <openFiles;	var fileptr;	// this only supports file sizes < 2^31 for now	*openDialog { arg prompt, successFunc, cancelFunc;		var path;		path = this.prOpenDialog(prompt);		if (path.notNil, { successFunc.value(path) },{ cancelFunc.value(path) });	}	*saveDialog { arg prompt, defaultName, successFunc, cancelFunc;		var path;		path = this.prSaveDialog(prompt, defaultName);		if (path.notNil, { successFunc.value(path) },{ cancelFunc.value(path) });	}		*new { arg pathName, mode; 		^super.new.open(pathName, mode);	}	*delete { arg pathName;		_FileDelete		^this.primitiveFailed	}	*exists { arg pathName;		var file;		file = File(pathName,"r");		if (file.isOpen, { file.close; ^true });		^false	}	open { arg pathName, mode;		/* open the file. mode is a string passed			to fopen, so should be one of:			"r","w","a","rb","wb","ab","r+","w+","a+",			"rb+","wb+","ab+" 		*/		if (this.prOpen(pathName, mode), {			this.addOpenFile;		});	}	close { // close the file		// the GC will not call this for you		_FileClose 		^this.primitiveFailed;	}	*closeAll {		if (openFiles.notNil, {			openFiles.copy.do({ arg file; file.close; });		});	}	isOpen {		^fileptr.notNil	}	length { // returns the length of the file		_FileLength;		^this.primitiveFailed;	}			pos { // current file position		_FilePos 		^this.primitiveFailed;	}	seek { arg offset, origin; 		// origin is an integer, one of: 		// 0 - from beginning of file		// 1 - from current position		// 2 - from end of file				_FileSeek		^this.primitiveFailed;	}	pos_ { arg toPos;		toPos = toPos.clip(0, this.length - 1);		this.seek(toPos, 0);	}		next { ^this.getChar }	nextN { arg n;		^String.fill(n, { this.next; });	}	contents {		^this.readAllString;	}		put { arg item; this.write(item); }	putAll { arg aCollection;		if (aCollection.isKindOf(RawArray), {			this.write( aCollection );		},{			aCollection.do({ arg item; this.write(item) });		});	}	write { arg item; 		/* writes any of the following items:			a double float,			a long,			an rgb color,			a char,			the name of a Symbol as chars,			the indexable part of any non-Slot format object,				(i.e. Strings, Int8Arrays, Int16Arrays,				Signals, etc.)							NOTE: write is asynchronous, so you should not modify an object after you			have issued a write of it. If you *do* want to modify it then you need to			do a thisProcess.toolboxSync to insure that the request has completed before			you continue.		*/		_FileWrite 		^this.primitiveFailed;	}		getLine { arg argString;		// returns a string up to lesser of next newline 		// or length-1 of the argument string		_FileReadLine;		^this.primitiveFailed;	}			// for more fine grained control these read and write a single	// item of the specified type and size	getChar { _FileGetChar; ^this.primitiveFailed; }	getInt8 { _FileGetInt8; ^this.primitiveFailed; }	getInt16 { _FileGetInt16; ^this.primitiveFailed; }	getInt32 { _FileGetInt32; ^this.primitiveFailed; }	getFloat { _FileGetFloat; ^this.primitiveFailed; }	getDouble { _FileGetDouble; ^this.primitiveFailed; }		putChar { arg aChar; _FilePutChar; ^this.primitiveFailed; }	putInt8 { arg anInteger; _FilePutInt8; ^this.primitiveFailed; }	putInt16 { arg anInteger; _FilePutInt16; ^this.primitiveFailed; }	putInt32 { arg anInteger; _FilePutInt32; ^this.primitiveFailed; }	putFloat { arg aFloat; _FilePutFloat; ^this.primitiveFailed; }	putDouble { arg aFloat; _FilePutDouble; ^this.primitiveFailed; }	putString { arg aString; _FilePutString; ^this.primitiveFailed; }		// these read the entire file into a new array of the specified 	// type.  the array can be written back out with 'write'	readAllString { _FileReadAllString; ^this.primitiveFailed; }	readAllInt8 { _FileReadAllInt8; ^this.primitiveFailed; }	readAllInt16 { _FileReadAllInt16; ^this.primitiveFailed; }	readAllInt32 { _FileReadAllInt32; ^this.primitiveFailed; }	readAllRGB { _FileReadAllRGB; ^this.primitiveFailed; }	readAllFloat { _FileReadAllFloat; ^this.primitiveFailed; }	readAllSignal { _FileReadAllSignal; ^this.primitiveFailed; }	readAllDouble { _FileReadAllDouble; ^this.primitiveFailed; }		// PRIVATE	addOpenFile {		if (openFiles.isNil, { openFiles = Array.new(4); });		openFiles = openFiles.add(this);	}	prOpen { arg pathName, mode;		/* open the file. mode is a string passed			to fopen, so should be one of:			"r","w","a","rb","wb","ab","r+","w+","a+",			"rb+","wb+","ab+" 		*/		_FileOpen 		^this.primitiveFailed;	}	// returns a string for the file's full path.	// returns nil if canceled.	*prOpenDialog { arg prompt;		_File_GetFile		^this.primitiveFailed;	}	// returns a string for the file's full path.	// returns nil if canceled.	*prSaveDialog { arg prompt, defaultName;		_File_PutFile		^this.primitiveFailed;	}}