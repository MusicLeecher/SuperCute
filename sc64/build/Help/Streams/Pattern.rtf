{\rtf1\mac\ansicpg10000\cocoartf824\cocoasubrtf100
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
\f3\fswiss\fcharset77 Helvetica-Oblique;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red0\green0\blue0;\red0\green0\blue191;
\red0\green115\blue0;\red96\green96\blue96;\red0\green115\blue0;\red191\green0\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 Pattern
\f1\b0 \cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 \
superclass: AbstractFunction\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs28 \cf0 Patterns versus Streams\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs24 \cf0 \
	Pattern 
\f1\b0 is an abstract class that is the base for the Patterns library.  These classes form a  \
rich and concise score language for music. The series of help files entitled 
\f0\b Streams-Patterns-Events 
\f1\b0 \
gives a detailed introduction. This attemps a briefer characterization.\
\
	A 
\f0\b Stream
\f1\b0  is an object that responds to 
\f2 next, reset, 
\f1 and 
\f2 embedInStream. 
\f1 Streams \
represent sequences of values that are obtained one at a time by with message 
\f2 next
\f1 .  A 
\f2 reset
\f0\b  \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 message will cause the stream to restart (many but  not all streams actually repeat themselves.) \
If a stream runs out of  values it returns 
\f2 nil
\f1  in response to 
\f2 next
\f1 .  The message 
\f2 embedInStream\

\f1 allows a stream definition to allow another stream to  "take over control" of the stream.\
All objects respond to 
\f2 next
\f1  and 
\f2 reset,
\f1 most by returning themselves in response to next.  \
Thus, the number 7 defines a Stream that produces an infinite sequence of 7's. Most objects \
respond to 
\f2 embedInStream 
\f1 with a singleton Stream that returns the object once. \
\
	A 
\f0\b Pattern 
\f1\b0 is an object that responds to 
\f2 asStream 
\f1 and 
\f2 embedInStream.  A 
\f1 Pattern
\f0\b \

\f1\b0 defines the behavior of a Stream and creates such streams in response to the messages 
\f2 asStream.\

\f1 The difference between a Pattern and a Stream is similar to the  difference between a score  and a \
performance of that score or a class and an instance of that class.  All objects respond to this interface, \
most by returning themselves.  So most objects are patterns that define streams that are an infinite \
sequence of the object and embed as singleton streams of that object returned once.\
\
	Patterns are defined in terms of other Patterns rather than in terms of specific \
values.  This allows a Pattern of arbitrary complexity to be substituted for a \
single value anywhere within a Pattern definition.  A comparison between a Stream\
definition and a Pattern will help illustrate the usefulness of Patterns.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 example 1 - Pseq vs. Routine\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs24 \cf0 The
\fs28  
\fs24 Pattern class 
\f0\b Pseq(array, repetitions) 
\f1\b0 defines a Pattern that will create a Stream that iterates \
an array. The class 
\f0\b Routine(func, stackSize) 
\f1\b0 defines a single Stream, the function that runs within\
that stream is defined to perform the array iteration. \
\
Below a stream is created with 
\f0\b Pseq 
\f1\b0 and an 
\f2 asStream
\f0\b  
\f1\b0 message and an identical stream is \
created directly using 
\f0\b Routine
\f1\b0 .\
\
 
\f0\b // a Routine vs a Pattern 
\f1\b0 \
(\
\
	a = [-100,00,300,400];					// the array to iterate\
\
	p = Pseq(a);							// make the Pattern\
	q = p.asStream;						// have the Pattern make a Stream\
	r = Routine(\{ a.do(\{ arg v; v.yield\}) \}) ;		// make the Stream directly\
\
	5.do(\{ Post << Char.tab << r.next << " " << q.next << Char.nl; \});\
)\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 example 2 - Nesting patterns\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 \
	In example 1, there is little difference between using  Pseq and Routine.  But Pseq actually \
iterates its array as  a collection of 
\f3\i patterns to be embedded
\f1\i0 , allowing another Pseq to replace any\
of the values in the array.  The Routine, on the other hand,  needs to be completely \
redefined.\
\
(\
	var routinesA;\
	a = [3, Pseq([-100,00,300,400]), Pseq([-100,00,300,400].reverse) ];\
	routinesA = [[3], [-100,00,300,400], [-100,00,300,400].reverse];\
	p = Pseq(a);\
	q = p.asStream;\
\
	r = Routine(\{ \
		routinesA.do(\{ arg v; \
			v.do(\{ arg i; i.yield\}) \
		\}) ;\
	\});\
	10.do(\{ Post << Char.tab << r.next << " " << q.next << Char.nl; \});\
)	\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 example 3 - Stream-embedInStream\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 \
The message 
\f2 embedInStream
\f1  is what allows Patterns to do this kind of nesting. Most  objects \
(such as the number 3 below) respond to 
\f2 embedInStream
\f0\b  
\f1\b0 by yielding themselves once and returning.\
Streams respond to embedInStream by iterating themselves to completion, effectively "taking over" the \
calling stream for that time.  \
\
A Routine can perform a pattern simply by replacing calls to 
\f2 yield 
\f1 with calls to 
\f2 embedInStream.\

\f1 ( \
	a = [3, Pseq([-100,00,300,400]), Pseq([-100,00,300,400].reverse) ];\
\
	r = Routine(\{ a.do(\{ arg v; v.
\f3\i embedInStream
\f1\i0 \}) \}) ;\
	p = Pseq(a);\
	q = p.asStream;\
	10.do(\{ Post << Char.tab << r.next << " " << q.next << Char.nl; \});\
)	\
\
Of course, there is no concise way to 
\f3\i define
\f1\i0  this stream without using Pseq. \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 note: 
\f1\b0 For reasons of efficiency, the implementation of embedInStream assumes that it is called from\
within a Routine. Consequently, embedInStream should never be called from within the function that\
defines a FuncStream or a Pfunc (the pattern that creates FuncStreams).\
 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs30 \cf0 Event Patterns
\f1\b0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 	
\f1\b0 An Event is a Environment with a 'play' method.  Typically, an Event consists of\
a collection of key/value pairs that determine what the play method actually does.\
The values may be any object including functions defined in terms of other named attributes.  \
Changing those values can generate a succession of sounds sometimes called 'music'...\
The pattern 
\f0\b Pbind 
\f1\b0 connects specific patterns with specific names. Consult its help page for \
details.\
\
..................\
\
	 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 A Summary of Pattern classes\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 	Below are brief examples for  most of the classes derived from Pattern. These examples\
all rely on the patterns assigned to the Interpreter variable p, q, and r in the first block of code.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs18 \cf2 \
\cf3 (\
\cf4 SynthDef\cf3 (\cf5 \\cfstring1\cf3 .postln, \{ \cf4 arg\cf3  i_out, freq = 360, gate = 1, pan, amp=0.1;\
	\cf4 var\cf3  out, eg, fc, osc, a, b, w;\
	fc = \cf4 LinExp\cf3 .kr(\cf4 LFNoise1\cf3 .kr(\cf4 Rand\cf3 (0.25,0.4)), -1,1,500,2000);\
	osc = \cf4 Mix\cf3 .fill(8, \{\cf4 LFSaw\cf3 .ar(freq * [\cf4 Rand\cf3 (0.99,1.01),\cf4 Rand\cf3 (0.99,1.01)], 0, amp) \}).distort * 0.2;\
	eg = \cf4 EnvGen\cf3 .kr(\cf4 Env\cf3 .asr(1,1,1), gate, doneAction:2);\
	out = eg * \cf4 RLPF\cf3 .ar(osc, fc, 0.1);\
	#a, b = out;\
	\cf4 Out\cf3 .ar(i_out, \cf4 Mix\cf3 .ar(\cf4 PanAz\cf3 .ar(4, [a, b], [pan, pan+0.3])));\
\}).store;\
\
\cf4 SynthDef\cf3 (\cf6 "sinegrain2"\cf3 , \
	\{ \cf4 arg\cf3  out=0, freq=440, sustain=0.05, pan;\
		\cf4 var\cf3  env;\
		env = \cf4 EnvGen\cf3 .kr(\cf4 Env\cf3 .perc(0.01, sustain, 0.3), doneAction:2);\
		\cf4 Out\cf3 .ar(out, \cf4 Pan2\cf3 .ar(\cf4 SinOsc\cf3 .ar(freq, 0, env), pan))\
	\}).store;\
\
p = \cf4 Pbind\cf3 (\
	[\cf5 \\degree\cf3 , \cf5 \\dur\cf3 ], \cf4 Pseq\cf3 ([[0,0.1],[2,0.1],[3,0.1],[4,0.1],[5,0.8]],1),\
	\cf5 \\amp\cf3 , 0.05, \cf5 \\octave\cf3 , 6, \cf5 \\instrument\cf3 , \cf5 \\cfstring1\cf3 , \cf5 \\mtranspose\cf3 , 0);\
\
q = \cf4 Pbindf\cf3 (p, \cf5 \\instrument\cf3 , \cf5 \\default\cf3  );\
\
r = \cf4 Pset\cf3 (\cf5 \\freq\cf3 , \cf4 Pseq\cf3 ([500, 600, 700], 2), q);\
\
)
\f0\b\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
// EVENT PATTERNS - patterns that generate or require event streams\
\
	// Pbind( ArrayOfPatternPairs )\
	\
	
\f2\b0\fs18 \cf2 p = Pbind\cf0 (\
		[\cf7 \\degree\cf0 , \cf7 \\dur\cf0 ], \cf2 Pseq\cf0 ([[0,0.1],[2,0.1],[3,0.1],[4,0.1],[5,0.8]],1),\
		\cf7 \\amp\cf0 , 0.05, \cf7 \\octave\cf0 , 6, \cf7 \\instrument\cf0 , \cf7 \\cfstring1\cf0 , \cf7 \\mtranspose\cf0 , 0);\
		\
	p.play;\
	\
	
\f0\b\fs24 //Ppar(arrayOfPatterns, repeats) - play in parallel\
	\
	
\f2\b0\fs18 Ppar([Pseq([p],4),Pseq([Pbindf(q,\\ctranspose, -24)],5)]).play
\f0\b\fs24 \
	\
	//Ptpar(arrayOfTimePatternPairs, repeats) - play in parallel at different times\
	\
	
\f2\b0\fs18 Ptpar([1,Pseq([p],4),0, Pseq([Pbindf(q,\\ctranspose, -24)],5)]).play
\f0\b\fs24 \
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs18 \cf0 	
\f0\b\fs24 // Pbindf( pattern, ArrayOfNamePatternPairs )\
	
\f2\b0\fs18 \
	q = Pbindf(p, \\instrument, \\default );\
	q.play;\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 	//Pfset(function, pattern)  \
	
\f1\b0 // function constructs an event that is passed to the pattern.asStream\
	
\f2\fs18 \
	\cf2 Pfset\cf0 (\cf7 \{ ~freq\cf0  = \cf2 Pseq\cf0 ([500, 600, 700], \cf2 2\cf0 ).asStream \}, q).play;\
	\
	
\f0\b\fs24 //Pset(name, valPattern, pattern)  \
	
\f1\b0 // set one field of the event on an event by event basis (
\f0\b Pmul
\f1\b0 , 
\f0\b Padd
\f1\b0  are similar)\
	
\f2\fs18 \
	\cf2 Pset\cf0 (\cf7 \\freq\cf0 , \cf2 Pseq\cf0 ([500, 600, 700], \cf2 2\cf0 ), q).play;\
	\
	
\f0\b\fs24 //Psetp(name, valPattern, pattern) \
	
\f1\b0 // set once for each iteration of the pattern (
\f0\b Pmulp
\f1\b0 , 
\f0\b Paddp
\f1\b0  are similar)\
	
\f2\fs18 \
	\cf2 r = Pset\cf0 (\cf7 \\freq\cf0 , \cf2 Pseq\cf0 ([500, 600, 700], \cf2 2\cf0 ), q);\
	\
	\cf2 Psetp\cf0 (\cf7 \\legato\cf0 , Pseq([0.01, 1.1],inf), r).play;\
	\
	
\f0\b\fs24 //Psetpre(name, valPattern, pattern) \
	
\f1\b0 // set before passing the event to the pattern (
\f0\b Pmulpre
\f1\b0 , 
\f0\b Paddpre
\f1\b0  are similar)\
	
\f2\fs18 \
	\cf2 r = Psetpre\cf0 (\cf7 \\freq\cf0 , \cf2 Pseq\cf0 ([500, 600, 700], \cf2 2\cf0 ), q);\
	\
	\cf2 Psetp\cf0 (\cf7 \\legato\cf0 , Pseq([0.01, 1.1],inf), r).play;\
	\
	
\f0\b\fs24 //Pstretch(valPattern, pattern) \
	
\f1\b0 // stretches durations after \
	
\f2\fs18 \
	\cf2 r = Psetpre\cf0 (\cf7 \\freq\cf0 , \cf2 Pseq\cf0 ([500, 600, 700], \cf2 2\cf0 ), q);\
	\
	\cf2 Pstretch(Pn(Env([0.5,2,0.5], [10,10]))\cf0 , Pn(r)).play;\
	\
	Pset(\\stretch, \cf2 Pn(Env([0.5,2,0.5], [10,10]) ), Pn(r)).play\cf0 \
	\
	
\f0\b\fs24 //Pstretchp(valPattern, pattern) \
	
\f1\b0 // stretches durations after \
	
\f2\fs18 \
	\cf2 r = Psetpre\cf0 (\cf7 \\freq\cf0 , \cf2 Pseq\cf0 ([500, 600, 700], \cf2 2\cf0 ), q);\
	\
	\cf2 Pstretchp(Pn(Env([0.5,2,0.5], [10,10]))\cf0 , r).play;\
	\
	
\f0\b\fs24 // Pfindur( duration, pattern ) - play pattern for duration\
	\
	
\f2\b0\fs18 Pfindur(2,Pn(q,inf)).play;\
	
\f0\b\fs24 \
	// PfadeIn(  pattern, fadeTime, holdTime, tolerance )\
	
\f2\b0\fs18 PfadeIn(Pn(q), 3, 0).play(quant: 0);\
	
\f0\b\fs24 \
	// PfadeOut(  pattern, fadeTime, holdTime, tolerance )\
	
\f2\b0\fs18 PfadeOut(Pn(q), 3, 0).play(quant: 0);\
	
\f0\b\fs24 \
	// Psync( pattern, quantization, dur, tolerance )\
	// pattern is played for dur seconds (within tolerance), then a rest is played so the next pattern\
	\
	
\f2\b0\fs18 Pn(Psync(\
		Pbind(	\\dur, Pwhite(0.2,0.5).round(0.2), \
				\\db, Pseq([-10,-15,-15,-15,-15,-15,-30])\
		), 2,3\
	)).play\
	
\f0\b\fs24 \
	//Plag(duration, pattern)\
	\
	
\f2\b0\fs18 Ppar([Plag(1.2,Pn(p,4)),Pn(Pbindf(q,\\ctranspose, -24),5)]).play\
	\

\f0\b\fs24 // GENERAL PATTERNS that work with both event and value streams\
\
	//Ptrace(pattern, key, printStream)  - print the contents of a pattern
\f1\b0 \
	
\f2\fs18 \
	\cf2 r = Psetpre\cf0 (\cf7 \\freq\cf0 , \cf2 Pseq\cf0 ([500, 600, 700], \cf2 2\cf0 ), q);\
	\
	\cf2 Ptrace(r\cf0 ).play;\
	\cf2 Ptrace(r, \\freq\cf0 ).play;\
	\
	(\
	\{ var printStream;\
		printStream = CollStream.new;\
	\cf2 	Pseq([Ptrace(r, \\freq, printStream\cf0 ), Pfunc(\{printStream.collection.dump; nil \}) ]).play;\
		\
	\}.value;\
	)	\
	
\f0\b\fs24 \
	//Pseed(seed, pattern) - set the seed of the random number generator \
	// to force repetion of pseudo-random patterns\
	\
	
\f2\b0\fs18 Pn(Pseed(44, Pbindf(q,\\ctranspose,Pbrown(-3.0,3.0, 10) ) ) ).play;\

\f0\b\fs24 \
	//Proutine(function) - on exit, the function must return the last value returned by yield\
	// (otherwise, the pattern cannot be reliably manipulated by other patterns)\
	\
	
\f2\b0\fs18 Proutine(\{ arg inval; \
		inval = p.embedInStream(inval);\
		inval = Event.silent(4).yield;\
		inval = q.embedInStream(inval);\
		inval = r.embedInStream(inval);\
		inval;\
	\}).play\

\f0\b\fs24 \
	//Pfunc(function) - the function should not have calls to embedInStream, use Proutine instead.\
		\
		
\f2\b0\fs18 Pn(Pbindf(q,\\legato, Pfunc(\{ arg inval; if (inval.at(\\degree)== 5)  \{4\} \{0.2\}; \})) ).play
\f0\b\fs24 \
\
	// the following patterns control the sequencing and repetition of other patterns\
	\
		//Pseq(arrayOfPatterns, repeats) - play as a sequence\
		\
		
\f2\b0\fs18 Pseq([Pseq([p],4),Pseq([Pbindf(q,\\ctranspose, -24)],5)]).play\
		
\f0\b\fs24 \
		//Pser(arrayOfPatterns, num) - play num patterns from the arrayOfPatterns\
		\
		
\f2\b0\fs18 Pser([p,q,r],5).play\
		
\f0\b\fs24 \
		//Place(arrayOfPatterns, repeats) - similar to Pseq\
		// but array elements that are themselves arrays are iterated \
		// embedding the first element on the first repetition, second on the second, etc\
		\
		
\f2\b0\fs18 Place([[p,q,r],q,r],5).play\
		
\f0\b\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b0\fs18 \cf0 		
\f0\b\fs24 \
		// Pn( pattern, patternRepetitions ) - repeat the pattern n times\
		\
		
\f2\b0\fs18 Pn(p,2).play;\
		
\f0\b\fs24 \
		// Pfin( eventcount, pattern ) - play n events from the pattern\
		\
		
\f2\b0\fs18 Pfin(12,Pn(p,inf)).play;\
		
\f0\b\fs24 \
		// Pstutter( eventRepetitions, pattern ) - repeat each event from the pattern n times\
		
\f2\b0\fs18 \
		Pstutter(4,q).play
\f0\b\fs24 \
		\
		//Pwhile(function, pattern) \
		
\f2\b0\fs18 \
		Pwhile(\{coin(0.5).postln;\}, q).play\
		
\f0\b\fs24 \
		// Pswitch( patternList, selectPattern ) - when a pattern ends, switch according to select\
		\
		
\f2\b0\fs18 Pswitch([p,q,r], Pwhite(0,100)).play\
		\
		
\f0\b\fs24 // Pswitch1( patternList, selectPattern ) - on each event switch according to select\
		
\f2\b0\fs18 \
		Pn(Pswitch1([p,q,r], Pwhite(0,2))).play\
		
\f0\b\fs24 \

\f2\b0\fs18 		
\f0\b\fs24 // Prand( patternList, repeats ) -  random selection from list		
\f2\b0\fs18 \
		Prand([p,q,r],  inf).play\
\
		
\f0\b\fs24 // Pxrand( patternList, repeats ) -  random selection from list without repeats		
\f2\b0\fs18 \
		Pxrand([p,q,r],  inf).play\
\
		
\f0\b\fs24 // Pwrand( patternList, weights, repeats ) - weighted random selection from list		
\f2\b0\fs18 \
		Pwrand([p,q,r], #[1, 3, 5].normalizeSum, inf).play\
\
		
\f0\b\fs24 // Pwalk( patternList, stepPattern, directionPattern ) - walk through a list of patterns\
		
\f2\b0\fs18 \
		Pwalk([p,q,r], 1, Pseq([-1,1], inf)).play\
\
		
\f0\b\fs24 // Pslide(list, repeats, length, step, start)\
\
		
\f2\b0\fs18  Pbind(\\degree, \cf2 Pslide\cf0 (#[1, 2, 3, 4, 5], inf, 3, 1, 0), \\dur,0.2).play
\f1\fs24 \
\

\f2\fs18 		
\f0\b\fs24 // Pshuf( patternList, repeats ) -  random selection from list		
\f2\b0\fs18 \
		Pn(Pshuf([p,q,r,r,p])).play\
\
		
\f0\b\fs24 // Ptuple(list, repeats)\
\
		
\f2\b0\fs18  Pbind(\\degree,Ptuple([Pwhite(1,-6), Pbrown(8,15,2)]), \
		 	\\dur, Pfunc(\{ arg ev; ev.at(\\degree).last/80 round: 0.1\}), \
		 	\\db, Pfunc(\{ if (coin(0.8)) \{-25\} \{-20\} \})\
		 ).play
\f1\fs24 \
\
\
	
\f0\b // the following patterns can alter the values returned by other patterns\
	\
		//Pcollect(function, pattern) \
		
\f2\b0\fs18 \
		Pcollect(\{ arg inval; inval.use(\{ ~freq = 1000.rand \}); inval\}, q).play\
		
\f0\b\fs24 \
		//Pselect(function, pattern) \
		
\f2\b0\fs18 \
		Pselect(\{ arg inval; inval.at(\\degree) != 0 \}, q).play(quant: 0)\
		
\f0\b\fs24 \
		//Preject(function, pattern) \
		
\f2\b0\fs18 \
		Preject(\{ arg inval; inval.at(\\degree) != 0 \}, q).play(quant: 0)\
		
\f0\b\fs24 \
	//Ppatmod(pattern, function, repeats) -\
	// function receives the current pattern as an argument and returns the next pattern to be played\
	\

\f2\b0\fs18 	Ppatmod(p, \{ arg oldPat; [p,q,r].choose \}, inf).play
\f0\b\fs24 \
\
// VALUE PATTERNS: these patterns define or act on streams of numbers\
\
	// Env as a pattern\
	
\f2\b0\fs18 \
	Pbindf(Pn(q,inf),\\ctranspose, Pn(Env.linen(3,0,0.3,20),inf) ).play;\
	\
	
\f0\b\fs24 // Pwhite(lo, hi, length)\
	
\f2\b0\fs18 \
	Pbindf(Pn(q,inf),\\ctranspose,Pwhite(-3.0,3.0) ).play;\
	\
	
\f0\b\fs24 // Pbrown(lo, hi, step, length)\
	
\f2\b0\fs18 \
	Pbindf(Pn(q,inf),\\ctranspose,Pbrown(-3.0,3.0, 2) ).play;\
	\
	
\f0\b\fs24 // Pseries(start,step, length)\
	
\f2\b0\fs18 \
	Pbindf(Pn(q,inf),\\ctranspose,Pseries(0,0.1,10) ).play;\
	\
	
\f0\b\fs24 // Pgeom(start,step, length)\
	
\f2\b0\fs18 \
	Pbindf(Pn(q,inf),\\ctranspose,Pgeom(1,1.2,20) ).play;\
	\
	
\f0\b\fs24 // Pwrap(pattern,lo, hi)\
	
\f2\b0\fs18 \
	Pbind(\\note, Pwrap(Pwhite(0, 128), 10, 20).round(2), \\dur, 0.05).play;\
	\
	
\f0\b\fs24 // PdegreeToKey(pattern, scale, stepsPerOctave)\
	// this reimplements part of pitchEvent (see Event)\
	
\f2\b0\fs18 \
	Pbindf(Pn(q,inf),\\note,PdegreeToKey(Pbrown(-8, 8, 2), [0,2,4,5,7,9,11]) ).play;\
	\
	
\f0\b\fs24 // Prewrite(pattern, dict, levels) - see help page for details.\
	// (notice use of Env to define a chord progression of sorts...\
	
\f2\b0\fs18 \
	Pbind(\\degree, \
		\cf2 Prewrite\cf0 (0,\cf8 	\cf2 (\cf0 	0: #[2,0],\
	 					1: #[0,0,1],\
	 					2: #[1,0,1]\
	 				), 4\
	 	) + Pn(Env([4,0,1,4,3,4], [6.4,6.4,6.4,6.4,6.4],'step')),\
	 	\\dur, 0.2).play\
\
	
\f0\b\fs24 // PdurStutter( repetitionPattern, patternOfDurations ) - \
	
\f2\b0\fs18 Pbindf(Pn(q), \\dur, \cf2 PdurStutter\cf0 (\
		Pseq(#[1,1,1,1,1,2,2,2,2,2,3,4,5,7,15],inf),\
		Pseq(#[0.5],inf)\
		)\
	).play;\
	
\f0\b\fs24 \
\
	// Pstep2add( pat1, pat2 )  \
	// Pstep3add( pat1, pat2, pat3 )  \
	// PstepNadd(pat1,pat2,...) \
	// PstepNfunc(function, patternArray )\
	// combine multiple patterns with depth first traversal\
\
	
\f2\b0\fs18 \cf2 Pbind\cf0 (\
		\cf7 \\octave\cf0 , 4,\
		\cf7 \\degree\cf0 , \cf2 PstepNadd\cf0 (\
					\cf2 Pseq\cf0 ([1, 2, 3]), \
					\cf2 Pseq\cf0 ([0, -2, [1, 3], -5]), \
					\cf2 Pshuf\cf0 ([1, 0, 3, 0], 2)\
				),\
		\cf7 \\dur\cf0 , \cf2 PstepNadd\cf0 (\
					\cf2 Pseq\cf0 ([1, 0, 0, 1], 2),\
					\cf2 Pshuf\cf0 ([1, 1, 2, 1], 2)\
			).loop * (1/8),\
		\cf7 \\legato\cf0 , \cf2 Pn\cf0 (\cf2 Pshuf\cf0 ([0.2, 0.2, 0.2, 0.5, 0.5, 1.6, 1.4], 4), \cf2 inf\cf0 ),\
		\cf7 \\scale\cf0 , #[0, 1, 3, 4, 5, 7, 8]\
	).play;\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 \
}