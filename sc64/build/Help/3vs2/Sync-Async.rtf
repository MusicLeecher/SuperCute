{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue191;\red96\green96\blue96;
\red0\green115\blue0;\red0\green0\blue0;\red0\green0\blue191;\red96\green96\blue96;\red191\green0\blue0;
}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 Synchronous and Asynchronous Execution\

\f1\b0\fs24 \
Using a program such as SuperCollider introduces a number of issues regarding timing and order of execution. Realtime audio synthesis requires that samples are calculated and played back at a certain rate and on a certain schedule, in order to avoid dropouts, glitches, etc. Other tasks, such as loading a sample into memory, might take arbitrary amounts of time, and may not be needed within a definite timeframe. This is the difference between synchronous and asynchronous tasks.\
\
Problems can arise when synchronous tasks are dependent upon the completion of asynchronous ones. For instance trying to play a sample that may or may not have been completely loaded yet.\
\
In SC2 this was relatively simple to handle. One scheduled synchronous tasks during synthesis, i.e. within the scope of a Synth.play. Asynchronous tasks were executed in order, outside of synthesis. Thus one would first create buffers, load samples into them, and then start synthesis and play them back. The interpreter made sure that each step was only done when the necessary previous step had been completed.\
\
In SC3 the separation of language and synth apps creates a problem: How does one side know that the other has completed necessary tasks, or in other words, how does the left hand know if the right is finished? The flexibility gained by the new architecture introduces another layer of complexity, and an additional demand on the user.\
\
A simple way to deal with this is to execute code in blocks. In the following code, for instance, each block or line of code is dependent upon the previous one being completed.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf2 // Execute these one at a time\
\
// Boot the local Server
\f1\fs24 \cf0 \
	
\f2\fs18 (\
	s = \cf3 Server\cf0 .local;\
	s.boot;\
	)\
\
\cf2 // Compile a SynthDef and write it to disk\cf0 \
	(\
	\cf3 SynthDef\cf0 (\cf4 "Help-SynthDef"\cf0 , \
		\{ \cf3 arg\cf0  out=0;\
			 \cf3 Out\cf0 .ar(out, \cf3 PinkNoise\cf0 .ar(0.1))\
		\}).writeDefFile;\
	)\
\
\cf2 // Load it into the server\cf0 \
	s.loadSynthDef(\cf4 "Help-SynthDef"\cf0 );\
	\
\cf2 // Create a Synth with it\cf0 \
	x = \cf3 Synth\cf0 .new(\cf4 "Help-SynthDef"\cf0 , s);\
\
\cf2 // Free the node on the server\cf0 \
	x.free;\
\
\cf2 // Allow the client-side Synth object to be garbage collected\cf0 \
	x = \cf3 nil\cf0 ; 
\f1\fs24  \
\
In the previous example it was necessary to use interpreter variables (the variables a-z, which are declared at compile time) in order to refer to previously created objects in later blocks or lines of code. If one had declared a variable within a block of code (i.e.\cf3  
\f2\fs18 va\cf0 r mySynth;
\f1\fs24 ) than it would have only persisted within that scope. (See the helpfile 
\f0\b Scope
\f1\b0  for more detail.)\
\
This style of working, executing lines or blocks of code one at a time, can be very dynamic and flexible, and can be quite useful in a performance situation, especially when improvising. But it does raise the issues of scope and persistence. Another way around this that allows for more descriptive variable names is to use environment variables (i.e. names that begin with ~, so ~mysynth; see the 
\f0\b Environment
\f1\b0  helpfile for details). However, in both methods you become responsible for making sure that objects and nodes do not persist when you no longer need them. \

\f2\fs18 \
	(\
	\cf3 SynthDef\cf0 (\cf4 "Help-SynthDef"\cf0 , \
		\{ \cf3 arg\cf0  out=0;\
			 \cf3 Out\cf0 .ar(out, \cf3 PinkNoise\cf0 .ar(0.1))\
		\}).send(s);\
	)\
	\
	\cf2 // make a Synth and assign it to an environment variable\cf0 \
	~mysynth = \cf3 Synth\cf0 .new(\cf4 "Help-SynthDef"\cf0 , s);\
	\
	\cf2 // free the synth\cf0 \
	~mysynth.free;\
	\
	\cf2 // but you've still got a Synth object\cf0 \
	~mysynth.postln;\
	\
	\cf2 // so remove it from the Environment so that the Synth will be garbage collected\cf0 \
	currentEnvironment.removeAt(\cf5 \\mysynth\cf0 );\
	
\f1\fs24 \
But what if you want to have one block of code which contains a number of synchronous and asynchronous tasks. The following will cause an error, as the SynthDef that the server needs has not yet been received.\
\

\f2\fs18 \cf2 // Doing this all at once produces the error "FAILURE /s_new SynthDef not found"
\f1\fs24 \cf0 \

\f2\fs18 	(\
	\cf3 var\cf0  name;\
	name = \cf4 "Rand-SynthDef"\cf0  ++ 400.0.rand; \cf2 // use a random name to ensure it's not already loaded\cf0 \
	\cf3 SynthDef\cf0 (name, \
		\{ \cf3 arg\cf0  out=0;\
			 \cf3 Out\cf0 .ar(out, \cf3 PinkNoise\cf0 .ar(0.1))\
		\}).send(s);\
	\
	\cf3 Synth\cf0 .new(name, s);\
	)\
	
\f1\fs24 \
A crude solution would be to schedule the dependant code for execution after a seemingly sufficient delay using a clock.\
\

\f2\fs18 \cf2 // This one works since the def gets to the server app first
\f1\fs24 \cf0 \

\f2\fs18 	(\
	\cf3 var\cf0  name;\
	name = \cf4 "Rand-SynthDef"\cf0  ++ 400.0.rand;\
	\cf3 SynthDef\cf0 (name, \
		\{ \cf3 arg\cf0  out=0;\
			 \cf3 Out\cf0 .ar(out, \cf3 PinkNoise\cf0 .ar(0.1))\
		\}).send(s);\
	\
	SystemClock.sched(0.05, \{\cf3 Synth\cf0 .new(name, s);\}); // create a Synth after 0.05 seconds\
	)
\f1\fs24 \
\
Although this works, it's not very elegant or efficient. What would be better would be to have the next thing execute immediately upon the previous thing's completion. To explore this, we'll look at an example which is already implemented.\
\
You may have realized that first example above was needlessly complex. SynthDef-play will do all of this compilation, sending, and Synth creation in one stroke of the enter key.\
\

\f2\fs18 \cf2 // All at once\cf0 \
	(\
	\cf3 SynthDef\cf0 (\cf4 "Help-SynthDef"\cf0 , \
		\{ \cf3 arg\cf0  out=0;\
			 \cf3 Out\cf0 .ar(out, \cf3 PinkNoise\cf0 .ar(0.1))\
		\}).play(s);\
	)\
	
\f1\fs24 \
Let's take a look at the method definition for SynthDef-play and see what it does.\
\

\f2\fs18 	play \{ \cf3 arg\cf0  target,args,addAction=\cf5 \\addToTail\cf0 ;\
		\cf3 var\cf0  synth, msg;\
		target = target.asTarget;\
		\
		synth = \cf3 Synth\cf0 .basicNew(name,target.server); \cf2 // create a Synth, but not a synth node \cf0 \
		msg = synth.newMsg(target, addAction, args);\cf2 // make a message that will add a synth node \cf0 \
		\cf3 this\cf0 .send(target.server, msg); \cf2 // ** send the def, and the message as a completion message\cf0 \
		^synth \cf2 // return the Synth object\cf0 \
	\}
\f1\fs24 \
\
This might seem a little complicated if you're not used to mucking about in class definitions, but the important part is the second argument to 
\f2\fs18 \cf3 this\cf0 .send(target.server, msg);
\f1\fs24 . This argument is a completion message, it is a message that the server will execute when the send action is complete. In this case it says create a synth node on the server which corresponds to the 
\f0\b Synth
\f1\b0  object I've already created, when and only when the def has been sent to the server app.  (See the helpfile 
\f0\b Server-Command-Reference 
\f1\b0 for details on messaging.)\
\
Many methods in SC have the option to include completion messages. Here we can use SynthDef-send to accomplish the same thing as SynthDef-play:\
\

\f2\fs18 \cf2 // Compile, send, and start playing\cf0 \
	\cf6 (\
	\cf7 SynthDef\cf6 (\cf8 "Help-SynthDef"\cf6 , \
		\{ \cf7 arg\cf6  out=0;\
			 \cf7 Out\cf6 .ar(out, \cf7 PinkNoise\cf6 .ar(0.1))\
		\}).send(s, [\cf8 "s_new"\cf6 , \cf8 "Help-SynthDef"\cf6 , x = s.nextNodeID]); \
		\cf9 // this is 'messaging' style, see below\cf6 \
	)\
	s.sendMsg(\cf8 "n_free"\cf6 , x);
\f1\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 	\
The completion message needs to be an OSC message, but it can also be some code which when evaluated  returns one:\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf2 // Interpret some code to return a completion message. The .value is needed.\
// This and the preceding example are essentially the same as SynthDef.play
\f1\fs24 \cf0 \
	
\f2\fs18 (
\f1\fs24 \
	
\f2\fs18 \cf3 SynthDef\cf0 (\cf4 "Help-SynthDef"\cf0 , \
		\{ \cf3 arg\cf0  out=0;\
			 \cf3 Out\cf0 .ar(out, \cf3 PinkNoise\cf0 .ar(0.1))\
		\}).send(s, \{x = \cf3 Synth\cf0 .basicNew(\cf4 "Help-SynthDef"\cf0 ); x.newMsg; \}.value); \cf2 // 'object' style\cf0 \
	)\
	x.free;\
	
\f1\fs24 \
If you prefer to work in 'messaging' style, this is pretty simple. If you prefer to work in 'object' style, you can use the commands like newMsg, setMsg, etc. with objects to create appropriate server messages. The two proceeding examples show the difference. See the 
\f0\b NodeMessaging
\f1\b0  helpfile for more detail.\
\
In the case of 
\f0\b Buffer
\f1\b0  objects a function can be used as a completion message. It will be evaluated and passed the 
\f0\b Buffer
\f1\b0  object as an argument. This will happen after the Buffer object is created, but before the message is sent to the server. It can also return a valid OSC message for the server to execute upon completion.\
\

\f2\fs18 	(\
	\cf3 SynthDef\cf0 (\cf4 "help-Buffer"\cf0 ,\{ \cf3 arg\cf0  out=0,bufnum;\
		\cf3 Out\cf0 .ar( out,\
			\cf3 PlayBuf\cf0 .ar(1,bufnum,\cf3 BufRateScale\cf0 .kr(bufnum))\
		)\
	\}).load(s);\
		\
	y = \cf3 Synth\cf0 .basicNew(\cf4 "help-Buffer"\cf0 ); \cf2 // not sent yet\
\cf0 	b = \cf3 Buffer\cf0 .read(s,\cf4 "sounds/a11wlk01.wav"\cf0 , \
		completionMessage: \{ \cf3 arg\cf0  buffer; \
			\cf2 // synth add its s_new msg to follow \
\cf0 			\cf2 // after the buffer read completes\
\cf0 			y.newMsg(s,\cf5 \\addToTail\cf0 ,[\cf5 \\bufnum\cf0 ,buffer.bufnum])\
		\}); \cf2 // .value NOT needed, unlike in the previous example\cf0 \
	\
	)\
	\
	\cf2 // when done...\
\cf0 	y.free;\
	b.free;\
	
\f1\fs24 \
The main purpose of completion messages is to provide OSC messages for the server to execute immediately upon completion. In the case of Buffer there is essentially no difference between the following:\
\

\f2\fs18 	(\
	b = \cf3 Buffer\cf0 .alloc(s, 44100, \
		completionMessage: \{ \cf3 arg\cf0  buffer; (\cf4 "bufnum:"\cf0  + buffer.bufnum).postln; \});\
	)\
	\cf2 // this is equivalent to the above\cf0 \
	(\
	b = \cf3 Buffer\cf0 .alloc;\
	(\cf4 "bufnum:"\cf0  + b.bufnum).postln;\
	)
\f1\fs24 \
\
One can also evaluate a function in response to a 'done' message, or indeed any other one, using an 
\f0\b OSCresponder
\f1\b0  or an 
\f0\b OSCresponderNode
\f1\b0 . The main difference between the two is that the former allows only a single responder per command, where as the latter allows multiple responders. See their respective helpfiles for details.\
\

\f2\fs18 (\
\cf3 SynthDef\cf0 (\cf4 "help-SendTrig"\cf0 ,\{\
	\cf3 SendTrig\cf0 .kr(\cf3 Dust\cf0 .kr(1.0), 0, 0.9);\
\}).send(s);\
\
\cf2 // register to receive this message\
\cf3 a = OSCresponderNode\cf0 (s.addr, \cf5 '/done'\cf0 , \{ \cf3 arg\cf0  time, responder, msg;\
	("This is the done message for the SynthDef.send:" + [time, responder, msg]).postln;\
\}).add.removeWhenDone; \cf2 // remove me automatically when done\cf0 \
\cf3 b = OSCresponderNode\cf0 (s.addr, \cf5 '/tr'\cf0 , \{ \cf3 arg\cf0  time, responder, msg;\
	[time, responder, msg].postln;\
\}).add;\
\cf3 c = OSCresponderNode\cf0 (s.addr, \cf5 '/tr'\cf0 , \{ \cf3 arg\cf0  time, responder, msg;\
	"this is another call".postln;\
\}).add;\
)\
\
\
\cf3 x = Synth\cf0 .new(\cf4 "help-SendTrig"\cf0 );\
b.remove;\
c.remove;\
x.free;}