{\rtf1\mac\ansicpg10000\cocoartf824\cocoasubrtf410
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fnil\fcharset77 Monaco;\f2\fnil\fcharset77 Futura-Medium;
\f3\fswiss\fcharset77 Helvetica;}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue191;\red96\green96\blue96;
\red0\green115\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs30 \cf0 proxy space examples\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs18 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 \ul \ulc0 \
preparation of the environment\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf2 \ulnone \
\cf0 (\
s = \cf3 Server\cf0 .local;\
s.boot;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 p = ProxySpace\cf0 .push(s);\
)\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 \ul playing and monitoring
\f1\fs18 \ulnone \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // play some output to the hardware busses, this could be any audio rate key.\cf0 \
~out.play;\cf2 \
\cf0 \
~out = \{ \cf3 SinOsc\cf0 .ar([400, 408]*0.8, 0, 0.2) \};\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
\cf2 // replacing the node. the crossfade envelope is created internally.\cf0 \
~out = \{ \cf3 SinOsc\cf0 .ar([443, 600-Rand(0,200)], 0, 0.2) \};\
~out = \{ \cf3 Resonz\cf0 .ar(\cf3 Saw\cf0 .ar(40+[0,0.2], 1), [1200, 1600], 0.1) + \cf3 SinOsc\cf0 .ar(60*[1,1.1],0,0.2) \};\
~out = \{ \cf3 Pan2\cf0 .ar(\cf3 PinkNoise\cf0 .ar(0.1), \cf3 LFClipNoise\cf0 .kr(2)) \};\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 \ul setting the node controls\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 \ulnone \
~out = \{ \cf3 arg\cf0  rate=2; \cf3 Pan2.ar\cf0 (\cf3 PinkNoise\cf0 .ar(0.1), \cf3 LFClipNoise\cf0 .kr(rate)) \};\
~out.set(\cf5 \\rate\cf0 , 30);\
~out = \{ \cf3 arg\cf0  rate=2; \cf3 Pan2\cf0 .ar(\cf3 Dust\cf0 .ar(2000, 0.2), \cf3 LFClipNoise\cf0 .kr(rate)) \};\
~out.set(\cf5 \\rate\cf0 , 2);\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 \ul referencing between proxies\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 \ulnone \
~lfo = \{ \cf3 LFNoise2\cf0 .kr(30, 300, 500) \};\
~out = \{ \cf3 SinOsc\cf0 .ar(~lfo.kr, 0, 0.15)  \};\
~out = \{ \cf3 SinOsc\cf0 .ar(~lfo.kr * [1, 1.2], 0, 0.1) * \cf3 Pulse\cf0 .ar(~lfo.kr * [0.1, 0.125], 0.5) \};\
~lfo = \{ \cf3 LFNoise1\cf0 .kr(30, 40) + \cf3 SinOsc\cf0 .kr(0.1, 0, 200, 500) \};\
~out = \{ \cf3 SinOsc\cf0 .ar(~lfo.kr * [1, 1.2], 0, 0.1)  \};\
~lfo = 410;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 \ul \
math
\f1\fs18 \ulnone \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // unary operators\cf0 \
~lfo2 = \{ \cf3 SinOsc\cf0 .kr(0.5, 0, 600, 100)  \};\
~lfo = ~lfo2.abs;\
~lfo2 = \{ \cf3 SinOsc\cf0 .kr(1.3, 0, 600, 100)  \};\
\
\
\cf2 // binary operators\cf0 \
~lfo3 = \{ \cf3 LFTri\cf0 .kr(0.5, 0, 80, 300) \};\
~lfo = ~lfo2 + ~lfo3;\
~lfo = ~lfo3;\
~lfo = (~lfo3 / 50).sin * 200 + 500 * \{ \cf3 LFTri\cf0 .kr(~lfo.kr * 0.0015, 0, 0.1 * ~lfo3.kr / 90, 1) \};\
~lfo3 = \{ \cf3 Mix\cf0 (~lfo2.kr * [1, 1.2]) \};\
\
currentEnvironment.free; \cf2 // free all node proxies\cf0 \
~out.stop; \cf2 // free the playback synth.\cf0 \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 \ul waking up a network of proxies
\f3\fs26 \ulnone \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 \
\cf2 // hit cmd-. to stop all nodes\cf0 \
\cf2 // start again\cf0 \
~out.play; \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 \ul feeding back\ulnone  (one buffer size delay)
\f3\fs26 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 \
~out = \{ \cf3 SinOsc\cf0 .ar([220, 330], ~out.ar(2).reverse * \cf3 LFNoise2\cf0 .kr(0.5, 4*pi), 0.4) \};\
\
\cf2 // there is no immediacy: hear the buffer size cycle\cf0 \
~out = \{ \cf3 Impulse\cf0 .ar(1 ! 2) + (~out.ar(2) * 0.99) \}; \
\
\
\
\cf2 // supercollider 'differential equations'\
\cf0 \
~out = \{ \cf3 SinOsc\cf0 .ar(\cf3 Slope\cf0 .ar(~out.ar) * \cf3 MouseX\cf0 .kr(1000, 18000, 1)) * 0.1 + \cf3 SinOsc\cf0 .ar(100, 0, 0.1) \};\
\
(\
~out = \{ \cf3 var\cf0  z, zz;\
	z = \cf3 Slope\cf0 .ar(~out.ar);\
	zz = \cf3 Slope\cf0 .ar(z);\
	\cf3 SinOsc\cf0 .ar(Rand(300,410), z) *\
	\cf3 SinOsc\cf0 .ar(zz * 410) \
	* 0.1 + \cf3 Decay2\cf0 .ar(\cf3 Pan2\cf0 .ar(\cf3 Dust\cf0 .ar(600), \cf3 MouseX\cf0 .kr(-1,1)), 0.01, 0.05);\
\}\
)\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 \ul multiple control
\f1\fs18 \ulnone \
\
(\
~out = \{ \cf3 arg\cf0  freqOffest;\
	\cf3 var\cf0  ctl;\
	ctl = \cf3 Control\cf0 .names(\cf5 \\array\cf0 ).kr(\cf3 Array\cf0 .rand(8, 400, 1000));\
	Pan2.ar(\cf3 Mix\cf0 (\cf3 SinOsc\cf0 .ar(ctl + freqOffest, 0, 0.1 / 8)), LFNoise0.kr(2))\
\};\
)	\
\
~out.setn(\cf5 \\array\cf0 , \cf3 Array\cf0 .exprand(8, 400, 2000));\
~out.set(\cf5 \\freqOffest\cf0 , rrand(300,200));\
~out.map(\cf5 \\freqOffest\cf0 , ~lfo);\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // a simpler short form for this is:\cf0 \
(\
~out = \{ \cf3 arg\cf0  freqOffest=0, array = #[ 997, 777, 506, 553, 731, 891, 925, 580 ];\
	\cf3 Pan2\cf0 .ar(\cf3 Mix\cf0 (\cf3 SinOsc\cf0 .ar(array + freqOffest, 0, 0.1 / 8)), \cf3 LFNoise0\cf0 .kr(2))\
\};\
)\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 \ul mixing
\f1\fs18 \ulnone \
\
\
~out1 = \{ \cf3 SinOsc\cf0 .ar(600, 0, 0.1) \};\
~out2 = \{ \cf3 SinOsc\cf0 .ar(500, 0, 0.1) \};\
~out3 = \{ \cf3 SinOsc\cf0 .ar(400, 0, 0.1) \};\
~out = ~out2 + ~out1 + ~out3;\
\
~out = ~out1 + ~out2;\
~out = ~out1;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // another way is:\cf0 \
~out = \{ \cf3 SinOsc\cf0 .ar(600, 0, 0.1) \};\
~out.add(\{ \cf3 SinOsc\cf0 .ar(500, 0, 0.1) \});\
~out.add(\{ \cf3 SinOsc\cf0 .ar(400, 0, 0.1) \});\
\
\cf2 // or with direct access:\cf0 \
~out[1] = \{ \cf3 SinOsc\cf0 .ar(500 * 1.2, 0, 0.1) \};\
~out[2] = \{ \cf3 SinOsc\cf0 .ar(400 * 1.2, 0, 0.1) \};\
\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 \ul restoring / erasing
\f3\fs26 \ulnone \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 \
~out.free; \cf2 // this frees the group, not the play synth x\cf0 \
~out.send; \cf2 // resends all synths\
\cf0 ~out.free; \
~out.send(\cf3 nil\cf0 , 1); \cf2 // this sends at index 1 only \cf0 \
~out.send;\cf2 \
\
// removing:\cf0 \
~out.removeLast;\
~out.removeAt(0);\
\
\cf2 // cleaning up, freeing the bus:\cf0 \
~out.clear; \cf2 // this neutralizes the proxy, and frees its bus\cf0 \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 for more on the proxy slots see:
\f1\fs18  
\f3\fs24 [\ul jitlib_basic_concepts_03\ulnone ]
\f1\fs18  \
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 \ul garbage collecting\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 \ulnone \
\cf2 // often there are proxies playing that are not used anymore - this is good,\cf0 \
\cf2 // because they might be used again at any time. \cf0 \
\cf2 // this shows how to free unused proxies, such as ~out1, ~out2.  \cf0 \
\
~out.play;\
~out = \{ \cf3 Pan2\cf0 .ar(\cf3 SinOsc\cf0 .ar(~lfo.kr, 0, 0.2), sin(~lfo.kr / 10)) \}; \cf2 // ~lfo is kept, as its parents.\cf0 \
~lfo = \{ LFNoise2.kr(3, 160, 400) \};\
\
p.keysValuesDo \{\'ca\cf3 arg\cf0  key, proxy; [key, proxy.isPlaying].postln \};\
p.reduce; \cf2 // all monitoring proxies (in this case ~out) are kept. equivalent: p.reduce(to: [~out]);\cf0 \
p.keysValuesDo \{\'ca\cf3 arg\cf0  key, proxy; [key, proxy.isPlaying].postln \};\
\
\cf2 // to remove everything else:\cf0 \
p.postln;\
p.clean; \cf2 // all monitoring proxies (in this case ~out) are kept.\cf0 \
p.postln;
\f3\fs24 \

\f1\fs18 \
\cf2 // after ~out is stopped, it is removed, too:\cf0 \
~out.stop; \cf2 // stop monitor\cf0 \
p.clean; \
p.postln; \cf2 // empty space.\cf0 \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 \ul execution order
\f3\fs26 \ulnone \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 \
\
\cf2 // you can .play .kr or .ar also a name that is not yet used.\cf0 \
\cf2 // the rate is guessed as far as possible. on this topic see also: [the_lazy_proxy]\cf0 \
\
~myOut.play; \cf2 // play some key (audio rate is assumed)\cf0 \
\
\cf2 // the rate is determined from the first access: \cf0 \
\cf2 // like this ~lfo becomes control rate\cf0 \
\
~myOut = \{ \cf3 SinOsc\cf0 .ar(~freq.kr * 2, 0, 0.1) \}; \
~freq = 900;\
~freq = \{ \cf3 SinOsc\cf0 .kr(115, 0, 70, 220) \}\
\
~myOut = \{ \cf3 SinOsc\cf0 .ar(~otherFreq.ar * 2, 0, 0.1) \};\
~otherFreq = \{ \cf3 SinOsc\cf0 .ar(115, 0, 70, 220) \};\
\
currentEnvironment.clear; \cf2 // clear every  proxy in this environment and remove them. (same: p.clear)\cf0 \
\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 \ul setting the xfade time
\f1\fs18 \ulnone \
\
~out.play;\
\
~out.fadeTime = 4;\
~out = \{ \cf3 SinOsc\cf0 .ar(Rand(800, 300.0)*[1,1.1], 0, 0.1) \};\
~out = \{ \cf3 SinOsc\cf0 .ar(Rand(800, 300.0)*[1,1.1], 0, 0.1) \};\
~out.fadeTime = 0.01;\
~out = \{ \cf3 SinOsc\cf0 .ar(Rand(800, 300.0)*[1,1.1], 0, 0.1) \};\
~out = \{ \cf3 SinOsc\cf0 .ar(Rand(800, 300.0)*[1,1.1], 0, 0.1) \};\
\
~out.free(3);  \cf2 // release the synths and the group with a given fadeTime without changing proxy time\cf0 \
~out.stop;	\cf2 // stop monitor\cf0 \
\
\
\

\f2\fs24 \ul setting and mapping arguments
\f1\fs18 \ulnone \
\
\
~out.play;\
\
~out = \{ \cf3 arg\cf0  freq=500, ffreq=120; \cf3 SinOsc\cf0 .ar(freq*[1,1.1], \cf3 SinOsc\cf0 .ar(ffreq, 0, pi), 0.2) \};\
~out.set(\cf5 \\freq\cf0 , 400+100.rand2);\
~out.set(\cf5 \\freq\cf0 , 400+100.rand2);\
~out.set(\cf5 \\ffreq\cf0 , 30+20.rand2);\
~out.unset(\cf5 \\freq\cf0 , \cf5 \\ffreq\cf0 );  \cf2 // remove the setting\cf0 \
~out.set(\cf5 \\ffreq\cf0 , 30+10.rand2, \cf5 \\freq\cf0 , 500 + 200.rand2);\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // argument settings and mappings are applied to every new function\cf0 \
~out = \{ \cf3 arg\cf0  freq=100, ffreq=20; \cf3 SinOsc\cf0 .ar(freq, SinOsc.ar(\cf3 SinOsc\cf0 .ar(ffreq)*ffreq, 0, pi), 0.2) \};\
\
\cf2 // mapping to other proxies\cf0 \
~lfo = \{ \cf3 SinOsc\cf0 .kr(0.3, 0, 80, 100) \};\
~out.map(\cf5 \\ffreq\cf0 , ~lfo);\
\
~out = \{ \cf3 arg\cf0  freq=300, ffreq=20; \cf3 Pulse\cf0 .ar(freq*[1,1.1]+ \cf3 SinOsc\cf0 .ar(ffreq, 0, freq), 0.3, 0.1) \};\
~out = \{ \cf3 arg\cf0  freq=300, ffreq=20; \cf3 BPF\cf0 .ar(\cf3 LFSaw\cf0 .ar(ffreq*[1,1.1], 0, 1), freq, 0.2) \};\
\
~lfo = \{ \cf3 FSinOsc\cf0 .kr(0.3, 0, 30, 200) + \cf3 FSinOsc\cf0 .kr(10, 0, 10) \};\
~out = \{ \cf3 arg\cf0  freq=300, ffreq=20; \cf3 SinOsc\cf0 .ar(freq*[1,1.1], \cf3 SinOsc\cf0 .ar(ffreq, 0, pi), 0.1) \};\
\
\
\cf2 // crossfaded setting and mapping: fadeTime is used\cf0 \
~out.fadeTime = 2;\
~out.xset(\cf5 \\freq\cf0 , 9000);\
~out.xset(\cf5 \\freq\cf0 , rrand(400, 700));\
\
~lfo = \{ \cf3 FSinOsc\cf0 .kr(0.1, 0, 30, 100) \};\
~lfo2 = \{ \cf3 LFClipNoise\cf0 .kr(3, 100, 200) \};\
~lfo3 = \cf3 StreamKrDur\cf0 (\cf3 Pseq\cf0 ([\cf3 Prand\cf0 ([530, 600],1), 700, 400, 800, 500].scramble, \cf3 inf\cf0 ) / 3, 0.2);\
\
~out.xmap(\cf5 \\ffreq\cf0 , ~lfo2);\
~out.xmap(\cf5 \\ffreq\cf0 , ~lfo);\
~out.xmap(\cf5 \\ffreq\cf0 , ~lfo3);\
\
\cf2 // argument rates: just like a synthdef has input 'rates' (like \\ir or \\tr), a nodeproxy control\
// can be given a rate. this rate is used for each function passed into the proxy.\
\
// trigger inputs\cf0 \
~out = \{ \cf3 arg\cf0  trig, dt=1; \cf3 Decay2\cf0 .kr(trig, 0.01, dt) * \cf3 Mix\cf0 (\cf3 SinOsc\cf0 .ar(7000*[1.2, 1.3, 0.2])) \}\
~out.setRates(\\trig, \\tr);\
\
\cf2 // set the group, so the node proxy does not store the new value\cf0 \
~out.group.set(\cf5 \\trig\cf0 , 0.1, \\dt, 0.1); \
~out.group.set(\cf5 \\trig\cf0 , 0.4, \\dt, 0.31);\
~out.group.set(\cf5 \\trig\cf0 , 0.13, \\dt, 2);\
\
\cf2 // lagging controls:\cf0 \
~out.lag(\cf5 \\xfreq\cf0 , 1); \cf2 // equivalent to ~out.setRates(\\xfreq, 1);\cf0 \
(\
~out = \{ \cf3 arg\cf0  trig, dt=1, xfreq=700; \
	\cf3 Decay2\cf0 .kr(trig, 0.01, dt) * \cf3 Mix\cf0 (\cf3 SinOsc\cf0 .ar(xfreq*[1.2, 1.3, 0.2])) \
\};\
)\
~out.group.set(\cf5 \\trig\cf0 , 0.1, \cf5 \\dt\cf0 , 1, \cf5 \\xfreq\cf0 , rrand(2000,9000)); \
~out.group.set(\cf5 \\trig\cf0 , 0.1, \cf5 \\dt\cf0 , 0.5, \cf5 \\xfreq\cf0 , rrand(2000,9000)); \
~out.group.set(\cf5 \\trig\cf0 , 0.1, \cf5 \\dt\cf0 , 1, \cf5 \\xfreq\cf0 , rrand(2000,9000)); \
\
\cf2 // changing the lag, the synth is reconstructed with the new lag:\
\cf0 \
~out.lag(\cf5 \\xfreq\cf0 , 0.01);\
~out.group.set(\cf5 \\trig\cf0 , 0.1, \cf5 \\dt\cf0 , 1, \cf5 \\xfreq\cf0 , rrand(2000,9000)); \
~out.group.set(\cf5 \\trig\cf0 , 0.1, \cf5 \\dt\cf0 , 1, \cf5 \\xfreq\cf0 , rrand(2000,9000)); \
~out.group.set(\cf5 \\trig\cf0 , 0.1, \cf5 \\dt\cf0 , 1, \cf5 \\xfreq\cf0 , rrand(2000,9000)); \
\
\cf2 // removing the trig rate:\cf0 \
~out.setRates(\cf5 \\trig\cf0 , \cf3 nil\cf0 );\
\
\cf2 // note that the same works with the i_ and the t_ arguments, just as it does in SynthDef\cf0 \
\
\
\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs26 \cf0 ___________________________________________________________________\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs32 \cf0 other possible inputs\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs26 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 \ul using a synthdef as input\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 \ulnone \
\
\cf2 // for a more systematic overview see: [jitlib_fading]\
\
// you have the responsibility for the right number of channels and output rate\cf0 \
\cf2 // you have to supply an 'out' argument so it can be mapped to the right channel.\
\
\cf0 ~out.play;\
~out = \cf3 SynthDef\cf0 (\cf4 "w"\cf0 , \{ \cf3 arg\cf0  out=0; \cf3 Out\cf0 .ar(out,\cf3 SinOsc\cf0 .ar([\cf3 Rand\cf0 (430, 600), 600], 0, 0.2)) \});\
~out = \cf3 SynthDef\cf0 (\cf4 "w"\cf0 , \{ \cf3 arg\cf0  out=0; \cf3 Out\cf0 .ar(out,\cf3 SinOsc\cf0 .ar([\cf3 Rand\cf0 (430, 600), 500], 0, 0.2)) \});\
\
\
\cf2 // if you supply a gate it fades in and out. evaluate this several times\cf0 \
(\
~out = \cf3 SynthDef\cf0 (\cf4 "w"\cf0 , \{ \cf3 arg\cf0  out=0, gate=1.0; \
	\cf3 Out\cf0 .ar(out,\
		\cf3 SinOsc\cf0 .ar([\cf3 Rand\cf0 (430, 800), \cf3 Rand\cf0 (430, 800)], 0, 0.2) * \cf3 EnvGen\cf0 .kr(\cf3 Env\cf0 .asr(1,1,1), gate, doneAction:2)\
	) \
	\});\
)\
\
\cf2 // once the SynthDef is sent, it can be assigned by name. \
// using this method, a \cf2 \ul \ulc2 gate argument\ulnone  should be \
// provided that releases the synth. (doneAction:2)\
// this is very efficient, as the def is on the server already.\
\
// if the synth def is in the synthdesc lib (.store) its gate is detected.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 (\
\cf3 SynthDef\cf0 (\cf4 "staub"\cf0 , \{ \cf3 arg\cf0  out, gate=1; \
	\cf3 Out\cf0 .ar(out, \cf3 Ringz\cf0 .ar(\cf3 Dust\cf0 .ar(15), Rand(1, 3) * 3000*[1,1], 0.001) * \cf3 EnvGen\cf0 .kr(\cf3 Env\cf0 .asr, gate, doneAction:2)) \
\}).send(s);\
)\
\
~out = \\staub;\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // if you supply an envelope that frees itself, no bundle is sent to free it\cf0 \
(\
~out = \cf3 SynthDef\cf0 (\cf4 "w"\cf0 , \{ arg out, lfo, f0=430;\
	\cf3 Out\cf0 .ar(out,\
		\cf3 SinOsc\cf0 .ar([\cf3 Rand\cf0 (f0, 800), \cf3 Rand\cf0 (f0, 800)]+lfo, 0, 0.2) * \cf3 EnvGen\cf0 .kr(\cf3 Env\cf0 .perc(0.01, 0.03), doneAction:2)\
	) \
	\});\
)\
\
~out.spawn;\
~out.spawn([\\f0, 5000]);\
fork \{ 5.do \{ ~out.spawn([\\f0, 5000 + 1000.0.rand]); 0.1.wait; \} \}\
\
\
\cf2 // when the synth description in the SynthDescLib is found for the symbol,\cf0 \
\cf2 // the proxy can determine whether to release or to free the synth.\cf0 \
\cf2 // so if there is no 'gate' arg provided and the def has a desc, the synth is\cf0 \
\cf2 // freed and not released. \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
(\
\cf3 SynthDef\cf0 (\cf4 "staub"\cf0 , \{ \cf3 arg\cf0  out; \
	\cf3 Out\cf0 .ar(out, \cf3 Ringz\cf0 .ar(\cf3 WhiteNoise\cf0 .ar(0.01), 1000*[1,1], 0.001)) \
\}).store; \cf2 // store the synth def so it is added to the SynthDescLib\cf0 \
)\
\
\
~out = \\staub;\
~out = \cf5 \\staub\cf0 ; \cf2 // watching the synth count shows that the old synth is freed.\cf0 \
~out = 0;  	\cf2 // now out plays continuous stream of zero.\cf0 \
~out = \cf3 nil\cf0 ;	\cf2 // removes object and stops it.\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 \ul \ulc0 \
using patterns\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 \ulnone \
\cf2 // example\cf0 \
\
(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 SynthDef\cf0 (\cf4 "who"\cf0 , \{ \cf3 arg\cf0  amp=0.1, freq=440, detune=0, gate=1, out=0, ffreq=800;\
	\cf3 var\cf0  env;\
	env = \cf3 Env\cf0 .asr(0.01, amp, 0.5);\
	\cf3 Out\cf0 .ar(out, \cf3 Pan2\cf0 .ar(\
		\cf3 Formant\cf0 .ar(freq + detune, ffreq, 30, \cf3 EnvGen\cf0 .kr(env, gate, doneAction:2)), \cf3 Rand\cf0 (-1.0, 1.0))\
	)\
\}).store;\
\
)\
\
~out.play;\
\
\
~out = \cf3 Pbind\cf0 (\cf5 \\instrument\cf0 , \cf5 \\who\cf0 , \cf5 \\freq\cf0 , [600, 601], \cf5 \\ffreq\cf0 , 800, \cf5 \\legato\cf0 , 0.02);\
\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // embed a control node proxy into an event pattern:\cf0 \
\cf2 // this does not work for indirect assignment as \\degree, \\midinote, etc., \cf0 \
\cf2 // because there is calculations in the event! if needed, these can be done in the SynthDef.\cf0 \
\
~lfo = \{ \cf3 SinOsc\cf0 .kr(2, 0, 400, 700) \};\
~out = \cf3 Pbind\cf0 (\cf5 \\instrument\cf0 , \cf5 \\who\cf0 , \cf5 \\freq\cf0 , 500, \cf5 \\ffreq\cf0 , ~lfo, \cf5 \\legato\cf0 , 0.02);\
\
~lfo = \{ \cf3 SinOsc\cf0 .kr(\cf3 SinOsc\cf0 .kr(0.2, Rand(0,pi), 10, 10), 0, 400, 700) \};\
\
~lfo = \{ \cf3 LFNoise1\cf0 .kr(5, 1300, 1500) \};\
~lfo = \{ \cf3 MouseX\cf0 .kr(100, 5500, 1) \};\
\
(\
~out = \cf3 Pbind\cf0 (\
			\cf5 \\instrument\cf0 , \cf5 \\who\cf0 ,\
			\cf5 \\freq\cf0 , \cf3 Pseq\cf0 ([500, 380, 300],\cf3 inf\cf0 ),\
			\cf5 \\legato\cf0 , 0.1,\
			\cf5 \\ffreq\cf0 , \cf3 Pseq\cf0 ([~lfo, 100, ~lfo, 100, 300, 550], \cf3 inf\cf0 ), \cf2 // use it in a pattern\cf0 \
			\cf5 \\dur\cf0 , \cf3 Pseq\cf0 ([1, 0.5, 0.75, 0.125]*0.4, \cf3 inf\cf0 )\
		);\
)\
\
\cf2 // note that when you use a proxy within a non-event pattern it gets embedded as an object,\cf0 \
\cf2 // so this functionality is still standard\
\cf0 \
\cf2 // works only with control rate proxies. multichannel control rate proxies cause\cf0 \
\cf2 // multichannel expansion of the events:\
\cf0 \
~lfoStereo = \{ \cf3 LFNoise1\cf0 .kr([1, 1], 1300, 1500) \}; \cf2 // 2 channel control rate proxy\cf0 \
~out = \cf3 Pbind\cf0 (\cf5 \\instrument\cf0 , \cf5 \\who\cf0 , \cf5 \\freq\cf0 , 1500, \cf5 \\detune\cf0 , ~lfoStereo, \cf5 \\legato\cf0 , 0.02);\
~lfoStereo = \{ [\cf3 MouseX\cf0 .kr(100, 15500, 1), \cf3 SinOsc\cf0 .kr(\cf3 SinOsc\cf0 .kr(0.2, 0, 10, 10), 0, 400, 700)] \}\
\
\cf2 // btw: setting the clock will cause the pattern to sync:\cf0 \
p.clock = \cf3 TempoClock\cf0 .default;\
p.clock.tempo = 2.0;\
p.clock.tempo = 1.0\
\
\
\cf2 // patterns also crossfade, if an \\amp arg is defined in the synthdef:\
// (evaluate a couple of times)\cf0 \
~out.fadeTime = 3.0;\
(\
~out = \cf3 Pbind\cf0 (\
			\cf5 \\instrument\cf0 , \cf5 \\who\cf0 ,\
			\cf5 \\freq\cf0 , \cf3 Pshuf\cf0 ([500, 380, 200, 510, 390, 300, 300],\cf3 inf\cf0 ) * rrand(1.0, 2.0),\
			\cf5 \\legato\cf0 , 0.1,\
			\cf5 \\ffreq\cf0 , \cf3 Pshuf\cf0 ([~lfo, 100, ~lfo, 100, 300, 550], \cf3 inf\cf0 ),\
			\cf5 \\dur\cf0 , 0.125 * [1, 2, 3, 2/3].choose\
		);\
)\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 \ul using instruments and players
\f1\fs18 \ulnone \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // pause and resume do not work yet.\
\
\cf0 \
\cf2 // store an instrument\cf0 \
(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 Instr\cf0 (\cf5 \\test\cf0 , \
		\{ \cf3 arg\cf0  dens=520, ffreq=7000; \cf3 Ringz\cf0 .ar(\cf3 Dust\cf0 .ar(dens, [1,1]*0.1), ffreq, 0.02) \}\
		);\
)\
\
~out = \cf3 Patch\cf0 (\cf5 \\test\cf0 , [10, rrand(5000, 8000)]);\
~out.fadeTime = 3;\
\
\
(\
~out = \cf3 InstrSpawner\cf0 (\{ \cf3 arg\cf0  freq=1900,env,pan;\
	\cf3 Pan2\cf0 .ar(\cf3 SinOsc\cf0 .ar(freq, 0.5pi, 0.3) * \cf3 EnvGen\cf0 .kr(env, doneAction: 2), pan)\
\},[\
	\cf3 Prand\cf0 ([1500, 700, 800, 3000] + 170.rand2, \cf3 inf\cf0 ),\
	\cf3 Env\cf0 .perc(0.002,0.01),\
	\cf3 Prand\cf0 ([-1,1],\cf3 inf\cf0 )\
],0.125)\
)\
\
~out.clear;\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // does not work (yet).\cf0 \
\cf2 //~out.set(\\dens, 120);\cf0 \
\cf2 //~out.xset(\\dens, 1030); \cf0 \
\cf2 //~out.unmap(\\ffreq);\cf0 \
\cf2 //~out.set(\\ffreq, 500);\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs26 \cf0 \
\
___________________________________________________________________\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs32 \cf0 client side routines
\fs26 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 \ul spawning\ulnone  
\f3\fs26 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 \
~out.play;\
~out.awake = false; \cf2 // allow sound object assignment without immediate sending\cf0 \
\
\cf2 // putting an synthdef into the node proxy without playing it right away\cf0 \
\cf2 // the synthdef has an envelope that frees by itself.\cf0 \
(\
~out = \cf3 SynthDef\cf0 (\cf4 "a"\cf0 , \{ \cf3 arg\cf0  out=0, freq=800, pmf=1.0, pan;\
		\cf3 var\cf0  env, u;\
		env = \cf3 EnvGen\cf0 .kr(\cf3 Env\cf0 .perc(0.001, 0.04, 0.4),doneAction:2); \cf2 // envelope\cf0 \
		u = \cf3 SinOsc\cf0 .ar(freq * \cf3 Rand\cf0 (0.9, 1.1), \cf3 SinOsc\cf0 .ar(pmf, 0, pi), env);\
		\cf3 Out\cf0 .ar(out, \cf3 Pan2\cf0 .ar(u, pan))\
	\})\
);\
\
\
\cf2 // create a task to repeatedly send grains\cf0 \
(\
t = \cf3 Task\cf0 .new(\{\
	loop(\{\
		\cf2 // starts a synth with the current synthdef at index 0\cf0 \
		~out.spawn([\cf5 \\pmf\cf0 , [1, 20, 300].choose, \cf5 \\pan\cf0 , [0, -1, 1].choose]); \
		[0.1, 0.01, 0.25].choose.wait;\
	\})\
\});\
)\
\
t.start;\
t.stop;\
t.start;\
\
\cf2 // note: if you want to avoid using interpreter variables (single letter, like "t"),\cf0 \
\cf2 // you can use Tdef for this. (see Tdef.help)\cf0 \
\
\cf2 // set some argument\cf0 \
~out.set(\cf5 \\freq\cf0 , 300);\
~out.set(\cf5 \\freq\cf0 , 600);\
~out.map(\cf5 \\freq\cf0 , ~lfo);\
~lfo = \{ SinOsc.kr(0.1, 0, 3000, 4000) \};\
~lfo = \{ SinOsc.kr(0.1, 0, 600, 700) \};\
~lfo.add(\{ Trig.kr(Dust.kr(1), 0.1) * 3000 \});\
~lfo = 300;\
\
\cf2 // change the definition while going along\cf0 \
(\
~out = SynthDef("a", \{ \cf3 arg\cf0  out, freq=800;\
		\cf3 var\cf0  env;\
		env = \cf3 EnvGen\cf0 .kr(\cf3 Env\cf0 .perc(0.01, 0.1, 0.3),doneAction:2);\
		Out.ar(out, \cf3 Pulse\cf0 .ar(freq * \cf3 Rand\cf0 ([0.9,0.9], 1.1), 0.5, env) )\
	\});\
)\
\
\
t.stop;\
~out.awake = \cf3 true\cf0 ; \cf2 // don't forget this\cf0 \
\cf2 //  free all synths in this current ProxySpace\cf0 \
currentEnvironment.clear;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs26 \cf0 \
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 \ul granular synthesis: efficient code
\f3\fs26 \ulnone \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs24 \cf0 see also [jitlib_efficiency]
\f1\fs18 \
\
~out.play;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs26 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 (\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 SynthDef\cf0 (\cf4 "grain"\cf0 , \{ \cf3 arg\cf0  i_out = 0, pan;\
	\cf3 var\cf0  env;\
	env = \cf3 EnvGen\cf0 .kr(\cf3 Env\cf0 .perc(0.001, 0.003, 0.2),doneAction:2);\
	\cf3 Out\cf0 .ar(i_out, Pan2.ar(\cf3 FSinOsc\cf0 .ar(\cf3 Rand\cf0 (1000,10000)), pan) * env) \
\}).send(s);\
)
\f3\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 \
\cf2 // a target for the grains\cf0 \
~someInput.ar(2);  \cf2 // initialize to 2 channels audio\cf0 \
~out = ~someInput;\
\
(\
t = \cf3 Task\cf0 (\{\
	loop(\{\
		s.sendMsg(\cf4 "/s_new"\cf0 ,\cf4 "grain"\cf0 ,-1,0,0, \
			\cf5 \\i_out\cf0 , ~someInput.index, \cf2 // returns the bus index of the proxy\cf0 \
			\cf5 \\pan\cf0 , [1, 1, -1].choose * 0.2\
		);  \
		[0.01, 0.02].choose.wait;\
	\})\
\});\
)\
t.play;\
\
\cf2 // different filters;\
\
\cf0 ~out.fadeTime = 1.0;\
\
~out = \{ \cf3 BPF\cf0 .ar(~someInput.ar, \cf3 MouseX\cf0 .kr(100, 18000, \cf5 1\cf0 ), 0.1) \};\
\
~out = \{ \cf3 CombL\cf0 .ar(~someInput.ar * (\cf3 LFNoise0\cf0 .ar(2) > 0), 0.2, 0.2, \cf3 MouseX\cf0 .kr(0.1, 5, 1)) \};\
\
~out = \{ \cf3 RLPF\cf0 .ar(~someInput.ar, \cf3 LFNoise1\cf0 .kr(3, 1000, 1040), 0.05) \};\
\
\
t.stop;\
\
\
\
//_________\
\
~out.stop;\
currentEnvironment.clear;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 ProxySpace\cf0 .pop; \cf2 // restore original environment
\f3\fs26 \cf0 \
\
\
\
________________________________________________________________________\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 \ul using multiple proxyspaces\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \ulnone note that this can be done while the server is not running: with p.wakeUp or p.play\
the environment can be played back.\ul \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs26 \cf0 \ulnone \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf2 // quit server:\cf0 \
\
s.quit;\
\
\
\cf2 // create two proxyspaces without a running server\cf0 \
(\
p = \cf3 ProxySpace\cf0 (s);\
q = \cf3 ProxySpace\cf0 (s);\
\
p.use(\{\
	~out = \{ \cf3 Resonz\cf0 .ar(~in.ar, ~freq.kr, 0.01) \};\
	~in = \{ \cf3 WhiteNoise\cf0 .ar(0.5) \};\
	~freq = \{ \cf3 LFNoise2\cf0 .kr(1, 1000, 2000) \};\
\});\
\
q.use(\{\
	\
	~in = \{ \cf3 Dust\cf0 .ar(20, 0.1) \};\
	~out = \{ \cf3 Resonz\cf0 .ar(~in.ar * 450, ~freq.kr, 0.005) \};\
	~freq = \{ \cf3 LFNoise2\cf0 .kr(1, 400, 2000) \};\
\});\
)\
\
\cf2 // wait for the booted  server\cf0 \
s.boot;\
\
\cf2 // play the proxy at \\out\cf0 \
p.play(\cf5 \\out\cf0 ); \
q.play; \cf2 // out is the default output\
\cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 \ul external access\ulnone \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 \
\
q[\\in][1] = \{ Impulse.ar(2, 0, 0.5) \}; \cf2 // adding a synth at index 1\cf0 \
\
\cf2 // equivalent to\cf0 \
q.at(\\in).put(1, \{ Impulse.ar(7, 0, 0.5) \});\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 \ul \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 \ulnone \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 \ul connecting two spaces\ulnone  (must be on one server)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 \
\
(\
q.use(\{\
	~freq =  100 + p[\cf5 \\freq\cf0 ] / 2;\
\})\
)\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 \ul recording output\ulnone  (see also: [RecNodeProxy])
\f1\fs18 \
\
\
r = p.record(\cf5 \\out\cf0 , \cf4 "proxySpace.aiff"\cf0 );\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // start recording\cf0 \
r.unpause;\
\
\cf2 // pause recording\cf0 \
r.pause;\
\
\cf2 // stop recording\cf0 \
r.close;\
\
\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 \ul push/pop\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 \ulnone \
\
\cf2 // make x the currentEnvironment\cf0 \
p.push; \
\
~freq = 700;\
~freq = 400;\
~freq = \{ p.kr(\cf5 \\freq\cf0 ) + LFNoise1.kr(1, 200, 300) % 400 \}; // feedback\
~freq = 400;\
\
p.pop; \cf2 // restore environment\cf0 \
\
\
\cf2 // make y the currentEnvironment\cf0 \
q.push; \
\
~freq = 1000;\
~in = \{ \cf3 WhiteNoise\cf0 .ar(0.01) \};\
\
q.pop; \cf2 // restore environment\cf0 \
\
q.clear;\
p.clear;\
\
\
\
\
______________________________________________________________\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 \ul some more topics
\f1\fs18 \ulnone \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 nodeproxy with numbers as input:
\f1\fs18 \
\
p = \cf3 ProxySpace\cf0 .push(s.boot);\
\
\
~out = \{ \cf3 SinOsc\cf0 .ar(~a.kr * Rand(1, 2), 0, 0.1) \};\
~out.play;\
\
~a = 900;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // these add up:\cf0 \
~a[0] = 440;\
~a[1] = 220;\
~a[2] = 20;\
\
~a.fadeTime = 2;\
\
~a[0] = 300; \cf2 // now there is a crossfade.\cf0 \
~a[1] = \{ \cf3 SinOsc\cf0 .kr(5, 0, 20) \}; \
~a[2] = \{ \cf3 SinOsc\cf0 .kr(30, 0, 145) \};\
\
\
\
\cf2 // internally a numerical input is approximately replaced by:\cf0 \
\cf2 // (pseudocode)\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 SynthDef\cf0 (\cf4 "name"\cf0 , \{ \cf3 arg\cf0  out, fadeTime;\
	 \cf3 Out\cf0 .kr(out,\
	 	\cf3 Control\cf0 .kr(\cf3 Array\cf0 .fill(proxy.numChannels, \{ the number \})) \
	 		* \cf3 EnvGate\cf0 .new(fadeTime:fadeTime)\
	 ) \
\});\
\
\
\
\
\
}