{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fnil\fcharset77 Georgia-Bold;\f2\fswiss\fcharset77 Helvetica;
\f3\fnil\fcharset77 Monaco;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red191\green0\blue0;\red0\green115\blue0;
}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs30 \cf0 Timing in NodeProxy		
\f1\fs72 4
\f2\b0\fs24 \
\
Changes that happen to NodeProxy, most importantly setting its source, are normally done\
whenever the put method is called (or, in ProxySpace, the assignment operation = ).\
Sometimes it is desirable to time these changes relative to a clock.\
\
previous: [\ul jitlib_basic_concepts_03\ulnone ]		next: [\ul JITLib\ulnone ]\
\
\
a) clock\
b) quant and offset\
c) client and server tempo\
d) sample accurate output\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 a) clock
\f2\b0 \
\
generally, every node proxy can have its own time base, usually\
a tempo clock. the clock is responsible for the timing of insertion\
of new functions, per default at the next beat of the clock.
\f3\fs18 \
\
\
\
p = \cf2 ProxySpace\cf0 .push(s.boot);\
~x.play; ~y.play;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 // these two synths are started at the time when they are inserted:\cf0 \
~x = \{ \cf2 Ringz\cf0 .ar(\cf2 Impulse\cf0 .ar(1), 400, 0.05) \};\
~y = \{ \cf2 Ringz\cf0 .ar(\cf2 Impulse\cf0 .ar(1), 600, 0.05) \};\
\
\cf3 // adding a common clock:\cf0 \
~x.clock = \cf2 TempoClock\cf0 .default;\
~y.clock = \cf2 TempoClock\cf0 .default;\
\
\cf3 // now they are in sync\cf0 \
~x = \{ \cf2 Ringz\cf0 .ar(\cf2 Impulse\cf0 .ar(1), 400, 0.05) \};\
~y = \{ \cf2 Ringz\cf0 .ar(\cf2 Impulse\cf0 .ar(1), 600, 0.05) \};\
\
\cf3 // for simplicity, one can provide a clock for a whole proxy space:\cf0 \
\
p.clock = \cf2 TempoClock\cf0 .default;\
~y = \{ \cf2 Ringz\cf0 .ar(\cf2 Impulse\cf0 .ar(1), 800, 0.05) \};\
\
~z.play;\
~z = \{ \cf2 Ringz\cf0 .ar(\cf2 Impulse\cf0 .ar(1), [500, 514], 0.8) \};\
~z = \{ \cf2 Ringz\cf0 .ar(\cf2 Impulse\cf0 .ar(1), exprand(300, 400 ! 2), 0.8) \};\
~z = \{ \cf2 Ringz\cf0 .ar(\cf2 Impulse\cf0 .ar(2), exprand(300, 3400 ! 2), 0.08) \};\
~z.end;\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 sequence of events:
\f2\b0 \
When inserting a new function into the proxy, the synthdef is built, sent to the server\
who sends back a message when it has completed. Then the proxy waits for the next beat to start\
the synth. When using node proxies with patterns, the patterns are played using the clock as a scheduler.
\f3\fs18 \
\
\
\

\f0\b\fs24 b) quant and offset
\f2\b0 \
\
\
In order to be able to control the offset/quant point of insertion, the 'quant' instance variable can be used,\
which can be either a number or an array of the form [quant, offset], just like in pattern.play(quant).
\f3\fs18 \
\
~y.quant = [1, 0.3]; \cf3 // offset of 0.3, quant of 1.0\cf0 \
~y = \{ \cf2 Ringz\cf0 .ar(\cf2 Impulse\cf0 .ar(1), 600, 0.05) \};\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 quant and offset scheduling is used for the following operations:\
play, put, removeAt, setNodeMap, wakeUp, rebuild (and the rebuild operations lag, setRates, bus_)
\f3\fs18 \
\
\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 c) connecting client and server tempo
\f3\b0\fs18 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 a ProxySpace has the method makeTempoClock, which creates an instance of TempoBusClock\
together with a node proxy (~tempo) which it keeps in sync.
\f3\fs18 \
\
\
p.makeTempoClock(2.0); \cf3 // create a new tempoclock with 2 beats/sec\cf0 \
\
~y.quant = 1; \cf3 // set the quant back to 1 and the offset to 0\cf0 \
~y = \{ \cf2 Ringz\cf0 .ar(\cf2 Impulse\cf0 .ar(~tempo.kr), 600, 0.05) \}; \cf3 // impulse uses tempo\cf0 \
~x = \cf2 Pbind\cf0 (\cf4 \\instrument\cf0 , \cf4 \\default\cf0 , \cf4 \\freq\cf0 , \cf2 Pseq\cf0 ([300, 400], \cf2 inf\cf0 )); \cf3 // pattern uses tempoclock\cf0 \
\
p.clock.tempo = 1.0; \cf3 // set the tempo to 1\cf0 \
p.clock.tempo = 2.2; \cf3 // set the tempo to 2.2\cf0 \
\
~x.free;\
~y.free;\
\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 d) sample accurate output
\f2\b0 \
\
for efficiency, NodeProxy uses a normal Out UGen for writing to its bus. If sample accurate\
playback is needed (OffsetOut), the ProxySynthDef class variable sampleAccurate can be set to true:
\f3\fs18 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 \
// example\cf0 \
\
\cf2 ProxySynthDef\cf0 .sampleAccurate = \cf2 false\cf0 ;\
\
~x.play;\
\
\cf3 // the grain frees itself\cf0 \
~x = \{ \cf2 SinOsc\cf0 .ar(800) * \cf2 EnvGen\cf0 .ar(\cf2 Env\cf0 .perc(0.001, 0.03, 0.4), doneAction:2) \};\
\
	\
\cf3 // jittery tone.\cf0 \
(\
r = \cf2 Routine\cf0  \{\
	loop \{\
		200.do \{ \cf2 arg\cf0  i;\
			~x.spawn;\
			(0.005).wait;\
		\};\
		1.wait;\
	\}\
\}.play;\
)\
\
\cf2 ProxySynthDef\cf0 .sampleAccurate = \cf2 true\cf0 ;\
\
\cf3 // steady tone, because sample accurate.\cf0 \
\
~x.rebuild;\
\
r.stop;\
\
p.clear; \cf3 // remove all.	\cf0 \
\
\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 previous: [\ul jitlib_basic_concepts_03\ulnone ]
\f3\fs18 \
\
\
}