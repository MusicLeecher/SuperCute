{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fnil\fcharset77 Monaco;\f2\fswiss\fcharset77 Helvetica;
}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue191;\red0\green115\blue0;
\red96\green96\blue96;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 SubsampleOffset
\f1\b0\fs18 		
\f0\b\fs24 offset from synth start within one sample
\f1\b0\fs18 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 superclass: InfoUGenBase\
\
	\
	
\f0\b SubsampleOffset.ir
\f2\b0 \
\
\
When a synth is created from a time stamped osc-bundle, it starts calculation at the next possible block (normally 64 samples). Using an 
\f0\b OffsetOut
\f2\b0  ugen, one can delay the audio so that it matches sample accurately. \
For some synthesis methods, one needs subsample accuracy. 
\f0\b SubsampleOffset
\f2\b0  provides the information where, within the current sample, the synth was scheduled. It can be used to offset envelopes or resample the audio output.\
\
see also: [\ul OffsetOut\ulnone ]\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // example: demonstrate cubic subsample interpolation\cf0 \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 Server\cf0 .default = s = \cf3 Server\cf0 .internal; \cf2 // switch servers for scope\cf0 \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // impulse train that can be moved between samples\cf0 \
(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 SynthDef\cf0 (\cf4 \\Help_SubsampleOffset\cf0 , \{ \cf3 |out, addOffset|\cf0 \
	\cf3 var\cf0  in, dt, sampDur, extraSamples, sampleOffset, resampledSignal;\
	in = \cf3 Impulse\cf0 .ar(2000, 0, 0.3); \cf2 // some input.\cf0 \
	sampDur = \cf3 SampleDur\cf0 .ir; 	\cf2 // duration of one sample\cf0 \
	extraSamples = 4;			\cf2 // DelayC needs at least 4 samples buffer\cf0 \
	sampleOffset = 1 - \cf3 SubsampleOffset\cf0 .ir; \cf2 // balance out subsample offset\cf0 \
	sampleOffset = sampleOffset + \cf3 MouseX\cf0 .kr(0, addOffset); \cf2 // add a mouse dependent offset\cf0 \
	\cf2 // cubic resampling:\cf0 \
	resampledSignal = \cf3 DelayC\cf0 .ar(in, \
							maxdelaytime: sampDur * (1 + extraSamples),\
							delaytime: sampDur * (sampleOffset + extraSamples)\
					);\
	\cf3 OffsetOut\cf0 .ar(out, resampledSignal)\
\}).send(s);\
)\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // create 2 pulse trains 1 sample apart, move one relatively to the other.\
// when cursor is at the left, the impulses are adjacent, on the right, they are\
// exactly 1 sample apart.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 var\cf0  dt = s.sampleRate.reciprocal; \cf2 // 1 sample delay\cf0 \
s.sendBundle(0.2, [9, \cf4 \\Help_SubsampleOffset\cf0 , s.nextNodeID, 1, 1, \cf4 \\out\cf0 , 40, \cf4 \\addOffset\cf0 , 3]);\
s.sendBundle(0.2 + dt, [9, \cf4 \\Help_SubsampleOffset\cf0 , s.nextNodeID, 1, 1, \cf4 \\out\cf0 , 40, \cf4 \\addOffset\cf0 , 0]);\
)\
\
s.scope(1, 40, zoom: 0.2);\
\
\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // example of a subsample accurate sine grain:\
// (I don't hear a difference to normal sample accurate grains, but maybe\
// someone could add an example that shows the effect)\cf0 \
\
(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 SynthDef\cf0 (\cf5 "Help_Subsample_Grain"\cf0 , \
	\{ \cf3 arg\cf0  out=0, freq=440, sustain=0.005, attack=0.001;\
		\cf3 var\cf0  env, offset, sig, sd;\
		\
		sd = \cf3 SampleDur\cf0 .ir;\
		offset = (1 - \cf3 SubsampleOffset\cf0 .ir) * sd;\
		\cf2 // free synth after delay:\cf0 \
		\cf3 Line\cf0 .ar(1,0, attack + sustain + offset, doneAction:2); 		env = \cf3 EnvGen\cf0 .kr(\cf3 Env\cf0 .perc(attack, sustain, 0.2));\
		sig = \cf3 SinOsc\cf0 .ar(freq, 0, env);\
		\
		sig = \cf3 DelayC\cf0 .ar(sig, sd * 4, offset);\
		\cf3 OffsetOut\cf0 .ar(out, sig);\
	\}, [\cf4 \\ir\cf0 , \cf4 \\ir\cf0 , \cf4 \\ir\cf0 , \cf4 \\ir\cf0 ]).send(s);\
)\
\
(\
	\cf3 Routine\cf0  \{\
		loop \{\
			s.sendBundle(0.2, [9, \cf4 \\Help_Subsample_Grain\cf0 , -1, 1, 1, \cf4 \\freq\cf0 , 1000]);\
			rrand(0.001, 0.002).wait;\
		\}\
	\}.play;\
)\
\
\
}