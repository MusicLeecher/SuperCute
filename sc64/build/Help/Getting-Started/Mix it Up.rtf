{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red191\green0\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 Mix it Up
\fs28 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 \
We've already seen that multiplication changes the level of something, but what about mixing UGens together? This turns out to be equally simple. All we need is addition:\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 	\{ \cf2 PinkNoise\cf0 .ar(0.2) + \cf2 SinOsc\cf0 .ar(440, 0, 0.2) + \cf2 Saw\cf0 .ar(660, 0.2) \}.play;
\f1\fs24 \
\
Saw is another type of oscillator, with a waveform that looks like a sawtooth. Note that we use a low value for mul, thus ensuring that the final output will be between -1 and 1, and not clip.\
\
There's another handy class called Mix, which will mix an array of channels down to a single channel or an array of arrays of channels down to a single array of channels. Watch the post window to see Mix's results. \
\

\f2\fs18 	\cf3 // one channel\cf0 \
	\{ \cf2 Mix\cf0 .new([\cf2 SinOsc\cf0 .ar(440, 0, 0.2), \cf2 Saw\cf0 .ar(660, 0.2)]).postln \}.play;\
	\
	\cf3 // combine two stereo arrays\cf0 \
	(\
	\{ \
		\cf2 var\cf0  a, b;\
		a = [\cf2 SinOsc\cf0 .ar(440, 0, 0.2), \cf2 Saw\cf0 .ar(662, 0.2)];\
		b = [\cf2 SinOsc\cf0 .ar(442, 0, 0.2), \cf2 Saw\cf0 .ar(660, 0.2)];\
		\cf2 Mix\cf0 ([a, b]).postln;\
	\}.play;\
	)
\f1\fs24 \
\
In the first case we get a 'BinaryOpUGen' (in this case this means the two UGens added together), and in the second we get an Array of two BinaryOpUGens.\
\
Note that in the first example we use Mix.new(...), but in the second we use Mix(...). The latter is a shorthand for the former. 'new' is the most common class method for creating a new object. In some cases objects have more than one class method for creating objects, such as the 'ar' and 'kr' methods of UGens. (Mix, however, is actually  just a 'convenience' class, and doesn't actually create Mix objects, it just returns the results of its summing, either a BinaryOpUGen or an Array of them.)\
\
Mix also has another class method called fill, which takes two arguments. The first is a number, which determines how many times the second argument, a Function, will be evaluated. The results of the evaluations will be summed. Confusing? Take a look at the following example:\
\

\f2\fs18 	(\
		\cf2 var\cf0  n = 8;\
		\{ \cf2 Mix\cf0 .fill(n, \{ \cf2 SinOsc\cf0 .ar(500 + 500.0.rand, 0, 1 / n) \})  \}.play;\
	)\
	
\f1\fs24 \
The Function will be evaluated n times, each time creating a SinOsc with a random frequency from 500 to 1000 Hz (500 plus a random number between 0 and 500). The mul arg of each SinOsc is set to 1 / n, thus ensuring that the total amplitude will not go outside -1 and 1. By simply changing the value of n, you can have vastly different numbers of SinOscs! (Try it!) This sort of approach makes this code extremely flexible and reusable.\
\
Each time the Function is evaluated it is passed the number of times evaluated so far as an argument. So if 'n' is 8 the Function will be passed values from 0 to 7, in sequence, counting up. By declaring an argument within our Function we can use this value.\
\

\f2\fs18 	\cf3 // Look at the post window for frequencies and indices\cf0 \
	(\
		\cf2 var\cf0  n = 8;\
		\{ \
			\cf2 Mix\cf0 .fill(n, \{ \cf2 arg\cf0  index; \
				\cf2 var\cf0  freq;\
				index.postln;\
				freq = 440 + index;\
				freq.postln;\
				\cf2 SinOsc\cf0 .ar(freq , 0, 1 / n) \
			\})\
		\}.play;\
	)
\f1\fs24 \
\
By combining addition and multiplication (or indeed almost any mathematical procedure you could imagine!) with the use of classes like Mix, we have the tools we need to combine multichannel sources of sound into complex mixes and submixes.\
\
For more information see:
\f0\b  \
\
[\ul Mix\ulnone ] [\ul BinaryOpUGen\ulnone ] [\ul Operators\ulnone ] [\ul Syntax-Shortcuts\ulnone ]\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 Suggested Exercise:\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 Experiment with altering the Functions in the text above. For instance try changing the frequencies of the SinOsc, or making multi-channel versions of things.
\f0\b \

\f1\b0 \
____________________\
\
This document is part of the tutorial 
\f0\b Getting Started With SuperCollider
\f1\b0 .\
\
Click here to go on to the next section: 
\f0\b [\ul Scoping and Plotting\ulnone ]
\f1\b0 \
\
Click here to return to the table of Contents: 
\f0\b [\ul Getting Started With SC\ulnone ]\
}