{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
\f3\fswiss\fcharset77 Helvetica-Oblique;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red191\green0\blue0;\red96\green96\blue96;
\red0\green115\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural

\f0\b\fs36 \cf0 Busses
\fs28 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural

\f1\b0\fs24 \cf0 \
Now a little bit more about busses on the server. Busses are named after the busses or sends in analog mixing desks, and they serve a similar purpose: Routing signals from one place to another. In SC this means to or from the audio hardware, or between different synths. They come in two types: audio rate and control rate. As you've probably guessed, the former routes audio rate signals and the latter routes control rate signals.\
\
The control rate busses are fairly simple to understand, each one has an index number, starting from 0.\
\
Audio rate busses are similar, but require slightly more explanation. A server app will have a certain number of output and input channels. These correspond to the first audio busses, with outputs coming before inputs. \
\
For example, if we imagine a server with two output channels and two input channels (i.e. stereo in and out) then the first two audio busses (index 0 and index 1) will be the outputs, and the two immediately following those (index 2 and index 3) will be the inputs. Writing audio out to one of the output busses will result in sound being played from your speakers, and reading audio in from the input busses will get sound into SC for things like recording and processing (providing you have a source such as a microphone connected to your computer's or audio interface's inputs).\
\
The remaining audio busses will be 'private'. These are used simply to send audio and control signals between various synths. Sending audio to a private bus will not result in sound in your speakers unless you reroute it later to one of the output busses. These 'private' busses are often used for things like an 'effects send', i.e. something that requires further processing before it's output.\
\
The number of control and audio busses available, as well as the number of input and output channels is set at the time the server app is booted.(See 
\f0\b [\ul ServerOptions\ulnone ]
\f1\b0  for information on how to set the number of input and output channels, and busses.)\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural

\f0\b\fs28 \cf0 Writing to or Reading from Busses
\f1\b0\fs24 \
\
We've already seen Out.ar, which allows you to write (i.e. play out) audio to a bus. Recall that it has two arguments, an index, and an output, which can be an array of UGens (i.e. a multichannel output) or a single UGen.\
\
To read in from a bus you use another UGen: In. In's 'ar' method also takes two arguments: An index, and the number of channels to read in. If the number of channels is greater than one, than In's output will be an Array. Execute the following examples, and watch the post window:\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural

\f2\fs18 \cf0 \
	\cf2 In\cf0 .ar(0, 1); \cf3 // this will return 'an OutputProxy'\cf0 \
	\cf2 In\cf0 .ar(0, 4); \cf3 // this will return an Array of 4 OutputProxies
\f1\fs24 \cf0 \
\
An OutputProxy is a special kind of UGen that acts as a placeholder for some signal that will be present when the synth is running. You'll probably never need to deal with one directly, so don't worry about them, just understand what they are so that you'll recognise them when you see them in the post window and elsewhere.\
\
In and Out also have 'kr' methods, which will read and write control rate signals to and from control rate busses. Note that Out.kr will convert an audio rate signal to control rate (this is called 'downsampling'), but that the reverse is not true: Out.ar needs an audio rate signal as its second arg.\
\

\f2\fs18 	\cf3 // This throws an error. Can't write a control rate signal to an audio rate bus\cf0 \
	\{\cf2 Out\cf0 .ar(0, \cf2 SinOsc\cf0 .kr)\}.play;\
	\
	\cf3 // This will work as the audio rate signal is downsampled to control rate\cf0 \
	\cf2 Server\cf0 .internal.boot;\
	\{\cf2 Out\cf0 .kr(0, \cf2 SinOsc\cf0 .ar)\}.scope;	
\f1\fs24 \
\
(This limitation is not universal amongst audio rate UGens however, and most will accept control rate signals for some or all of their arguments. Some will even convert control rate inputs to audio rate if needed, filling in the extra values through a process called interpolation.)\
\
You'll note that when multiple Synths write to the same bus, there output is summed, or in other words, mixed.\
\

\f2\fs18 	(\
	\cf2 SynthDef\cf0 (\cf4 "tutorial-args"\cf0 , \{ \cf2 arg\cf0  freq = 440, out = 0; \
		\cf2 Out\cf0 .ar(out, \cf2 SinOsc\cf0 .ar(freq, 0, 0.2)); \
	\}).send(s);\
	)\
	\cf3 // both write to bus 1, and their output is mixed\cf0 \
	x = \cf2 Synth\cf0 (\cf4 "tutorial-args"\cf0 , [\cf4 "out"\cf0 , 1, \cf4 "freq"\cf0 , 660]);\
	y = \cf2 Synth\cf0 (\cf4 "tutorial-args"\cf0 , [\cf4 "out"\cf0 , 1, \cf4 "freq"\cf0 , 770]);
\f1\fs24 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural

\f0\b\fs28 \cf0 Creating a Bus Object
\f1\b0\fs24 \
\
There is a handy client-side object to represent server busses: Bus. Given that all you need is an In or Out Ugen and an index to write to a bus, you might wonder what one would need a full-fledged Bus object for. Well, much of the time you don't, particularly if all you're doing is playing audio in and out. But Bus does provide some useful functionality. We'll get to that in a second, but first lets look at how to make one.\
\
Just as many UGens have ar and kr methods, Bus has two commonly used creation methods: Bus-audio and Bus-control. These each take two arguments: a Server object, and the number of channels.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural

\f2\fs18 \cf0 	b = \cf2 Bus\cf0 .control(s, 2); \cf3 // Get a two channel control Bus\
	\cf0 c = \cf2 Bus\cf0 .audio(s); 		\cf3 // Get a one channel private audio Bus (one is the default)
\f1\fs24 \cf0 \
\
You may be wondering what a 'two channel' bus is, since we haven't mentioned these before. You should recall that when Out has an Array as its second argument it will write the channels of the Array to consecutive busses. Recall this example from 
\f0\b [\ul SynthDefs and Synths\ulnone ]
\f1\b0 :\

\f2\fs18 	\
	(\
	\cf2 SynthDef\cf0 .new(\cf4 "tutorial-SinOsc-stereo"\cf0 , \{ \cf2 var\cf0  outArray;\
		outArray = [\cf2 SinOsc\cf0 .ar(440, 0, 0.2), \cf2 SinOsc\cf0 .ar(442, 0, 0.2)];\
		\cf2 Out\cf0 .ar(0, outArray); \cf3 // writes to busses 0 and 1 \cf0 \
	\}).play;\
	)\
	
\f1\fs24 \
The truth is that there aren't multichannel busses per se, but Bus objects are able to represent a series of busses with consecutive indices. The 
\f3\i encapsulate
\f1\i0  several adjacent sever-side busses into a single Bus object, allowing you to treat them as a group. This turns out to be rather handy.\
\
When you're working with so-called 'private' busses (i.e. anything besides the input and output channels; all control busses are private) you generally want to make sure that that bus is only used for exactly what you want. The point after all is to keep things separate. You could do this by carefully considering which indices to use, but Bus allows for this to be done automatically. Each Server object has a bus allocator, and when you make a Bus object, it reserves those private indices, and will not give them out again until freed. You can find out the index of a Bus by using its 'index' method.\
\

\f2\fs18 	s.reboot; \cf3 // this will restart the server app and thus reset the bus allocators\cf0 \
	\
	b = \cf2 Bus\cf0 .control(s, 2);	\cf3 // a 2 channel control Bus\cf0 \
	b.index; 				\cf3 // this should be zero\cf0 \
	b.numChannels 		\cf3 // Bus also has a numChannels method\cf0 \
	c = \cf2 Bus\cf0 .control(s);	\
	c.numChannels;		\cf3 // the default number of channels is 1\cf0 \
	c.index;				\cf3 // note that this is 2; b uses 0 and 1\cf0 \
	
\f1\fs24 \
So by using Bus objects to represent adjacent busses, you can guarantee that there won't be a conflict. Since the indices are allocated dyamically, you can change the number of channels of a Bus in your code (for instance because you now need to route a multichannel signal), and you're still guaranteed to be safe. If you were simply 'hard allocating' busses by using index numbers, you might have to adjust them all to make room for an extra adjacent channel, since the indices need to be consecutive! This is a good example of the power of objects: By encapsulating things like index allocation, and providing a 
\f3\i layer of abstraction
\f1\i0 , they can make your code more flexible.\
\
You can free up the indices used by a Bus by calling its 'free' method. This allows them to be reallocated.\
\

\f2\fs18 	b = \cf2 Bus\cf0 .control(s, 2);\
	b.free; \cf3 // free the indices. You can't use this Bus object after that\cf0  \
	
\f1\fs24 \
Note that this doesn't actually make the bus on the server go away, it's still there. 'free' just lets the allocator know that you're done using this bus for the moment, and it can freely reallocate its index.\
\
Now here's another advantage when working with private audio rate busses. As we said above, the first few busses are the output and input channels. So if we want to use the first private bus, all we need to do is add those together, right? Consider our server app with 2 output and 2 input channels. The first private audio bus is index 4. (0, 1, 2, 3 ... 4!) So we write our code, and give the appropriate Out UGen 4 as its index arg. \
\
But what happens if we later decide to change the number of output channels to 6? Now everything that was written to our private bus is going out one of the output channels! A Server's audio bus allocator will only assign private indices, so if you change the number of input or output channels it will take this into account when you execute your code. Again this makes your code more flexible.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 Busses in Action\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural

\f1\b0\fs24 \cf0 \
So here are two examples using busses. The first is with a control rate bus.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 	(\
	\cf2 SynthDef\cf0 (\cf4 "tutorial-Infreq"\cf0 , \{ \cf2 arg\cf0  bus, freqOffset = 0;\
		\cf3 // this will add freqOffset to whatever is read in from the bus\cf0 \
		\cf2 Out\cf0 .ar(0, \cf2 SinOsc\cf0 .ar(\cf2 In\cf0 .kr(bus) + freqOffset, 0, 0.5));\
	\}).send(s);\
	\
	\cf2 SynthDef\cf0 (\cf4 "tutorial-Outfreq"\cf0 , \{ \cf2 arg\cf0  freq = 400, bus;\
		\cf2 Out\cf0 .kr(bus, \cf2 SinOsc\cf0 .kr(1, 0, freq/40, freq));\
	\}).send(s);\
	\
	b = \cf2 Bus\cf0 .control(s,1);\
	)\
	\
	(\
	x = \cf2 Synth\cf0 .new(\cf4 "tutorial-Outfreq"\cf0 , [\cf5 \\bus\cf0 , b.index]);\
	y = \cf2 Synth\cf0 .after(x, \cf4 "tutorial-Infreq"\cf0 , [\cf5 \\bus\cf0 , b.index]);\
	z = \cf2 Synth\cf0 .after(x, \cf4 "tutorial-Infreq"\cf0 , [\cf5 \\bus\cf0 , b.index, \\freqOffset, 200]);\
	)\
	x.free; y.free; z.free; b.free;
\f0\b\fs28 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural

\f1\b0\fs24 \cf0 \
Both y and z read from the same bus, the latter just modifies the frequency control signal by adding a constant value of 200 to it. This is more efficient than having two separate control oscillators to control frequency. This sort of strategy of connecting together synths, each of which does different things in a larger process, can be very effective in SC.\
\
Now an example with an audio bus. This is the most complicated example we've seen so far, but should give you some idea of how to start putting all the things we've learned together. The code below will use two Synths as sources, one creating pulses of PinkNoise (a kind of Noise which has less energy at high frequencies than at low), and another creating pulses of Sine Waves. The pulses are created using the UGens 
\f0\b [\ul Impulse\ulnone ] 
\f1\b0 and 
\f0\b [\ul Decay2\ulnone ]
\f1\b0 . These are then reverberated using a chain of 
\f0\b [\ul AllpassC\ulnone ]
\f1\b0 , which is a kind of delay.\
\
Note the construction 16.do(\{ ... \}), below. This makes the chain by evaluating the function 16 times. This is a very powerful and flexible technique, as by simply changing the number, I can change the number of evaluations. See 
\f0\b [\ul Integer\ulnone ] 
\f1\b0 for more info on Integer-do.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 	(\
	\cf3 // the arg direct will control the proportion of direct to processed signal\cf0 \
	\cf2 SynthDef\cf0 (\cf4 "tutorial-DecayPink"\cf0 , \{ \cf2 arg\cf0  outBus = 0, effectBus, direct = 0.5;\
		\cf2 var\cf0  source;\
		\cf3 // Decaying pulses of PinkNoise. We'll add reverb later.\cf0 \
		source = \cf2 Decay2\cf0 .ar(\cf2 Impulse\cf0 .ar(1, 0.25), 0.01, 0.2, \cf2 PinkNoise\cf0 .ar);\
		\cf3 // this will be our main output\cf0 \
		\cf2 Out\cf0 .ar(outBus, source * direct);\
		\cf3 // this will be our effects output\cf0 \
		\cf2 Out\cf0 .ar(effectBus, source * (1 - direct));\
	\}).send(s);\
	\
	\cf2 SynthDef\cf0 (\cf4 "tutorial-DecaySin"\cf0 , \{ \cf2 arg\cf0  outBus = 0, effectBus, direct = 0.5;\
		\cf2 var\cf0  source;\
		\cf3 // Decaying pulses of a modulating Sine wave. We'll add reverb later.\cf0 \
		source = \cf2 Decay2\cf0 .ar(\cf2 Impulse\cf0 .ar(0.3, 0.25), 0.3, 1, \cf2 SinOsc\cf0 .ar(\cf2 SinOsc\cf0 .kr(0.2, 0, 110, 440)));\
		\cf3 // this will be our main output\cf0 \
		\cf2 Out\cf0 .ar(outBus, source * direct);\
		\cf3 // this will be our effects output\cf0 \
		\cf2 Out\cf0 .ar(effectBus, source * (1 - direct));\
	\}).send(s);\
	\
	\cf2 SynthDef\cf0 (\cf4 "tutorial-Reverb"\cf0 , \{ \cf2 arg\cf0  outBus = 0, inBus;\
		\cf2 var\cf0  input;\
		input = \cf2 In\cf0 .ar(inBus, 1);\
		\
		\cf3 // a low rent reverb\cf0 \
		\cf3 // aNumber.do will evaluate it's function argument a corresponding number of times\cf0 \
		\cf3 // \{\}.dup(n) will evaluate the function n times, and return an Array of the results\cf0 \
		\cf3 // The default for n is 2, so this makes a stereo reverb\cf0 \
		16.do(\{ input = \cf2 AllpassC\cf0 .ar(input, 0.04, \{ \cf2 Rand\cf0 (0.001,0.04) \}.dup, 3)\});\
		\
		\cf2 Out\cf0 .ar(outBus, input);\
	\}).send(s);\
	\
	b = \cf2 Bus\cf0 .audio(s,1); \cf3 // this will be our effects bus\cf0 \
	)\
	\
	(\
	x = \cf2 Synth\cf0 .new(\cf4 "tutorial-Reverb"\cf0 , [\cf5 \\inBus\cf0 , b.index]);\
	y = \cf2 Synth\cf0 .before(x, \cf4 "tutorial-DecayPink"\cf0 , [\cf5 \\effectBus\cf0 , b.index]);\
	z = \cf2 Synth\cf0 .before(x, \cf4 "tutorial-DecaySin"\cf0 , [\cf5 \\effectBus\cf0 , b.index, \cf5 \\outBus\cf0 , 1]);\
	)\cf4 \
	\
	\cf3 // Change the balance of wet to dry\cf4 \
\cf0 	y.set(\cf5 \\direct\cf0 , 1); \cf3 // only direct PinkNoise\cf0 \
	z.set(\cf5 \\direct\cf0 , 1); \cf3 // only direct Sine wave\cf0 \
	y.set(\cf5 \\direct\cf0 , 0); \cf3 // only reverberated PinkNoise\cf0 \
	z.set(\cf5 \\direct\cf0 , 0); \cf3 // only reverberated Sine wave\cf0 \
	x.free; y.free; z.free; b.free;
\f0\b\fs28 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural

\f1\b0\fs24 \cf0 Note that we could easily have many more source synths being processed by the single reverb synth. If we'd built the reverb into the source synths we'd be duplicating effort. But by using a private bus, we're able to be more efficient.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural

\f0\b\fs28 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 More Fun with Control Busses
\f1\b0\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural
\cf0 \
There are some other powerful things that you can do with control rate busses. For instance, you can map any arg in a running synth to read from a control bus. This means you don't need an In UGen. You can also write constant values to control busses using Bus' 'set' method, and poll values using its 'get' method. \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural

\f2\fs18 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural
\cf0 	(\
	\cf3 // make two control rate busses and set their values to 880 and 884. \cf0 \
	b = \cf2 Bus\cf0 .control(s, 1); b.set(880);\
	c = \cf2 Bus\cf0 .control(s, 1);	c.set(884);\
	\cf3 // and make a synth with two frequency arguments\cf0 \
	x = \cf2 SynthDef\cf0 (\cf4 "tutorial-map"\cf0 , \{ \cf2 arg\cf0  freq1 = 440, freq2 = 440; \
		\cf2 Out\cf0 .ar(0, \cf2 SinOsc\cf0 .ar([freq1, freq2], 0, 0.1));\
	\}).play(s);\
	)\
	\cf3 // Now map freq1 and freq2 to read from the two busses\cf0 \
	x.map(\cf5 \\freq1\cf0 , b.index, \cf5 \\freq2\cf0 , c.index);\
	\
	\cf3 // Now make a Synth to write to the one of the busses\cf0 \
	y = \{\cf2 Out\cf0 .kr(b.index, \cf2 SinOsc\cf0 .kr(1, 0, 50, 880))\}.play(addAction: \cf5 \\addToHead\cf0 );\
\
	\cf3 // free y, and b holds its last value\cf0 \
	y.free;\
	\
	\cf3 // use Bus-get to see what the value is. Watch the post window\cf0 \
	b.get(\{ \cf2 arg\cf0  val; val.postln; f = val; \});\
	\
	\cf3 // set the freq2, this 'unmaps' it from c\cf0 \
	x.set(\cf5 \\freq2\cf0 , f / 2);\
	\
	\cf3 // freq2 is no longer mapped, so setting c to a different value has no effect\cf0 \
	c.set(200);\
	\
	x.free; b.free; c.free;
\f1\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural
\cf0 \
Note that unlike audio rate busses, control rate busses hold their last value until something new is written. \
\
Also note that Bus-get takes a Function (called an action function) as an argument. This is because it takes a small amount of time for the server to get the reply and send it back. The function, which is passed the value (or Array of values in the case of a multichannel bus) as an argument, allows you to do something with the value once its come back.\
\
This concept of things taking a small amount of time to respond (usually called 
\f3\i latency
\f1\i0 ) is quite important to understand. There are a number of other methods in SC which function this way, and it can cause you problems if you're not careful. To illustrate this consider the example below.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural

\f2\fs18 \cf0 	\cf3 // make a Bus object and set its values \cf0 \
	b = \cf2 Bus\cf0 .control(s, 1); b.set(880);\
	\
	\cf3 // execute this altogether\cf0 \
	(\
	f = \cf2 nil\cf0 ; \cf3 // just to be sure\cf0 \
	b.get(\{ \cf2 arg\cf0  val; f = val; \});\
	f.postln;\
	)\
	\
	\cf3 // f equals nil, but try it again and it's as we expected!\cf0 \
	f.postln;
\f1\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural
\cf0 \
So why was f nil the first time but not the second time? The part of the language app which executes your code (called the 
\f3\i interpreter
\f1\i0 ), does what you tell it, as fast as it can, when you tell it to. So in the block of code between the parentheses above it sends the 'get' message to the server, schedules the Function to execute when a reply is received, and then moves on to posting f. Since it hasn't received the reply yet f is still nil when it's posted the first time.\
\
It only takes a tiny amount of time for the server to send a reply, so by the time we get around to executing the last line of code f has been set to 880, as we expected. In the previous example this wasn't a problem, as we were only executing a line at a time. But there will be cases where you will need to execute things as a block, and the action function technique is very useful for that.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 Getting it all in the Right Order
\f1\b0\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7260\ql\qnatural
\cf0 \
In the examples above, you may have wondered about things like Synth.after, and addAction: \\addToHead. During each cycle (the period in which a block of samples is calculated) the server calculates things in a particular order, according to its list of running synths.\
\
It starts with the first synth in its list, and calculates a block of samples for its first UGen. It then takes that and calculates a block of samples for each of its remaining UGens in turn (any of which may take the output of an earlier UGen as an input.) This synth's output is written to a bus or busses, as the case may be. The server then moves on to the next synth in its list, and the process repeats, until all running synths have calculated a block of samples. At this point the server can move on to the next cycle.\
\
The important thing to understand is that 
\f3\i as a general rule
\f1\i0 , when you are connecting synths together using busses it is important that synths which write signals to busses are earlier in the server's order than synths which read those signals from those busses. For instance in the audio bus example above it was important that the 'reverb' synth is calculated 
\f3\i after
\f1\i0  the noise and sine wave synths that it processes.\
\
This is a complicated topic, and there are some exceptions to this, but you should be aware that ordering is crucial when interconnecting synths. The file 
\f0\b [\ul Order-of-execution\ulnone ] 
\f1\b0 covers this topic in greater detail.\
\
Synth-new has two arguments which allow you to specify where in the order a synth is added. The first is a 
\f3\i target
\f1\i0 , and the second is an 
\f3\i addAction
\f1\i0 . The latter specifies the new synth's position in relation to the target.\
\
	
\f2\fs18 x = \cf2 Synth\cf0 (\cf4 "default"\cf0 , [\cf5 \\freq\cf0 , 300]);\
	\cf3 // add a second synth immediately after x\cf0 \
	y = \cf2 Synth\cf0 (\cf4 "default"\cf0 , [\cf5 \\freq\cf0 , 450], x, \cf5 \\addAfter\cf0 );\
	x.free; y.free;
\f1\fs24 \
\
A target can be another Synth (or some other things; more on that soon), and an addAction is a symbol. See 
\f0\b [\ul Synth\ulnone ]
\f1\b0  for a complete list of possible addActions.\
\
Methods like Synth-after are simply convenient ways of doing the same thing, the difference being that they take a target as their first argument.\
\
	
\f2\fs18 \cf3 // These two lines of code are equivalent\cf0 \
	y = \cf2 Synth\cf0 .new(\cf4 "default"\cf0 , [\cf5 \\freq\cf0 , 450], x, \cf5 \\addAfter\cf0 );
\f1\fs24 \
	
\f2\fs18 y = \cf2 Synth\cf0 .after(x, \cf4 "default"\cf0 , [\cf5 \\freq\cf0 , 450]);
\f1\fs24 \
\
For more information see:
\f0\b  \
\
[\ul Bus\ulnone ] [\ul In\ulnone ] [\ul OutputProxy\ulnone ] [\ul Order-of-execution\ulnone ] [\ul Synth\ulnone ]\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs28 \cf0 Suggested Exercise:\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 Experiment with interconnecting different synths using audio and control busses. When doing so be mindful of their ordering on the server.
\f0\b \

\f1\b0 \
____________________\
\
This document is part of the tutorial 
\f0\b Getting Started With SuperCollider
\f1\b0 .\
\
Click here to go on to the next section: 
\f0\b [\ul Groups\ulnone ]
\f1\b0 \
\
Click here to return to the table of Contents: 
\f0\b [\ul Getting Started With SC\ulnone ]}