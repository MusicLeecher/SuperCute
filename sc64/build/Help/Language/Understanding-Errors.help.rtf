{\rtf1\mac\ansicpg10000\cocoartf824\cocoasubrtf330
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
\f3\fswiss\fcharset77 Helvetica-Oblique;}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue191;\red96\green96\blue96;
\red191\green0\blue0;\red0\green0\blue0;\red0\green0\blue191;\red0\green115\blue0;}
\pard\tx1440\tx2880\tx4320\tx5760\tx7200\ql\qnatural

\f0\b\fs40 \cf0 Understanding errors 
\f1\b0\fs24 \
\

\f0\b 1. Reading error dumps\
2. Error objects and error handling\
3. Common primitive errors\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 4. A common network error\
\pard\tx1440\tx2880\tx4320\tx5760\tx7200\ql\qnatural
\cf0 5. A common warning\

\f1\b0 \

\f0\b\fs32 1. Reading error dumps \

\f1\b0\fs24 \
When sc3 reports an error to the user, there are usually three parts: \
\
- the error text\
- a dump of the receiver of the method that caused the error, and/or any arguments of the method call\
- a dump of the call stack to the point of the error \
\
For example:\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 1.blech  \cf2 // no class implements this method; therefore you'll get an error\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 \
// error text\cf0 \
ERROR: Message 'blech' not understood.\
\cf2 // receiver and args\cf0 \
RECEIVER:\
   Integer 1\
ARGS:\
Instance of Array \{    (02207560, gc=01, fmt=01, flg=11, set=00)\
  indexed slots [0]\
\}\
\cf2 // call stack\cf0 \
CALL STACK:\
	DoesNotUnderstandError-reportError\
		arg this = <instance of DoesNotUnderstandError>\
	Nil-handleError\
		arg this = nil\
		arg error = <instance of DoesNotUnderstandError>\
	Object-throw\
		arg this = <instance of DoesNotUnderstandError>\
	Object-doesNotUnderstand\
		arg this = 1\
		arg selector = 'blech'\
		arg args = [*0]\
	< closed FunctionDef >  (no arguments or variables)\
	Interpreter-interpretPrintCmdLine\
		arg this = <instance of Interpreter>\
		var res = nil\
		var func = <instance of Function>\
	Process-interpretPrintCmdLine\
		arg this = <instance of Main>
\f1\fs24 \
\pard\tx1440\tx2880\tx4320\tx5760\tx7200\ql\qnatural
\cf0 \
Each of these parts provides valuable information about the cause of the error. Debugging is much easier if you understand what the error output means. \
\

\f0\b Error text:
\f1\b0  A string describing the error. In this case, "Message 'xxx' not understood" means that you attempted to use the method xxx on a class that does not implement it. \
\

\f0\b Receiver and arguments:
\f1\b0  The method was applied to an integer (1), with no arguments (the size of the arguments array is 0). \
\

\f0\b Call stack:
\f1\b0  Order of execution in the call stack is in reverse: the top of the stack shows the most recent calls. \
\
Most call stacks for errors will show the same top three calls as shown here (calling the method reportError on an error class, calling handleError on Nil, and calling throw on the error object). You can ignore these three calls. \
\
Following is the meat: the error happened when an object was not understood. Continuing to read down, it happened inside a function definition. (Every time you highlight a block of code and press the enter key, the code is compiled into a function definition and executed. So, this function definition simply refers to the text submitted to the interpreter.) And, it all began with the instruction to interpret and print a command line. \
\
Here is a slightly more complex example, showing how you can use the variables listed for each call in the call stack to help locate the error.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf3 Routine\cf0 (\{\
	\cf3 var\cf0  a;\
	a = 5;\
	loop \{\
		\cf3 var\cf0  b;\
		b = 20.rand;\
		b.postln.ecky_ecky_phtang;   \cf2 // "NI!!!!"\cf0 \
		a.wait;\
	\}\
\}).play;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 ERROR: Message 'ecky_ecky_phtang' not understood.\
RECEIVER:\
   Integer 6\
ARGS:\
Instance of Array \{    (02207560, gc=01, fmt=01, flg=11, set=00)\
  indexed slots [0]\
\}\
CALL STACK:\
	DoesNotUnderstandError-reportError\
		arg this = <instance of DoesNotUnderstandError>\
	Nil-handleError\
		arg this = nil\
		arg error = <instance of DoesNotUnderstandError>\
	Object-throw\
		arg this = <instance of DoesNotUnderstandError>\
	Object-doesNotUnderstand\
		arg this = 6\
		arg selector = 'ecky_ecky_phtang'\
		arg args = [*0]\
	< FunctionDef in closed FunctionDef >\
		var b = 6\
	Function-loop\
		arg this = <instance of Function>\
	< FunctionDef in closed FunctionDef >\
		var a = 5\
	Routine-prStart\
		arg this = <instance of Routine>\
		arg inval = 1542.075067\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 Reading from the bottom this time, to trace the flow in chronological order: this time, execution did not begin with the command line, but with a routine commencing within the scheduler (Routine(\{...\}).play). Note that there are two calls identified as "FunctionDef in closed FunctionDef" and that they can be distinguished by the variables contained within. The earlier call (second from the bottom) defines the variable "a" while the other defines "b." To locate the error in the code, then, you should look for a function defining the variable "b" that is 
\f3\i called
\f1\i0  within another function defining "a" inside a routine. \
\
What if the error occurred not inside a function definition that you wrote, but inside a method in the class library? There may be a bug in the method, or you may have thought the method took a certain kind of argument when in fact it expects something else. \
\
If you double click on the construction "ClassName-methodName" in the call stack, the whole thing is selected. Then you can press cmd-J to open the method definition and look at the source code.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs32 \cf0 2. Error objects and error handling 
\f1\b0\fs24 \
\
sc3 implements error reporting using Error objects, which are instances of the class Error or one of its subclasses. Any code (whether in the class library or any user application) can throw an error any time as follows: \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf3 Error\cf0 (\cf4 "This is a basic error."\cf0 ).throw; \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
You can also catch exceptions that occur within functions by executing the function with "try" or "protect" instead of "value."\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 try -
\f1\b0  execute the first function. On an error, execute the second function and suppress the error. The second function can rethrow the error if desired, allowing you to decide which errors will be reported and which suppressed. In this example, we do not rethrow the error, so the error is swallowed and execution continues to the end.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 try \{ 1.blech \} \{ \cf3 |error|\cf0  \cf4 "oops"\cf0 .postln \};\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 "next line"\cf0 .postln;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 oops\
next line\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 protect -
\f1\b0  executes the first function. On an error, execute the second function before reporting the error. This is useful when the steps before the protect make some changes that need to be undone if an error occurs. See the method Environment-use for an example.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 protect \{ 1.blech \} \{ \cf3 |error|\cf0  \cf4 "oops"\cf0 .postln \};\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 "next line"\cf0 .postln;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 oops  \cf2 // without protect, this would not be posted\cf0 \
ERROR: Message 'blech' not understood.\
RECEIVER:\
   Integer 1\
ARGS:\
Instance of Array \{    (02207560, gc=01, fmt=01, flg=11, set=00)\
  indexed slots [0]\
\}\
CALL STACK:\
	DoesNotUnderstandError-reportError\
		arg this = <instance of DoesNotUnderstandError>\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\
Prior to August 2004, try and protect do not return the value of the function to the caller if there is no error.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 try \{ 1+1 \}\
\
a Function\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
More recent builds (since early August 2004) do return the function's value. Non-error objects can be thrown using the class 
\f0\b Exception
\f1\b0 .\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 try \{ 1+1 \}\
2
\f1\fs24 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf2 // can't add a Point to an integer - binary op failed error\cf0 \
\cf2 // result of catch func is returned instead\cf0 \
try \{ 1+\cf3 Point\cf0 (0, 0) \} \{ 2*5 \}\
10\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs32 \cf0 3. Common primitive errors \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 - operation cannot be called from this Process. \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 \
This is usually the results of performing a GUI operation within a routine or scheduled function that is executing on some clock other than AppClock. AppClock is the only clock that can execute GUI manipulation because it is a lower priority thread. If the CPU is busy with audio synthesis or maintaining accurate scheduling for musical events, AppClock events will be delayed until the CPU is free enough. \
\
Solution: write your GUI updates as follows. 
\f0\b defer
\f1\b0  schedules the function on AppClock.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 \{ myGUIObject.value_(newValue) \}.defer; \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 - Attempted write to immutable object. \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 #[0, 1, 2].put(1, 3)\
\
ERROR: Primitive '_BasicPut' failed.\
Attempted write to immutable object.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
#[0, 1, 2] is a literal array. Literal arrays cannot be manipulated--they can only be indexed. They cannot be changed internally. \
\
Solution: copy the array first.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 #[0, 1, 2].copy.put(1, 3)\
\
[ 0, 3, 2 ] \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 - Index not an Integer.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 #[0, 1, 2].at(\\1)\
\
ERROR: Primitive '_BasicAt' failed.\
Index not an Integer\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
Arrays can be indexed only with integers (or, in builds since August 2004, floats).\
\
Solution: use .asInteger\'d1note that if the object cannot be converted into an integer, you'll get a "Does not understand" error!\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 #[0, 1, 2].at(\\1.asInteger)\
1\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 - Index out of range.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 [0, 1, 2].put(5, 5)\
\
ERROR: Primitive '_BasicPut' failed.\
Index out of range.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
Arrays have a finite size. If you try to put an object into an array slot but the slot does not exist because the array is too small, you'll get this error. \
\
Solution: extend the array.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 [0, 1, 2].extend(6).put(5, 5)\
\
[ 0, 1, 2, nil, nil, 5 ]\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 Note that if the argument to extend() is smaller than the array, then the array will be truncated. If you're not sure, use max:
\f2\fs18 \
\
i = rrand(5, 10);\
a = [0, 1, 2];\
a.extend(max(i+1, a.size)).put(i, 100);\

\f1\fs24 \
Why i+1? An array with size 4 allows 0, 1, 2 and 3 as indexes (4 elements starting with 0).\
\
If it's a new array, use .newClear instead of .new.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 a = \cf3 Array\cf0 .new(4);\
a.put(3, 1);\
ERROR: Primitive '_BasicPut' failed.\
Index out of range.\
\
a = \cf3 Array\cf0 .newClear(4);\
a.put(3, 1);\
[ nil, nil, nil, 1 ]\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs32 \cf0 4. A common network error
\f2\b0\fs18 \
\
\
Exception in World_OpenUDP: unable to bind udp socket
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
This is because you have multiple servers running, left over from crashes, unexpected quits etc.\
One can't cause them to quit via OSC (the boot button).
\f2\fs18 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf5 // use this to remove them:\cf6 \
\cf7 Server\cf6 .killAll \cf0 
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs32 \cf0 5. A common warning\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 WARNING: FunctionDef contains variable declarations and so will not be inlined.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 \
\pard\tx1440\tx2880\tx4320\tx5760\tx7200\ql\qnatural
\cf0 This warning can be safely ignored. Your code will still run, even if you get this warning. \
\
Inlining is a compiler optimization that takes the operations inside a function and places them in the main line of the containing function. For instance, \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf2 // inlined\cf0 \
\{ while \{ 0.9.coin \} \{ 10.rand.postln \}\
\}.def.dumpByteCodes;\
\pard\tx1440\tx2880\tx4320\tx5760\tx7200\ql\qnatural

\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 BYTECODES: (16)\
  0   40       PushLiteral Float 0.9   3FECCCCC CCCCCCCD  \cf2 // \{ 0.9.coin \}\cf0 \
  1   0D 2C    SendSpecialUnaryArithMsgX 'coin'\
  3   F9 00 09 JumpIfFalsePushNil 9  (15)\
  6   2C 0A    PushInt 10							  \cf2 // \{ 10.rand.postln \}\cf0 \
  8   0D 25    SendSpecialUnaryArithMsgX 'rand'\
 10   C1 38    SendSpecialMsg 'postln'\
 12   FD 00 0D JumpBak 13  (0)\
 15   F2       BlockReturn\
a FunctionDef in closed FunctionDef
\f1\fs24 \
\pard\tx1440\tx2880\tx4320\tx5760\tx7200\ql\qnatural
\cf0 \
This function contains two other functions. One is the condition for the while loop; the other is the while loop's action. The compiler renders this into a single code block, using jump instructions to handle the looping and exit. \
\
If, however, one of the functions defines a variable, then that function requires a separate execution frame. In this case, it's necessary for the compiler to push function definition objects onto the stack. \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf2 // not inlined\cf0 \
\{ while \{ 0.9.coin \} \{\
    \cf3 var\cf0  a;	\cf2 // variable here prevents optimization\cf0 \
    a = 10.rand;\
    a.postln\
  \}\
\}.def.dumpByteCodes;\
\pard\tx1440\tx2880\tx4320\tx5760\tx7200\ql\qnatural

\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 BYTECODES: (7)\
  0   04 00    PushLiteralX instance of FunctionDef in closed FunctionDef\
  2   04 01    PushLiteralX instance of FunctionDef in closed FunctionDef\
  4   C2 0C    SendSpecialMsg 'while'\
  6   F2       BlockReturn\
a FunctionDef in closed FunctionDef
\f1\fs24 \
\pard\tx1440\tx2880\tx4320\tx5760\tx7200\ql\qnatural
\cf0 \
Inlined code will run faster, because pushing and using different execution frames is extra work for the virtual machine. If you're very concerned about speed, you can use this warning as an indicator that you might be able to optimize something in your code further. \
\
Sometimes, there's no way around un-optimized code. To wit, \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf2 // inlined, optimized, but you'll get stuck notes\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 Routine\cf0 (\{\
  \cf3 var\cf0  synth;\
  \{ synth = \cf3 Synth\cf0 (\cf4 "someSynth"\cf0 , [...args...]);\
    \cf3 thisThread\cf0 .clock.sched(10, \{\
      synth.free;\
    \});\
    2.wait;\
  \}.loop;\
\}).play;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // not inlined, but no stuck notes\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 Routine\cf0 (\{\
  \{ \cf3 var\cf0  synth;\
    synth = \cf3 Synth\cf0 (\cf4 "someSynth"\cf0 , [...args...]);\
    \cf3 thisThread\cf0 .clock.sched(10, \{\
      synth.free;\
    \});\
    2.wait;\
  \}.loop;\
\}).play;
\f1\fs24 \
\pard\tx1440\tx2880\tx4320\tx5760\tx7200\ql\qnatural
\cf0 \
The first routine can be optimized because there is no variable declaration inside the loop. But, the synth variable changes on each iteration, meaning that by the time the first release happens, you don't have access anymore to the first note. Thus the first note will never terminate. \
\
In the second case, each note has its own synth variable, so the notes will be terminated as expected. You get a warning, but it's better because the results are correct.\
\
\
A solution to the above problem is to use a function with local variables. \
\
\pard\tx1440\tx2880\tx4320\tx5760\tx7200\ql\qnatural

\f2\fs18 \cf0 (\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 Routine\cf0 (\{\
	\cf3 var\cf0  func;\
	func = \{ \
		\cf3 var\cf0  synth; \cf2 // this variable is local to the function\cf0 \
    		synth = \cf3 Synth\cf0 (\cf4 "default"\cf0 );\
    		[\cf8 \\play\cf0 , synth].postln;\
    		\cf3 thisThread\cf0 .clock.sched(4.5, \{ \
    			synth.free;\
    			[\cf8 \\free\cf0 , synth].postln;  \
    		\});\
    	\};\
    	\{ func.value; 1.wait; \}.loop\
\}).play;\
)\
\pard\tx1440\tx2880\tx4320\tx5760\tx7200\ql\qnatural

\f1\fs24 \cf0 \
}