{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fnil\fcharset77 Monaco;}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue191;\red96\green96\blue96;
\red0\green115\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 Routines and clocks
\f1\b0\fs18 \
\
Use clocks to create automated, algorithmic scheduling. Among the things that clocks "play" are routines, tasks, and patterns. \
\
To see how a clock "plays" a routine, first examine how a function works in a routine.\
\
The first argument (and usually the only argument) to a routine is a function.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // template for a routine\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 Routine\cf0 (\{ \cf4 ".... code within curly braces is a function .... "\cf0 \});\
\
A .yield message to an expression in a function (in a routine) returns a value.\
\
r = \cf3 Routine\cf0 (\{ \cf4 "hello, world"\cf0 .yield.postln \});\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // to evaluate a routine, send a .next message\
// it will "hand over" the value of the expression to which the .yield message is attached\cf0 \
r.next;\
\
Evaluate (again)\
\
r.next;\
\
The routine above returns nil when its evaluated a second time. This is because once a routine "yields" and if there's no additional code after the .yield message, the routine is finished, over, and done - unless it receives a reset message. Then it can start over again.\
\
r.next;		\cf2 // returns nil\cf0 \
r.reset;		\cf2 // reset the routine\cf0 \
r.next;		\cf2 // it works!\cf0 \
\
\cf2 ////////////////////////////////////////////////////////////////////////////////////////////////////\cf0 \
\
(\
r = \cf3 Routine\cf0 (\{ \
	\cf4 "hello, world"\cf0 .yield;\
	\cf4 "what a world"\cf0 .yield;\
	\cf4 "i am a world"\cf0 .yield;\
\});\
)\
\
The first three .next messages return a string. The fourth .next message returns nil.\
\
r.next;	\cf2 // returns a string\cf0 \
r.next;	\cf2 // returns a string\cf0 \
r.next;	\cf2 // returns a string\cf0 \
r.next;	\cf2 // returns nil\cf0 \
\
Reset the routine.\
\
r.reset;\
\
r.next;\
r.next;\
r.next;\
r.next;\
\
\cf2 ////////////////////////////////////////////////////////////////////////////////////////////////////\cf0 \
\
Use a .do message in a routine to make a loop.\
\
(\
r = \cf3 Routine\cf0 (\{ \
\
	\cf2 // setup code\cf0 \
	\cf3 var\cf0  array;\
	array = [ \cf4 "hello, world"\cf0 , \cf4 "what a world"\cf0 , \cf4 "i am a world"\cf0  ];\
\
	\cf2 // the loop\cf0 \
	3.do(\{ array.choose.yield \})\
	\
\});\
)\
\
Evaluate the routine one more time than the loop in the routine allows. \
\
4.do(\{ r.next.postln \});\
\
The routine returned three strings followed by nil.\
\
\cf2 ////////////////////////////////////////////////////////////////////////////////////////////////////\cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 Scheduling routines
\f1\b0\fs18 \
\
Rewrite the routine so that it includes a .wait message.\
\
(\
r = \cf3 Routine\cf0 (\{ \
\
	\cf3 var\cf0  array;\
	array = [ \cf4 "hello, world"\cf0 , \cf4 "what a world"\cf0 , \cf4 "i am a world"\cf0  ];\
\
	3.do(\{ \
		1.wait; 				\cf2 // pause for 1 second\cf0 \
		array.choose.postln; \
	\})\
	\
\});\
)\
\
Then "play" the routine, eg, send it a .play message.\
\
r.play\
\
Append a .reset message to the routine so that it can start over. \
\
r.reset.play;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 ////////////////////////////////////////////////////////////////////////////////////////////////////\cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 Clocks and the convenience of .play
\f1\b0\fs18 \
\
When a routine receives a .play message, control (of the routine) is redirected to a clock. The clock uses the receiver of the .wait message as a unit of time to schedule ("play") the routine.\
\
SuperCollider has three clocks, each of which has a help file.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 SystemClock\cf0 					\cf2 // the most accurate\cf0 \
\cf3 AppClock\cf0 						\cf2 // for use with GUIs\cf0 \
\cf3 TempoClock\cf0 					\cf2 // to schedule in beats\cf0 \
\
The .play message is a convenience that allows one to write\
\
r.reset.play;				\cf2 // reset the routine before playing it\cf0 \
\
instead of \
\
\cf3 SystemClock\cf0 .play(r)	\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 ////////////////////////////////////////////////////////////////////////////////////////////////////\cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 Scheduling synths with routines\
\

\f1\b0\fs18 Enclose synths within routines. It's often the case that the synthdef used by the synth in routines should have an envelope with a doneAction parameter set to 2 (to deallocate the memory needed for the synth after its envelope has finished playing).\
\
(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // DEFINE A SYNTHDEF\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 SynthDef\cf0 (\cf4 "fm2"\cf0 , \{ \
	\cf3 arg\cf0  bus = 0, freq = 440, carPartial = 1, modPartial = 1, index = 3, mul = 0.2, ts = 1;\
\
	\cf2 // index values usually are between 0 and 24\cf0 \
	\cf2 // carPartial :: modPartial => car/mod ratio\cf0 \
	\
	\cf3 var\cf0  mod;\
	\cf3 var\cf0  car;\
	\
	mod = \cf3 SinOsc\cf0 .ar(\
		freq * modPartial, \
		0, \
		freq * index * \cf3 LFNoise1\cf0 .kr(5.reciprocal).abs\
	);\
		\
	car = \cf3 SinOsc\cf0 .ar(\
		(freq * carPartial) + mod, \
		0, \
		mul\
	);\
	\
	\cf3 Out\cf0 .ar(\
		bus,\
		car * \cf3 EnvGen\cf0 .kr(\cf3 Env\cf0 .sine(1), doneAction: 2, timeScale: ts)\
	)\
\}).load(s);\
)\
\
(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // DEFINE A ROUTINE\cf0 \
r = \cf3 Routine\cf0 (\{\
\
	12.do(\{\
		\cf3 Synth\cf0 (\
			\cf4 "fm2"\cf0 , \
			[\
				\\bus, 2.rand, \cf5 \\freq\cf0 , 400.0.rrand(1200), \
				\cf5 \\carPartial\cf0 , 0.5.rrand(2), \cf5 \\ts\cf0 , 0.5.rrand(11)\
			]\
		);\
		s.queryAllNodes;\
		"".postln.postln.postln.postln.postln;\
		2.wait;\
	\})\
\});\
)\
\
\cf2 // PLAY THE ROUTINE\cf0 \
r.reset.play;\
\
\cf2 ////////////////////////////////////////////////////////////////////////////////////////////////////\cf0 \
\
Process synths spawned in a routine through effects that run outside of the routine. \
\
(\
\cf2 // DEFINE A SYNTHDEF\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 SynthDef\cf0 (\cf4 "echoplex"\cf0 , \{\
	\cf3 ReplaceOut\cf0 .ar(\
		0,\
		\cf3 CombN\cf0 .ar(\
			\cf3 In\cf0 .ar(0, 1),\
			0.35,\
			[\cf3 Rand\cf0 (0.05, 0.3), \cf3 Rand\cf0 (0.05, 0.3)], \
			\cf2 // generate random values every time a synth is created\cf0 \
			7,\
			0.5\
		)\
	)\
\}).load(s);\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // DEFINE GROUPS TO CONTROL ORDER-OF-EXECUTION\
// attach a ~source group to the head of the rootnode and \cf0 \
\cf2 // an ~effects group to the tail of the rootenode\cf0 \
~source = \cf3 Group\cf0 .head(s);\
~effect = \cf3 Group\cf0 .tail(s);\
\
\cf2 // DEFINE A ROUTINE\cf0 \
r = \cf3 Routine\cf0 (\{\
\
	\cf2 // loop is the same as inf.do, eg, create an infinite loop that runs forever\cf0 \
	loop(\{\
		\cf3 Synth\cf0 .head(	\cf2 // attach the synth to the head of the ~source group\cf0 \
			~source,\
			\cf4 "fm2"\cf0 , \
			[\
				\cf5 \\outbus\cf0 , 0, \cf5 \\freq\cf0 , 400.0.rrand(1200), \cf5 \\modPartial\cf0 , 0.3.rrand(2.0),\
				\cf5 \\carPartial\cf0 , 0.5.rrand(11), \cf5 \\ts\cf0 , 0.1.rrand(0.2)]\
		);\
		s.queryAllNodes;\
		2.wait;\
	\})\
\});\
\
\cf2 // TURN ON EFFECTS\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 Synth\cf0 .head(~effect, \cf4 "echoplex"\cf0 );\
\cf3 Synth\cf0 .tail(~effect, \cf4 "echoplex"\cf0 );\
)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // PLAY THE ROUTINE\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 r.reset.play;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 ////////////////////////////////////////////////////////////////////////////////////////////////////\
}