{\rtf1\mac\ansicpg10000\cocoartf824\cocoasubrtf410
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fnil\fcharset77 Monaco;\f2\fswiss\fcharset77 Helvetica;
\f3\fnil\fcharset77 LucidaGrande;}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue191;\red96\green96\blue96;
\red0\green115\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 SCView
\f1\b0\fs18 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7280\tx7840\ql\qnatural

\f0\b\fs24 \cf0 superclass: Object\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tx7280\tx7840\ql\qnatural

\f2\b0 \cf0 \
SCView is the abstract superclass for all SC GUI widgets. Currently this system is OSX only. On Linux there is another GUI implementation, SCUM, which has its own documentation. Several key methods and variables are defined in SCView and inherited in its subclasses.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf0 \

\f0\b\fs24 resize_(int)\
\

\f2\b0 This setting controls how the widget will behave when it's window or enclosing view is resized. This is illustrated graphically below:
\f0\b\fs28 \

\f1\b0\fs18 \

\f2\fs24 		1  2  3\
		4  5  6\
		7  8  9\
		\
		1 - fixed to left, fixed to top\
		2 - horizontally elastic, fixed to top\
		3 - fixed to right, fixed to top\
		\
		4 - fixed to left, vertically elastic\
		5 - horizontally elastic, vertically elastic\
		6 - fixed to right, vertically elastic\
		\
		7 - fixed to left, fixed to bottom\
		8 - horizontally elastic, fixed to bottom\
		9 - fixed to right, fixed to bottom
\f1\fs18 \
\

\f0\b\fs24 resize\
\

\f2\b0 Return an Integer corresponding to the current resize behaviour (see above).\

\f1\fs18 \

\f0\b\fs24 keyDownAction_(aFunction)
\f2\b0 \
\
Register a 
\f0\b Function
\f2\b0  to be evaluated when a keystroke is received and this view is in focus.\

\f1\fs18 \
(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // select the slider, type something and watch the post window\cf0 \
	w = \cf3 SCWindow\cf0 .new;\
	c = \cf3 SCSlider\cf0 (w,\cf3 Rect\cf0 (0,0,100,30));\
	c.keyDownAction = \{ \cf3 arg\cf0  view,char,modifiers,unicode,keycode;\
		[char,modifiers,unicode,keycode].postln;\
	\};\
	w.front;\
)\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 If you return nil from your function, or you have no function registered, the event will bubble up to the parent view which may then respond.  It will continue to bubble up unless something responds or it hits the topView of the window.  You may register a function in the window's topView to respond to all unhandled events for the window.\

\f1\fs18 \

\f2\fs24 There are default keyDownActions for some views, which will be overridden when you set a keydown action.\
\
When called, the function will be passed the following arguments:\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-560\ql\qnatural

\f0\b \cf0 view -
\f2\b0  The receiving instance of SCView.\
\

\f0\b char - 
\f2\b0 The character pressed, possibly unprintable.  Character sequences (for example \'8e) get passed as two characters, the first one blank ( ), the second one is the unmodified character (e).  This will also vary depending on the nationality the keyboard is set to.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-560\ql\qnatural

\f1\fs18 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-560\ql\qnatural

\f0\b\fs24 \cf0 modifiers - 
\f2\b0 An integer bit field indicating the modifier keys in effect. You can examine individual flag settings using the C bitwise AND operator.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-560\ql\qnatural

\fs20 \cf0 	\
	65536 NSAlphaShiftKeyMask \
	Set if Caps Lock key is pressed. \
	\
	131072 NSShiftKeyMask \
	Set if Shift key is pressed. \
	\
	262144 NSControlKeyMask \
	Set if Control key is pressed. \
	\
	524288 NSAlternateKeyMask \
	Set if Option or Alternate key is pressed. \
	\
	1048576 NSCommandKeyMask \
	Set if Command key is pressed. \
	\
	2097152 NSNumericPadKeyMask \
	Set if any key in the numeric keypad is pressed. The numeric keypad is generally on the right side of the keyboard. \
	\
	4194304 NSHelpKeyMask \
	Set if the Help key is pressed. \
	\
	8388608 NSFunctionKeyMask \
	Set if any function key is pressed. The function keys include the F keys at the top of most keyboards (F1, F2, and so on) and the navigation keys in the center of most keyboards (Help, Forward Delete, Home, End, Page Up, Page Down, and the arrow keys). \
	\
	arrow keys have an extra modifier value of 
\fs18 10485760\
	so for a shift arrow key do a bitwise 'or' with the shift mask:\
		10485760 | 131072
\fs20 \
	= 
\fs18 10616832 // this is the mask for shift arrow key\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-560\ql\qnatural

\f0\b\fs24 \cf0 unicode - 
\f2\b0 The unicode integer, identical to the char.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-560\ql\qnatural

\f3\fs20 \cf0 	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-560\ql\qnatural

\f0\b\fs24 \cf0 keycode - 
\f2\b0 The hardware dependent keycode indicating the physical key.  This will vary from machine to machine, but is useful for building musical interfaces using the computer keyboard.  In order to play little melodies, this code will identify which key you consider to be special.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-560\ql\qnatural

\f1\fs18 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-560\ql\qnatural

\f0\b\fs24 \cf0 N.B.:
\f2\b0  Function key modifier may change the keycode.\
\
For various reasons these don't make it through cocoa:\
	most command modifiers\
	 cntl-tab\
	 cntl-escape\
	 tab and shift tab are currently trapped by SC itself for cycling the focus through the views.\
	 	(we could change this)
\f1\fs18 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \

\f0\b\fs24 keyDownAction\
\

\f2\b0 Return the current keyDownAction function for this view if there is one, otherwise return nil.
\f1\fs18 \
\

\f0\b\fs24 *globalKeyDownAction_(func)
\fs28 \

\f2\b0\fs24 \
A function that is evaluated for every keyDown event on every SCView. See 
\f0\b keyDownAction_
\f2\b0  for details.
\f1\fs18 \
\

\f0\b\fs24 focus\
\

\f2\b0 Brings this view into focus.\

\f1\fs18 \
(\
	w = \cf3 SCWindow\cf0 .new;\
	c = \cf3 SCSlider\cf0 (w,\cf3 Rect\cf0 (0,0,100,30));\
	d = \cf3 SCSlider\cf0 (w,\cf3 Rect\cf0 (0,30,100,30));\
	w.front;\
)\
\
	c.focus;\
	d.focus;\
	w.close;\
\

\f0\b\fs24 refresh\
\

\f2\b0 Under certain circumstances a view will not automatically update its appearance. This forces a redraw.\

\f1\fs18 \
(\
	w = \cf3 SCWindow\cf0 .new;\
	c = \cf3 SCButton\cf0 (w,\cf3 Rect\cf0 (0,0,100,30));\
	c.states = [[\cf4 "a"\cf0 ,\cf3 Color\cf0 .black,\cf3 Color\cf0 .red]];\
	d = \cf3 SCButton\cf0 (w,\cf3 Rect\cf0 (0,30,100,30));\
	d.states = [[\cf4 "a"\cf0 ,\cf3 Color\cf0 .black,\cf3 Color\cf0 .red]];\
	w.front;\
)\
\
	\cf2 // won't display change...\
\cf0 	c.states = [[\cf4 "b"\cf0 ,\cf3 Color\cf0 .red,\cf3 Color\cf0 .black]];\
	d.states = [[\cf4 "b"\cf0 ,\cf3 Color\cf0 .red,\cf3 Color\cf0 .black]];\
	\
	\cf2 //until\
\cf0 	c.refresh;\
	\
	\cf2 //needs separate refresh\
\cf0 	d.refresh;\
	\
	\cf2 // in some cases might be better to refresh the whole window\
\cf0 	\cf2 // which does refresh on all damaged areas (it keeps track, doesn't redraw whole thing)\
\cf0 	\
	c.states = [[\cf4 "a"\cf0 ,\cf3 Color\cf0 .black,\cf3 Color\cf0 .red]];\
	w.refresh;\
	w.close;\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\f0\b\fs24 \cf0 addAction(func, selector)\
removeAction(func, selector)\
		func:
\f2\b0  a function to be evaluated when action happens
\f0\b \
		selector: 
\f2\b0 what function to add to (default: slider action)
\f0\b \
\

\f1\b0\fs18 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
	(\
		w = \cf3 SCWindow\cf0 (\cf4 "add action test"\cf0 );\
		c = \cf3 SCSlider\cf0 (w,\cf3 Rect\cf0 (170, 50, 30, 270));\
		w.front;\
	)\
	\
	\
	u = \{ \cf3 |x|\cf0  x.value.postln \};\
	v = \{ \cf3 |x|\cf0  x.value.round(1).value.postln \};\
	\
	c.addAction(u); \cf2 // slider posts value\cf0 \
	\
	c.addAction(v); \cf2 // slider posts value and rounded value\cf0 \
	\
	c.removeAction(u); \cf2 // slider posts rounded value only\cf0 \
	\
	c.removeAction(v); \cf2 // slider posts nothing\cf0 \
	\
	c.action; \cf2 // nil again\cf0 \
	\
	c.addAction(u, \cf5 \\mouseDownAction\cf0 ); \cf2 // slider posts value on mouse down\cf0 \
	\
	c.mouseDownAction.postln; \cf2 // a function\cf0 \
	\
	c.addAction(v, \cf5 \\mouseDownAction\cf0 ); \cf2 // slider posts rounded value on mouse down\cf0 \
	\
	c.mouseDownAction.postln; \cf2 // a function list\cf0 \
	\
	c.removeAction(u, \cf5 \\mouseDownAction\cf0 );\
	\
	c.mouseDownAction.postln; \cf2 // a function \cf0 \
	\
	c.removeAction(v, \cf5 \\mouseDownAction\cf0 );\
	\
	c.mouseDownAction.postln; \cf2 // nil again\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural
\cf0 \
	w = c = u = v = nil;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 	\
	\

\f0\b\fs24 drag and drop\

\f2\b0 \
Each view subclass has a default object that it exports when dragged from.  For sliders its the value of the slider, for lists it is the currently selected numeric index etc.  \
\
By setting the beginDragAction handler you can return a different object based on the context and your application.\
\

\f0\b beginDragAction(theView)
\f2\b0  - return the object you wish your view to export by dragging\

\f1\fs18 	aView.beginDragAction =  \{ \cf3 arg\cf0  theView;  someList[ theView.value ]  \}\

\f2\fs24 	\
The current dragged thing can be found in the classvar SCView.currentDrag.  Objects dragged from within \
SuperCollider are also in SCView.currentDragString as a compile string.  Text dragged\
from other applications is in SCView.currentDragString and the results of attempting to\
compile that as sc code is in SCView.currentDrag\
\
Each view subclass has a defaultCanReceiveDrag method that determines if the current object being dragged is possible for this view to accept, and a defaultReceiveDrag method for actually receiving the drag.  Sliders accept numbers, simple text labels do not accept drags etc.  After receiving the drag, the SCView.currentDrag is set to nil.\
\
By setting the canReceiveDragHandler and receiveDragHandler you can make any view accept and receive objects based on the context and your application.  (Note: currently not possible for SCStaticText)\
\

\f0\b canReceiveDrag(theView)
\f2\b0  - return true/false if you are willing to accept the current drag.\

\f1\fs18 	aView.canReceiveDrag = \cf3 false\cf0 ; \cf2 // no, leave me alone\cf0 \
	aView.canReceiveDrag = \{ \cf3 SCView\cf0 .currentDrag.isString \};\

\f2\fs24 	\

\f0\b receiveDrag(theView)
\f2\b0  - accept the drag.\

\f1\fs18 	aView.receiveDrag = \{ \
		\cf3 SCView\cf0 .currentDrag.postln;\
	\}\

\f2\fs24 \
\
The default drag object from a list view is the currently selected integer index.\
Here a list view is made to export a string.\

\f1\fs18 (\
	f = \cf3 SCWindow\cf0 .new.front;\
	a = \cf3 SCListView\cf0 (f,100@100);\
	a.items = [\cf4 "eh?"\cf0 ,\cf4 "bee!"\cf0 ,\cf4 "sea."\cf0 ];\
	a.beginDragAction = \{ arg listView;\
		listView.items[ listView.value ].debug("begun dragging");\
	\};\
	\
	c = nil;\
	b = SCButton(f,Rect(0,200,200,20));\
	b.states = [["Drop stuff on me"]];\
	b.canReceiveDragHandler = \{ SCView.currentDrag.isString \};\
	b.receiveDragHandler = \{ \
		b.states = [[SCView.currentDrag]];\
		c = SCView.currentDrag;\
	\};\
	b.action = \{\
		c.postln\
	\};\
	\
)\

\f2\fs24 \
}