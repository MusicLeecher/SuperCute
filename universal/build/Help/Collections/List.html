<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<title></title>
<meta name="Generator" content="Cocoa HTML Writer">
<meta name="CocoaVersion" content="824.42">
<style type="text/css">
p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 18.0px Helvetica}
p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; min-height: 14.0px}
p.p3 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica}
p.p4 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco}
p.p5 {margin: 0.0px 0.0px 0.0px 0.0px; font: 14.0px Helvetica}
p.p6 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #a71e12}
p.p7 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Monaco; min-height: 16.0px}
p.p8 {margin: 0.0px 0.0px 0.0px 0.0px; font: 10.0px Monaco; min-height: 14.0px}
p.p9 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; min-height: 12.0px}
p.p10 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; color: #0019b7; min-height: 14.0px}
span.s1 {color: #0019b7}
span.s2 {text-decoration: underline}
span.s3 {color: #606060}
span.s4 {color: #000000}
span.s5 {color: #326f17}
span.Apple-tab-span {white-space:pre}
</style>
</head>
<body>
<p class="p1"><b>List</b></p>
<p class="p2"><br></p>
<p class="p3"><b>Superclass: SequenceableCollection</b></p>
<p class="p2"><br></p>
<p class="p3">List is a subclass of <b>SequenceableCollection</b> with unlimited growth in size. Although not a subclass of <b>Array</b> or its superclass <b>ArrayedCollection </b>it uses an Array in its implementation and is in many cases interchangeable with one. (List implements many of the same methods.)<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p3">Arrays have a fixed maximum size. If you add beyond that size a new Array is created and returned, but you must use an assignment statement or the new array will be lost. (See the <b>Array </b>helpfile.) List has no size limitation and is thus more flexible, but has slightly more overhead.</p>
<p class="p2"><br></p>
<p class="p4">(</p>
<p class="p4">x = <span class="s1">Array</span>.new(3);<span class="Apple-converted-space"> </span></p>
<p class="p4">y = <span class="s1">List</span>.new(3);<span class="Apple-converted-space"> </span></p>
<p class="p4">5.do({<span class="s1">arg</span> i; z = x.add(i); y.add(i);});<span class="Apple-converted-space"> </span></p>
<p class="p4">x.postln; z.postln; y.postln;</p>
<p class="p4">)</p>
<p class="p2"><br></p>
<p class="p3">Many of List's methods are inherited from <b>SequenceableCollection </b>or <b>Collection </b>and are documented in those helpfiles.</p>
<p class="p2"><br></p>
<p class="p5"><b><span class="s2">Creation</span></b></p>
<p class="p2"><br></p>
<p class="p3"><b>*new(size)</b></p>
<p class="p2"><br></p>
<p class="p3">Creates a List with the initial capacity given by <b>size</b>.</p>
<p class="p2"><br></p>
<p class="p3"><b>*newClear(size)</b></p>
<p class="p2"><br></p>
<p class="p3">Creates a List with the initial capacity given by <b>size</b> and slots filled with nil.</p>
<p class="p2"><br></p>
<p class="p3"><b>*copyInstance(aList)</b></p>
<p class="p2"><br></p>
<p class="p3">Creates a List by copying <b>aList's</b> array variable.</p>
<p class="p2"><br></p>
<p class="p3"><b>*newUsing(anArray)</b></p>
<p class="p2"><br></p>
<p class="p3">Creates a List using <b>anArray</b>.</p>
<p class="p2"><br></p>
<p class="p5"><b><span class="s2">Instance Methods</span></b></p>
<p class="p2"><br></p>
<p class="p3"><b>asArray</b></p>
<p class="p2"><br></p>
<p class="p3">Returns a new <b>Array</b> based upon this List.</p>
<p class="p2"><br></p>
<p class="p3"><b>array</b></p>
<p class="p2"><br></p>
<p class="p3">Returns the List's Array, allowing it to be manipulated directly. This should only be necessary for exotic manipulations not implemented in List or its superclasses.</p>
<p class="p2"><br></p>
<p class="p4">(</p>
<p class="p4">x = <span class="s1">List</span>[1, 2, 3];</p>
<p class="p4">x.array.add(<span class="s3">"foo"</span>);</p>
<p class="p4">x.postln;</p>
<p class="p4">)</p>
<p class="p2"><br></p>
<p class="p3"><b>array_(anArray)</b></p>
<p class="p2"><br></p>
<p class="p3">Sets the List's Array.</p>
<p class="p2"><br></p>
<p class="p3"><b>at(index)</b></p>
<p class="p2"><br></p>
<p class="p3">Return the <b>item</b> at <b>index</b>.</p>
<p class="p2"><br></p>
<p class="p4">List[ 1, 2, 3 ].at(0).postln;</p>
<p class="p2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p3"><b>clipAt(index)</b></p>
<p class="p2"><br></p>
<p class="p3">Same as <b>at</b>, but values for <b>index</b> greater than the size of the List will be clipped to the last index.</p>
<p class="p2"><br></p>
<p class="p4">y = List[ 1, 2, 3 ];</p>
<p class="p4">y.clipAt(13).postln;</p>
<p class="p2"><span class="Apple-converted-space"> </span></p>
<p class="p3"><b>wrapAt(index)</b></p>
<p class="p2"><br></p>
<p class="p3">Same as <b>at</b>, but values for <b>index</b> greater than the size of the List will be wrapped around to 0.</p>
<p class="p2"><br></p>
<p class="p4">y = List[ 1, 2, 3 ];</p>
<p class="p6"><span class="s4">y.wrapAt(3).postln; </span>// this returns the value at index 0</p>
<p class="p6"><span class="s4">y.wrapAt(4).postln; </span>// this returns the value at index 1</p>
<p class="p2"><br></p>
<p class="p3"><b>foldAt(index)</b></p>
<p class="p2"><br></p>
<p class="p3">Same as <b>at</b>, but values for <b>index</b> greater than the size of the List will be folded back.</p>
<p class="p2"><br></p>
<p class="p4">y = List[ 1, 2, 3 ];</p>
<p class="p6"><span class="s4">y.foldAt(3).postln; </span>// this returns the value at index 1</p>
<p class="p6"><span class="s4">y.foldAt(4).postln; </span>// this returns the value at index 0</p>
<p class="p6"><span class="s4">y.foldAt(5).postln; </span>// this returns the value at index 1</p>
<p class="p2"><br></p>
<p class="p3"><b>put(index, item)</b></p>
<p class="p2"><br></p>
<p class="p3">Put <b>item</b> at <b>index</b>, replacing what is there.</p>
<p class="p2"><br></p>
<p class="p3"><b>clipPut(index, item)</b></p>
<p class="p2"><br></p>
<p class="p3">Same as <b>put</b>, but values for <b>index</b> greater than the size of the List will be clipped to the last index.</p>
<p class="p2"><span class="Apple-converted-space"> </span></p>
<p class="p3"><b>wrapPut(index, item)</b></p>
<p class="p2"><br></p>
<p class="p3">Same as <b>put</b>, but values for <b>index</b> greater than the size of the List will be wrapped around to 0.</p>
<p class="p2"><br></p>
<p class="p3"><b>foldPut(index)</b></p>
<p class="p2"><br></p>
<p class="p3">Same as <b>put</b>, but values for <b>index</b> greater than the size of the List will be folded back.</p>
<p class="p2"><br></p>
<p class="p3"><b>add(item)</b></p>
<p class="p2"><br></p>
<p class="p3">Adds an <b>item</b> to the end of the List.</p>
<p class="p2"><br></p>
<p class="p3"><b>addFirst(item)</b></p>
<p class="p2"><br></p>
<p class="p3">Inserts the <b>item</b> at the beginning of the List.</p>
<p class="p7"><br></p>
<p class="p3"><b>insert(index, item)</b></p>
<p class="p2"><br></p>
<p class="p3">Inserts the <b>item</b> into the contents of the List at the indicated <b>index</b>.</p>
<p class="p7"><br></p>
<p class="p3"><b>pop</b></p>
<p class="p2"><br></p>
<p class="p3">Remove and return the last element of the List.</p>
<p class="p2"><br></p>
<p class="p3"><b>grow(sizeIncrease)</b></p>
<p class="p2"><br></p>
<p class="p3">Increase the size of the List by <b>sizeIncrease </b>number of slots.</p>
<p class="p2"><br></p>
<p class="p3"><b>removeAt(index)</b></p>
<p class="p2"><br></p>
<p class="p3">Remove and return the element at <b>index</b>, shrinking the size of the List.</p>
<p class="p2"><br></p>
<p class="p4">y = List[ 1, 2, 3 ];<span class="Apple-converted-space"> </span></p>
<p class="p4">y.removeAt(1);<span class="Apple-converted-space"> </span></p>
<p class="p4">y.postln;</p>
<p class="p2"><br></p>
<p class="p3"><b>fill(value)</b></p>
<p class="p2"><br></p>
<p class="p3">Inserts the item into the contents of the receiver, possibly returning a new collection. Note the difference between this and Collection's *fill.</p>
<p class="p2"><br></p>
<p class="p4">(</p>
<p class="p4"><span class="s1">var</span> z;</p>
<p class="p4">z = <span class="s1">List</span>[1, 2, 3, 4];</p>
<p class="p4">z.fill(4).postln;</p>
<p class="p4">z.fill([1,2,3,4]).postln;</p>
<p class="p4">)</p>
<p class="p8"><br></p>
<p class="p3"><b>do(function)</b></p>
<p class="p2"><br></p>
<p class="p3">Iterate over the elements in order, calling the function for each element. The function is passed two arguments, the element and an index.</p>
<p class="p2"><br></p>
<p class="p4"><span class="s1">List</span>[<span class="s5">'a'</span>, <span class="s5">'b'</span>, <span class="s5">'c'</span>].do({ <span class="s1">arg</span> item, i; [i, item].postln; });</p>
<p class="p9"><br></p>
<p class="p3"><b>reverseDo(function)</b></p>
<p class="p2"><br></p>
<p class="p3">Iterate over the elements in reverse order, calling the function for each element. The function is passed two arguments, the element and an index.</p>
<p class="p2"><br></p>
<p class="p4"><span class="s1">List</span>[<span class="s5">'a'</span>, <span class="s5">'b'</span>, <span class="s5">'c'</span>].reverseDo({ <span class="s1">arg</span> item, i; [i, item].postln; });</p>
<p class="p9"><br></p>
<p class="p3"><b>copyRange(start, end)</b></p>
<p class="p2"><br></p>
<p class="p3">Return a new List which is a copy of the indexed slots of the receiver from start to end.</p>
<p class="p7"><br></p>
<p class="p4">(</p>
<p class="p4"><span class="s1">var</span> y, z;</p>
<p class="p4">z = <span class="s1">List</span>[1, 2, 3, 4, 5];</p>
<p class="p4">y = z.copyRange(1,3);</p>
<p class="p4">z.postln;</p>
<p class="p4">y.postln;</p>
<p class="p4">)</p>
<p class="p9"><br></p>
<p class="p3"><b>copySeries(first, second, last)</b></p>
<p class="p2"><br></p>
<p class="p3">Return a new List consisting of the values starting at <b>first</b>, then every step of the distance between <b>first</b> and <b>second</b>, up until <b>last</b>.</p>
<p class="p7"><br></p>
<p class="p4">(</p>
<p class="p4"><span class="s1">var</span> y, z;</p>
<p class="p4">z = <span class="s1">List</span>[1, 2, 3, 4, 5, 6];</p>
<p class="p4">y = z.copySeries(0, 2, 5);</p>
<p class="p4">y.postln;</p>
<p class="p4">)</p>
<p class="p9"><br></p>
<p class="p3"><b>putSeries(first, second, last, value)</b></p>
<p class="p2"><br></p>
<p class="p3">Put <b>value</b> at every index starting at <b>first</b>, then every step of the distance between <b>first</b> and <b>second</b>, up until <b>last</b>.</p>
<p class="p7"><br></p>
<p class="p4">(</p>
<p class="p4"><span class="s1">var</span> y, z;</p>
<p class="p4">z = <span class="s1">List</span>[1, 2, 3, 4, 5, 6];</p>
<p class="p4">y = z.putSeries(0, 2, 5, <span class="s3">"foo"</span>);</p>
<p class="p4">y.postln;</p>
<p class="p4">)</p>
<p class="p9"><br></p>
<p class="p3"><b>reverse</b></p>
<p class="p2"><br></p>
<p class="p3">Return a new List whose elements are reversed.</p>
<p class="p2"><br></p>
<p class="p4">(</p>
<p class="p4"><span class="s1">var</span> y, z;</p>
<p class="p4">z = <span class="s1">List</span>[1, 2, 3, 4];</p>
<p class="p4">y = z.reverse;</p>
<p class="p4">z.postln;</p>
<p class="p4">y.postln;</p>
<p class="p4">)</p>
<p class="p9"><br></p>
<p class="p3"><b>scramble</b></p>
<p class="p2"><br></p>
<p class="p3">Returns a new List whose elements have been scrambled. The receiver is unchanged.</p>
<p class="p10"><br></p>
<p class="p4"><span class="s1">Lis</span>t[1, 2, 3, 4, 5, 6].scramble.postln;</p>
<p class="p7"><br></p>
<p class="p3"><b>mirror</b></p>
<p class="p2"><br></p>
<p class="p3">Return a new List which is the receiver made into a palindrome.<span class="Apple-converted-space"> </span></p>
<p class="p3">The receiver is unchanged.</p>
<p class="p2"><br></p>
<p class="p4"><span class="s1">Lis</span>t[1, 2, 3, 4].mirror.postln;</p>
<p class="p2"><br></p>
<p class="p3"><b>mirror1</b></p>
<p class="p2"><br></p>
<p class="p3">Return a new List which is the receiver made into a palindrome with the last element removed.<span class="Apple-converted-space"> </span></p>
<p class="p3">This is useful if the list will be repeated cyclically, the first element will not get played twice.</p>
<p class="p3">The receiver is unchanged.</p>
<p class="p2"><br></p>
<p class="p4"><span class="s1">Lis</span>t[1, 2, 3, 4].mirror1.postln;</p>
<p class="p2"><br></p>
<p class="p3"><b>mirror2</b></p>
<p class="p2"><br></p>
<p class="p3">Return a new List which is the receiver concatenated with a reversal of itself. The center element is duplicated. The receiver is unchanged.</p>
<p class="p2"><br></p>
<p class="p4"><span class="s1">Lis</span>t[1, 2, 3, 4].mirror2.postln;</p>
<p class="p2"><br></p>
<p class="p3"><b>stutter(n)</b></p>
<p class="p2"><br></p>
<p class="p3">Return a new List whose elements are repeated n times. The receiver is unchanged.</p>
<p class="p2"><br></p>
<p class="p4"><span class="s1">Lis</span>t[1, 2, 3].stutter(2).postln;</p>
<p class="p2"><br></p>
<p class="p3"><b>rotate(n)</b></p>
<p class="p2"><br></p>
<p class="p3">Return a new List whose elements are in rotated order. Negative n values rotate left, postive n values rotate right. The receiver is unchanged.</p>
<p class="p2"><br></p>
<p class="p4"><span class="s1">Lis</span>t[1, 2, 3, 4, 5].rotate(1).postln;</p>
<p class="p9"><br></p>
<p class="p4"><span class="s1">Lis</span>t[1, 2, 3, 4, 5].rotate(-1).postln;</p>
<p class="p9"><br></p>
<p class="p4"><span class="s1">Lis</span>t[1, 2, 3, 4, 5].rotate(3).postln;</p>
<p class="p2"><br></p>
<p class="p3"><b>pyramid</b></p>
<p class="p2"><br></p>
<p class="p3">Return a new List whose elements have been reordered via one of 10 "counting" algorithms.</p>
<p class="p3">The algorithms are numbered 1 through 10. Run the examples to see the algorithms.</p>
<p class="p2"><br></p>
<p class="p4"><span class="s1">Lis</span>t[1, 2, 3, 4].pyramid(1).postln;</p>
<p class="p7"><br></p>
<p class="p4">(</p>
<p class="p4">10.do({ <span class="s1">arg</span> i;</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="s1">Lis</span>t[1, 2, 3, 4].pyramid(i + 1).asCompileString.postln;</p>
<p class="p4">});</p>
<p class="p4">)</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p3"><b>lace(length)</b></p>
<p class="p2"><br></p>
<p class="p3">Returns a new List whose elements are interlaced sequences of the elements of the receiver's subcollections, up to size <b>length</b>. The receiver is unchanged.</p>
<p class="p2"><br></p>
<p class="p4">(</p>
<p class="p4">x = <span class="s1">List</span>[ [1, 2, 3], 6, <span class="s1">List</span>[<span class="s3">"foo"</span>, <span class="s5">'bar'</span>]];</p>
<p class="p4">y = x.lace(12);</p>
<p class="p4">x.postln;</p>
<p class="p4">y.postln;</p>
<p class="p4">)</p>
<p class="p2"><br></p>
<p class="p3"><b>permute(nthPermutation)</b></p>
<p class="p2"><br></p>
<p class="p3">Returns a new List whose elements are the <b>nthPermutation</b> of the elements of the receiver. The receiver is unchanged.</p>
<p class="p2"><br></p>
<p class="p4">(</p>
<p class="p4">x = <span class="s1">List</span>[ 1, 2, 3];</p>
<p class="p4">6.do({|i| x.permute(i).postln;});</p>
<p class="p4">)</p>
<p class="p2"><br></p>
<p class="p3"><b>wrapExtend(length)</b></p>
<p class="p2"><br></p>
<p class="p3">Returns a new List whose elements are repeated sequences of the receiver, up to size <b>length</b>. The receiver is unchanged.</p>
<p class="p2"><br></p>
<p class="p4">(</p>
<p class="p4">x = <span class="s1">List</span>[ 1, 2, 3, <span class="s3">"foo"</span>, <span class="s5">'bar'</span> ];</p>
<p class="p4">y = x.wrapExtend(9);</p>
<p class="p4">x.postln;</p>
<p class="p4">y.postln;</p>
<p class="p4">)</p>
<p class="p2"><br></p>
<p class="p3"><b>foldExtend(length)</b></p>
<p class="p2"><br></p>
<p class="p3">Same as <b>lace</b> but the sequences fold back on the list elements.</p>
<p class="p9"><br></p>
<p class="p4">(</p>
<p class="p4">x = <span class="s1">List</span>[ 1, 2, <span class="s3">"foo"</span>];</p>
<p class="p4">y = x.foldExtend(9);</p>
<p class="p4">x.postln;</p>
<p class="p4">y.postln;</p>
<p class="p4">)</p>
<p class="p2"><br></p>
<p class="p3"><b>slide(windowLength, stepSize)</b></p>
<p class="p2"><br></p>
<p class="p3">Return a new List whose elements are repeated subsequences from the receiver.<span class="Apple-converted-space"> </span></p>
<p class="p3">Easier to demonstrate than explain.</p>
<p class="p2"><br></p>
<p class="p4"><span class="s1">Lis</span>t[1, 2, 3, 4, 5, 6].slide(3, 1).asCompileString.postln;</p>
<p class="p9"><br></p>
<p class="p4"><span class="s1">Lis</span>t[1, 2, 3, 4, 5, 6].slide(3, 2).asCompileString.postln;</p>
<p class="p9"><br></p>
<p class="p4"><span class="s1">Lis</span>t[1, 2, 3, 4, 5, 6].slide(4, 1).asCompileString.postln;</p>
<p class="p9"><br></p>
<p class="p3"><b>dump</b></p>
<p class="p2"><br></p>
<p class="p3">Dump the List's Array.</p>
<p class="p2"><br></p>
<p class="p3"><b>clear</b></p>
<p class="p2"><br></p>
<p class="p3">Replace the List's Array with a new empty one.</p>
</body>
</html>
