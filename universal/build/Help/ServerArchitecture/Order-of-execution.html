<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<title></title>
<meta name="Generator" content="Cocoa HTML Writer">
<meta name="CocoaVersion" content="824.42">
<style type="text/css">
p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 20.0px Helvetica}
p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; min-height: 14.0px}
p.p3 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica}
p.p4 {margin: 0.0px 0.0px 0.0px 0.0px; font: 14.0px Helvetica}
p.p5 {margin: 0.0px 0.0px 0.0px 0.0px; font: 14.0px Helvetica; min-height: 17.0px}
p.p6 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #a71e12}
p.p7 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco}
p.p8 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; min-height: 12.0px}
p.p9 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #0019b7}
p.p10 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #0019b7; min-height: 12.0px}
p.p11 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #606060}
span.s1 {text-decoration: underline}
span.s2 {color: #0019b7}
span.s3 {color: #000000}
span.s4 {color: #326f17}
span.s5 {color: #606060}
span.Apple-tab-span {white-space:pre}
</style>
</head>
<body>
<p class="p1"><b>Order of execution<span class="Apple-converted-space"> </span></b></p>
<p class="p2"><br></p>
<p class="p3">Order of execution is one of the most critical and seemingly difficult aspects of using SuperCollider, but in reality it only takes a little thought in the early planning stages to make it work for you.<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p3">Order of execution in this context doesn't mean the order in which statements are executed in the language (the client). It refers to the ordering of synth nodes on the server, which corresponds to the order in which their output is calculated each control cycle (blockSize). Whether or not you specify the order of execution, each synth and each group goes into a specific place in the chain of execution.</p>
<p class="p2"><br></p>
<p class="p3">If you have on the server:</p>
<p class="p2"><br></p>
<p class="p3"><span class="Apple-tab-span">	</span>synth 1 ---&gt; synth 2<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p3">... all the unit generators associated with synth 1 will execute before those in synth 2 during each control cycle.<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p3">If you don't have any synths that use In.ar, you don't have to worry about order of execution. It only matters when one synth is reading the output of another.</p>
<p class="p2"><br></p>
<p class="p3">The rule is simple: if you have a synth on the server (i.e. an "effect") that depends on the output from another synth (the "source"), the effect must appear later in the chain of nodes on the server than the source.</p>
<p class="p2"><br></p>
<p class="p3"><span class="Apple-tab-span">	</span>source ---&gt; effect<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p3">If you have:</p>
<p class="p2"><br></p>
<p class="p3"><span class="Apple-tab-span">	</span>effect ---&gt; source<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p3">The effect synth will not hear the source synth, and you won't get the results you want.<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p4"><b><span class="s1">Some Notes about Servers and Targets</span></b></p>
<p class="p5"><br></p>
<p class="p3">There is always a default <b>Server</b>, which can be accessed or set through the class method Server.default. At startup this is set to be the local Server, and is also assigned to the interpreter variable s.</p>
<p class="p2"><br></p>
<p class="p6">// execute the following and watch the post window</p>
<p class="p7">s === <span class="s2">Server</span>.default;</p>
<p class="p7">s === <span class="s2">Server</span>.local;</p>
<p class="p7"><span class="s2">Server</span>.default = <span class="s2">Server</span>.internal; s === <span class="s2">Server</span>.default;</p>
<p class="p6"><span class="s2">Server</span><span class="s3">.default = </span><span class="s2">Server</span><span class="s3">.local; </span>// return it to the local server</p>
<p class="p2"><br></p>
<p class="p3">When a <b>Server</b> is booted there is a top level group with an ID of 0 that defines the root of the node tree. This is represented by a subclass of Group: <b>RootNode</b>. There is also a <b>default_group</b> with an ID of 1. This group is the default group for all Nodes. This is what you will get if you supply a Server as a target. If you don't specify a target or pass in nil, you will get the default group of the default Server. <span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p3">The default group serves an important purpose: It provides a predictable basic Node tree so that methods such as Server-scope and Server-record can function without running into order of execution problems. Thus in general one should create new Nodes within the default group rather than in the RootNode. See <b>default_group</b> and <b>RootNode </b>for more detail.</p>
<p class="p5"><br></p>
<p class="p4"><b><span class="s1">Controlling order of execution</span></b><b><span class="Apple-converted-space"> </span></b></p>
<p class="p2"><br></p>
<p class="p3">There are three ways to control the order of execution: using addAction in your synth creation messages, moving nodes, and placing your synths in groups. Using groups is optional, but they are the most effective in helping you organize the order of execution.</p>
<p class="p2"><br></p>
<p class="p3"><b>Add actions:</b></p>
<p class="p2"><br></p>
<p class="p3">By specifying an addAction argument for <b>Synth.new</b> (or SynthDef.play, Function.play, etc.) one can specify the node's placement relative to a target. The target might be a group node, another synth node, or a server.<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p3">As noted above, the default target is the <b>default_group</b> (the group with <b>nodeID 1</b>) of the default Server.<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p3"><span class="Apple-converted-space"> </span>The following <b>Symbols</b> are valid addActions for Synth.new: <span class="s4">\addToHead</span>, <span class="s4">\addToTail</span>, <span class="s4">\addBefore</span>, <span class="s4">\addAfter</span>, <span class="s4">\addReplace</span>.</p>
<p class="p2"><br></p>
<p class="p3"><b><span class="Apple-tab-span">	</span>Synth.new(defName, args, target, addAction)</b></p>
<p class="p3"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>if target is a Synth the<span class="Apple-converted-space">  </span><span class="s4">\addToHead</span>, and <span class="s4">\addToTail</span> methods will apply to that Synths group</p>
<p class="p3"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>if target is a Server it will resolve to that Server's default group</p>
<p class="p3"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>if target is nil it will resolve to the default group of the default Server</p>
<p class="p2"><span class="Apple-tab-span">	</span> <span class="Apple-tab-span">	</span><span class="Apple-converted-space"> </span></p>
<p class="p3">For each addAction there is also a corresponding convenience method of class <b>Synth</b>:</p>
<p class="p2"><b><span class="Apple-tab-span">	</span></b></p>
<p class="p3"><b><span class="Apple-tab-span">	</span>Synth.head(aGroup, defName, args)</b></p>
<p class="p3"><b><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></b>add the new synth to the the head of the group specified by aGroup</p>
<p class="p3"><span class="Apple-tab-span">	</span> <span class="Apple-tab-span">	</span>if aGroup is a synth node, the new synth will be added to the head of that node's group</p>
<p class="p3"><span class="Apple-tab-span">	</span> <span class="Apple-tab-span">	</span>if target is a Server it will resolve to that Server's default group</p>
<p class="p3"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>if target is nil it will resolve to the default group of the default Server</p>
<p class="p2"><br></p>
<p class="p3"><b><span class="Apple-tab-span">	</span>Synth.tail(aGroup, defName, args)</b></p>
<p class="p3"><b><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></b>add the new synth to the the tail of the group specified by aGroup</p>
<p class="p3"><span class="Apple-tab-span">	</span> <span class="Apple-tab-span">	</span>if aGroup is a synth node, the new synth will be added to the tail of that node's group</p>
<p class="p3"><span class="Apple-tab-span">	</span> <span class="Apple-tab-span">	</span>if target is a Server it will resolve to that Server's default group</p>
<p class="p3"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>if target is nil it will resolve to the default group of the default Server</p>
<p class="p2"><b><span class="Apple-tab-span">	</span></b></p>
<p class="p3"><b><span class="Apple-tab-span">	</span>Synth.before(aNode, defName, args)</b></p>
<p class="p3"><b><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></b>add the new node just before the node specified by aNode.</p>
<p class="p2"><br></p>
<p class="p3"><b><span class="Apple-tab-span">	</span>Synth.after(aNode, defName, args)</b></p>
<p class="p3"><b><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></b>add the new node just after the node specified by aNode.</p>
<p class="p2"><br></p>
<p class="p3"><b><span class="Apple-tab-span">	</span>Synth.replace(synthToReplace, defName, args)</b></p>
<p class="p3"><b><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></b>the new node replaces the node specified by synthToReplace. The target node is freed.</p>
<p class="p2"><br></p>
<p class="p3">Using Synth.new without an addAction will result in the default addAction. (You can check the default values for the arguments of any method by looking at a class' source code. See <b>Internal-Snooping</b> for more details.) Where order of execution matters, it is important that you specify an addAction, or use one of the convenience methods shown above.</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p3"><b>Moving nodes:</b></p>
<p class="p2"><br></p>
<p class="p3"><b><span class="Apple-tab-span">	</span>.moveBefore</b></p>
<p class="p3"><b><span class="Apple-tab-span">	</span>.moveAfter</b></p>
<p class="p3"><b><span class="Apple-tab-span">	</span>.moveToHead</b></p>
<p class="p3"><b><span class="Apple-tab-span">	</span>.moveToTail</b></p>
<p class="p2"><br></p>
<p class="p3">If you need to change the order of execution after synths and groups have been created, you can do this using move messages.</p>
<p class="p2"><br></p>
<p class="p7"><span class="Apple-tab-span">	</span>~fx = <span class="s2">Synth</span>.tail(s, <span class="s5">"fx"</span>);</p>
<p class="p6"><span class="s3"><span class="Apple-tab-span">	</span>~src = </span><span class="s2">Synth</span><span class="s3">.tail(s, </span><span class="s5">"src"</span><span class="s3">);<span class="Apple-converted-space">  </span></span>// effect will not be heard b/c it's earlier</p>
<p class="p6"><span class="s3"><span class="Apple-tab-span">	</span>~src.moveBefore(~fx); <span class="Apple-converted-space">  </span></span>// place the source before the effect</p>
<p class="p8"><span class="Apple-tab-span">	</span></p>
<p class="p2"><br></p>
<p class="p3"><b>Groups<span class="Apple-converted-space"> </span></b></p>
<p class="p2"><br></p>
<p class="p3">Groups can be moved in the same way as synths. When you move a group, all the synths in that group move with it. This is why groups are such an important tool for managing order of execution. (See the <b>Group</b> helpfile for details on this and other convenient aspects of Groups.)</p>
<p class="p2"><br></p>
<p class="p3"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Group 1 ---&gt; Group 2</p>
<p class="p2"><br></p>
<p class="p3">In the above configuration, all of the synths in group 1 will execute before all of the synths in group 2. This is an easy, easy way to make the order of execution happen the way you want it to.<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p3">Determine your architecture, then make groups to support the architecture.</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p3"><b>Using order of execution to your advantage<span class="Apple-converted-space"> </span></b></p>
<p class="p2"><br></p>
<p class="p3">Before you start coding, plan out what you want and decide where the synths need to go.<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p3">A common configuration is to have a routine playing nodes, all of which need to be processed by a single effect. Plus, you want this effect to be separate from other things running at the same time. To be sure, you should place the synth -&gt; effect chain on a private audio bus, then transfer it to the main output.</p>
<p class="p2"><br></p>
<p class="p3"><span class="Apple-tab-span">	</span>[Lots of synths] ----&gt; effect ----&gt; transfer</p>
<p class="p2"><br></p>
<p class="p3">This is a perfect place to use a group:</p>
<p class="p2"><br></p>
<p class="p3"><span class="Apple-tab-span">	</span>Group ( [lots of synths] ) ----&gt; effect ----&gt; transfer</p>
<p class="p2"><br></p>
<p class="p3">To make the structure clearer in the code, one can also make a group for the effect (even if there's only one synth in it):</p>
<p class="p2"><br></p>
<p class="p3"><span class="Apple-tab-span">	</span>Group ( [lots of synths] ) ----&gt; Group ( [effect] ) ----&gt; transfer<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p3">I'm going to throw a further wrench into the example by modulating a parameter (note length) using a control rate synth.</p>
<p class="p2"><br></p>
<p class="p3">So, at the beginning of your program:</p>
<p class="p2"><br></p>
<p class="p7">s.boot;</p>
<p class="p8"><br></p>
<p class="p7">(</p>
<p class="p6"><span class="s3">l = </span><span class="s2">Bus</span><span class="s3">.control(s, 1);<span class="Apple-converted-space">  </span></span>// get a bus for the LFO--not relevant to order-of-exec</p>
<p class="p6"><span class="s3">b = </span><span class="s2">Bus</span><span class="s3">.audio(s, 2);<span class="Apple-tab-span">	</span></span>// assuming stereo--this is to keep the src-&gt;fx chain separate from</p>
<p class="p6"><span class="s3"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// other similar chains</p>
<p class="p7">~synthgroup = <span class="s2">Group</span>.tail(s);</p>
<p class="p7">~fxgroup = <span class="s2">Group</span>.tail(s);</p>
<p class="p8"><br></p>
<p class="p6">// now you have synthgroup --&gt; fxgroup within the default group of s</p>
<p class="p8"><br></p>
<p class="p6">// make some synthdefs to play with</p>
<p class="p7"><span class="s2">SynthDef</span>(<span class="s5">"order-of-ex-dist"</span>, { <span class="s2">arg</span> bus, preGain, postGain;</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s2">var</span> sig;</p>
<p class="p7"><span class="Apple-tab-span">	</span>sig = <span class="s2">In</span>.ar(bus, 2);</p>
<p class="p7"><span class="Apple-tab-span">	</span>sig = (sig * preGain).distort;</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s2">ReplaceOut</span>.ar(bus, sig * postGain);</p>
<p class="p7">}).send(s);</p>
<p class="p8"><br></p>
<p class="p7"><span class="s2">SynthDef</span>(<span class="s5">"order-of-ex-pulse"</span>, { <span class="s2">arg</span> freq, bus, ffreq, pan, lfobus;</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s2">var</span> sig, noteLen;</p>
<p class="p7"><span class="Apple-tab-span">	</span>noteLen = <span class="s2">In</span>.kr(lfobus, 1);</p>
<p class="p7"><span class="Apple-tab-span">	</span>sig = <span class="s2">RLPF</span>.ar(<span class="s2">Pulse</span>.ar(freq, 0.2, 0.5), ffreq, 0.3);</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s2">Out</span>.ar(bus, <span class="s2">Pan2</span>.ar(sig, pan)</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>* <span class="s2">EnvGen</span>.kr(<span class="s2">Env</span>.perc(0.1, 1), timeScale: noteLen, doneAction: 2));</p>
<p class="p7">}).send(s);</p>
<p class="p8"><br></p>
<p class="p7"><span class="s2">SynthDef</span>(<span class="s5">"LFNoise1"</span>, { <span class="s2">arg</span> freq, mul, add, bus;</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s2">Out</span>.kr(bus, <span class="s2">LFNoise1</span>.kr(freq, mul:mul, add:add));</p>
<p class="p7">}).send(s);</p>
<p class="p7">)</p>
<p class="p8"><br></p>
<p class="p6">// Place LFO:</p>
<p class="p8"><br></p>
<p class="p7">~lfo = <span class="s2">Synth</span>.head(s, <span class="s5">"LFNoise1"</span>, [<span class="s4">\freq</span>, 0.3, <span class="s4">\mul</span>, 0.68, <span class="s4">\add</span>, 0.7, <span class="s4">\bus</span>, l.index]);</p>
<p class="p8"><br></p>
<p class="p6">// Then place your effect:<span class="Apple-converted-space"> </span></p>
<p class="p8"><br></p>
<p class="p7">~dist = <span class="s2">Synth</span>.tail(~fxgroup, <span class="s5">"order-of-ex-dist"</span>, [<span class="s4">\bus</span>, b.index, <span class="s4">\preGain</span>, 8, <span class="s4">\postGain</span>, 0.6]);</p>
<p class="p8"><br></p>
<p class="p6">// transfer the results to main out, with level scaling</p>
<p class="p6">// play at tail of s's default group (note that Function-play also takes addActions!</p>
<p class="p8"><br></p>
<p class="p7">~xfer = { <span class="s2">Out</span>.ar(0, 0.25 * <span class="s2">In</span>.ar(b.index, 2)) }.play(s, addAction: <span class="s4">\addToTail</span>);<span class="Apple-converted-space">   </span></p>
<p class="p8"><br></p>
<p class="p6">// And start your routine:</p>
<p class="p8"><br></p>
<p class="p7">(</p>
<p class="p9"><span class="s3">r = </span>Routine<span class="s3">({</span></p>
<p class="p7"><span class="Apple-tab-span">	</span>{</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s2">Synth</span>.tail(~synthgroup, <span class="s5">"order-of-ex-pulse"</span>,</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>[<span class="s4">\freq</span>, rrand(200, 800), <span class="s4">\ffreq</span>, rrand(1000, 15000), <span class="s4">\pan</span>, 1.0.rand2,</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span> <span class="s4">\bus</span>, b.index, <span class="s4">\lfobus</span>, l.index]);</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>0.07.wait;</p>
<p class="p7"><span class="Apple-tab-span">	</span>}.loop;</p>
<p class="p9"><span class="s3">}).play(</span>SystemClock<span class="s3">);</span></p>
<p class="p7">)</p>
<p class="p8"><br></p>
<p class="p6"><span class="s3">~dist.run(</span><span class="s2">false</span><span class="s3">);<span class="Apple-tab-span">	</span></span>// proves that the distortion effect is doing something</p>
<p class="p7">~dist.run(<span class="s2">true</span>);</p>
<p class="p8"><br></p>
<p class="p6">// to clean up:</p>
<p class="p7">(</p>
<p class="p7">r.stop;</p>
<p class="p7">[~synthgroup, ~fxgroup, b, l, ~lfo, ~xfer].do({ <span class="s2">arg</span> x; x.free });</p>
<p class="p6"><span class="s3">currentEnvironment.clear; </span>// clear all environment variables</p>
<p class="p7">)</p>
<p class="p2"><br></p>
<p class="p3">Note that in the routine, using a Group for the source synths allows their order to easily be specified relative to each other (they are added with the .tail method), without worrying about their order relative to the effect synth.</p>
<p class="p2"><br></p>
<p class="p3">Note that this arrangement prevents errors in order of execution, through the use of a small amount of organizational code. Although straightforward here, this arrangement could easily be scaled to a larger project.</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p3"><b>Messaging Style</b></p>
<p class="p2"><br></p>
<p class="p3">The above examples are in 'object style'. Should you prefer to work in 'messaging style' there are corresponding messages to all of the methods shown above. See <b>NodeMessaging</b>, and <b>Server-Command-Reference</b> for more details.</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p4"><b><span class="s1">Feedback</span></b></p>
<p class="p5"><br></p>
<p class="p3">When the various output ugens (<b>Out</b>, <b>OffsetOut</b>, <b>XOut</b>) write data to a bus, they <i>mix</i> it with any data from the current cycle, but <i>overwrite</i> any data from the previous cycle. (<b>ReplaceOut</b> overwrites all data regardless.) Thus depending on node order, the data on a given bus may be from the current cycle or be one cycle old. <b>In.ar</b> checks the timestamp of any data it reads in and zeros any data from the previous cycle (for use within that synth; the data remains on the bus). This is fine for audio data, as it avoids feedback, but for control data it is useful to be able to read data from any place in the node order. For this reason <b>In.kr</b> also reads data that is older than the current cycle.</p>
<p class="p2"><br></p>
<p class="p3">In some cases we might also want to read audio from a node later in the current node order. This is the purpose of <b>InFeedback</b>. The delay introduced by this is at maximum one block size, which equals about 0.0014 sec at the default block size and sample rate.</p>
<p class="p2"><br></p>
<p class="p3">The variably mixing and overwriting behaviour of the output ugens can make order of execution crucial when using <b>In.kr</b> or <b>InFeedback.ar</b>. (No pun intended.) For example with a node order like the following the InFeedback ugen in Synth 2 will only receive data from Synth 1 (-&gt; = write out; &lt;- = read in):</p>
<p class="p2"><br></p>
<p class="p3">Synth 1 -&gt; busA<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>this synth overwrites the output of Synth3 before it reaches Synth 2</p>
<p class="p3">Synth 2 (with InFeedback) &lt;- busA<span class="Apple-converted-space"> </span></p>
<p class="p3">Synth 3 -&gt; busA</p>
<p class="p2"><br></p>
<p class="p3">If Synth 1 were moved after Synth 2 then Synth 2's InFeedback would receive a mix of the output from Synth 1 and Synth 3. This would also be true if Synth 2 came after Synth1 and Synth 3. In both cases data from Synth 1 and Synth 3 would have the same time stamp (either current or from the previous cycle), so nothing would be overwritten.</p>
<p class="p2"><br></p>
<p class="p3">(As well, if any In.ar wrote to busA earlier in the node order than Synth 2, it would zero the bus before Synth 3's data reached Synth 2. This is true even it there were no node before Synth 2 writing to busA.)</p>
<p class="p2"><br></p>
<p class="p3">Because of this it is often useful to allocate a separate bus for feedback. With the following arrangement Synth 2 will receive data from Synth3 regardless of Synth 1's position in the node order.</p>
<p class="p10"><br></p>
<p class="p3">Synth 1 -&gt; busA</p>
<p class="p3">Synth 2 (with InFeedback) &lt;- busB<span class="Apple-converted-space"> </span></p>
<p class="p3">Synth 3 -&gt; busB + busA<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p3">The following example demonstrates this issue with In.kr:</p>
<p class="p10"><br></p>
<p class="p7">(</p>
<p class="p11"><span class="s2">SynthDef</span><span class="s3">(</span>"help-Infreq"<span class="s3">, { </span><span class="s2">arg</span><span class="s3"> bus;</span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s2">Out</span>.ar(0, <span class="s2">FSinOsc</span>.ar(<span class="s2">In</span>.kr(bus), 0, 0.5));</p>
<p class="p7">}).send(s);</p>
<p class="p8"><br></p>
<p class="p7"><span class="s2">SynthDef</span>(<span class="s5">"help-Outfreq"</span>, { <span class="s2">arg</span> freq = 400, bus;</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s2">Out</span>.kr(bus, <span class="s2">SinOsc</span>.kr(1, 0, freq/40, freq));</p>
<p class="p7">}).send(s);</p>
<p class="p8"><br></p>
<p class="p7">b = <span class="s2">Bus</span>.control(s,1);</p>
<p class="p7">)</p>
<p class="p8"><br></p>
<p class="p6">// add the first control Synth at the tail of the default server; no audio yet</p>
<p class="p7">x = <span class="s2">Synth</span>.tail(s, <span class="s5">"help-Outfreq"</span>, [<span class="s4">\bus</span>, b.index]);</p>
<p class="p8"><br></p>
<p class="p6">// add the sound producing Synth BEFORE it; It receives x's data from the previous cycle</p>
<p class="p7">y = <span class="s2">Synth</span>.before(x, <span class="s5">"help-Infreq"</span>, [<span class="s4">\bus</span>, b.index]);</p>
<p class="p8"><br></p>
<p class="p6">// add another control Synth before y, at the head of the server</p>
<p class="p6">// It now overwrites x's cycle old data before y receives it</p>
<p class="p7">z = <span class="s2">Synth</span>.head(s, <span class="s5">"help-Outfreq"</span>, [<span class="s4">\bus</span>, b.index, <span class="s4">\freq</span>, 800]);</p>
<p class="p8"><br></p>
<p class="p6">// get another bus</p>
<p class="p7">c = <span class="s2">Bus</span>.control(s, 1);</p>
<p class="p8"><br></p>
<p class="p6">// now y receives x's data even though z is still there</p>
<p class="p7">y.set(<span class="s4">\bus</span>, c.index); x.set(<span class="s4">\bus</span>, c.index);</p>
<p class="p8"><br></p>
<p class="p7">x.free; y.free; z.free;</p>
<p class="p2"><span class="Apple-tab-span">	</span></p>
<p class="p5"><b><span class="Apple-converted-space"> </span></b></p>
<p class="p4"><b><span class="s1">Helpful 'Third Party' Classes</span></b></p>
<p class="p2"><br></p>
<p class="p3">James Harkins' MixerChannel class can help you with order of execution. Each channel includes a synth group and an effect group, as well as level and panning controls and pre- and post-fader sends. Using this class, it helps if you understand audio buses, but it does include methods .play and .playfx to place synths in the correct group and assign the bus automatically. You can download this class from http://www.duke.edu/~jharkins/sc3</p>
<p class="p2"><br></p>
<p class="p3">If you run into trouble, the crucial library includes a utility to query all nodes on the server so that you can see the order in which they're executing. Type <b>Crucial.menu</b> to access this command.</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
</body>
</html>
