{\rtf1\mac\ansicpg10000\cocoartf824\cocoasubrtf100
{\fonttbl\f0\fnil\fcharset77 Monaco;}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue0;\red0\green0\blue191;
\red96\green96\blue96;\red0\green115\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\f0\fs18 \cf2 // Termite College\cf3 \
\cf2 // (Tim Walters) (CC 2006)\cf3 \
\
\cf2 // Features recursively generated phase modulation trees\
//\cf3 \
\cf2 // Requires the GVerb and BEQsuite UGens, downloadable at\
// http://realizedsound.net/downloads\
\cf3 \
s.serverRunning.not.if(\{ s.boot \});\
\
(\
\cf4 var\cf3  pmSynthDefFactory;\
		\
pmSynthDefFactory = \{\
	\cf4 |name, out = 0, flatness = 6, maxOperators = 32, flavor = 0, attack = 4.0, release = 4.0, \
		sustain = 1.0, trace = false|\cf3 \
	\cf4 var\cf3  freqFuncs, freqModFunc, depthFunc, minNumModulatorsFunc;\
	\cf4 var\cf3  maxNumModulatorsFunc, levelSpec, pmtree;\
\
	\cf2 // This does timbral shifts by modulating volume of individual operators\cf3 \
	depthFunc = \{ \cf4 LinExp\cf3 .kr(\cf4 LFNoise1\cf3 .kr(exprand(0.1, 2.0)), -1, 1, 0.1, 1.0) \};\
	\
	\cf2 // Three flavors\cf3 \
	freqFuncs = [\
		\{ exprand(0.125, 4000) \},\
		\{ exprand(40, 4000) \},\
		\{ exprand(80, 500) \}\
	];\
	\
	\cf2 // Destabilize oscillators a bit.\cf3 \
	\cf2 // Would need a LinExp for proper tuning, but here\cf3 \
	\cf2 // we don't care.\cf3 \
	freqModFunc = \{ \cf4 BrownNoise\cf3 .kr.range(0.998, 0.998.reciprocal) \};\
	\
	\cf2 // This could be something more interesting\cf3 \
	minNumModulatorsFunc = \{\
		\cf4 |level|\cf3 \
		1\
	\};\
	\
	\cf2 // Tree thins out slowly with increasing depth\cf3 \
	maxNumModulatorsFunc = \{\
		\cf4 |level|\cf3 \
		(level.reciprocal.sqrt * flatness).asInteger + 1;\
	\};\
	\
	\cf2 // Generate tree of given size. If trace is true, dumps representation to post window.\cf3 \
	pmtree = \{\
		\cf4 |level, size, trace = false|\cf3 \
		\cf4 var\cf3  numModulators, numSubOperators, modGroup, thisUnitDepth, freq, freqMod;\
		\cf4 var\cf3  output, newSizes;\
		\
		\cf2 // Keep root oscillator in normal note range\cf3 \
		freq = (level == 1).if(\
			\{ exprand(80, 500) \},\
			\{ freqFuncs.wrapAt(flavor).value \}\
		);\
		trace.if(\{\
			(level - 1).do(\{ \cf5 "-"\cf3 .post \});\
			freq.postln;\
		\});\
		freqMod = freqModFunc.value;\
		numSubOperators = size - 1;\
		\
		\cf2 // Keep root oscillator at appropriate volume (don't modulate)\cf3 \
		thisUnitDepth = (level == 1).if(\
			\{ -18.dbamp * \cf4 AmpComp\cf3 .kr(freq) \}, \
			\{ depthFunc.value \}\
		);\
		\
		\cf2 // Choose number of tree branches, based on current level\cf3 \
		numModulators = (\
			minNumModulatorsFunc.value(level)..maxNumModulatorsFunc.value(level)\
		).choose.min(numSubOperators);\
		\
		\cf2 // Recursively generate subtrees, dividing up size among them.\cf3 \
		(size == 0).if(\{\
			output = 0\
		\}, \{\
			(numModulators == 0).if(\{\
				modGroup = 0\
			\}, \{\
				newSizes = 0 ! numModulators;\
				numSubOperators.do(\{\
					\cf4 var\cf3  index;\
					index = rrand(0, numModulators - 1);\
					newSizes[index] = newSizes[index] + 1;\
				\});\
				modGroup = \cf4 Mix\cf3 .ar(\{\
					\cf4 |i|\cf3 \
					pmtree.value(level + 1, newSizes[i], trace) \
				\} ! numModulators);\
			\});\
			\
			\cf2 // Return sine oscillator with subtrees summed as phase modulator\cf3 \
			output = \cf4 SinOsc\cf3 .ar(freq * freqMod, modGroup, thisUnitDepth);\
		\});\
		output\
	\};\
	\
	\cf2 // Generate synthdef from tree. Use audio rate panning for stereo, \cf3 \
	\cf2 // with modulated width.\cf3 \
	\cf4 SynthDef\cf3 .new(name ? \cf6 \\PMTree\cf3 , \{\
		\cf4 |attack = 4.0, release = 4.0, sustain = 1.0, gate = 1.0|\cf3 \
		\cf4 var\cf3  env;\
		env = \cf4 EnvGen\cf3 .kr(\cf4 Env\cf3 .asr(attack, sustain, release, curve: [4, -4]), gate, doneAction: 2);\
		\cf4 Out\cf3 .ar(out, \cf4 Pan2\cf3 .ar(\
			pmtree.value(1, maxOperators, trace), \
			\cf4 SinOsc\cf3 .ar(freqFuncs.wrapAt(flavor).value, 0, depthFunc.value, rrand(-0.5, 0.5)),\
			env\
		));\
	\})\
\};\
\
~synths = \cf4 Set\cf3 [];\
\
~effectBus = \cf4 Bus\cf3 .audio(s, 2);\
\
\cf2 // Add some reverb.\cf3 \
~effect = \{\
	\cf4 |gate = 1.0|\cf3 \
	\cf4 var\cf3  env;\
	env = \cf4 EnvGen\cf3 .ar(\cf4 Env\cf3 .asr(0, 1.0, 16.0), gate, doneAction: 2);\
	\cf4 GVerb\cf3 .ar(\
		\cf2 // Tame those pesky upper mids.\cf3 \
		\cf4 BPeakEQ\cf3 .ar(\cf4 In\cf3 .ar(~effectBus.index), 4000.0, 0.5, -6),\
		roomsize: 50, \
		earlyreflevel: -9.dbamp, \
		taillevel: -12.dbamp,\
		mul: env\
	)\
\}.play;\
\
\cf2 // Player generates and plays synths of random size and flavor.\cf3 \
~player = \cf4 Task\cf3 (\{\
	\cf4 var\cf3  synthName, polyphony;\
	polyphony = 4;\
	\cf4 inf\cf3 .do(\{\
		\cf4 |i|\cf3 \
		\cf4 var\cf3  targetNumSynths;\
		synthName = (\cf5 "PMTree"\cf3  ++ (i % 100).asString).asSymbol;\
		targetNumSynths = rrand(1, polyphony - 1);\
		\{~synths.size > targetNumSynths\}.while(\{\
			~synths.remove(~synths.choose.release);\
		\});\
		~synths.add(\
			pmSynthDefFactory.value(\
				synthName, \
				~effectBus.index, \
				exprand(2.0, 9.0).asInteger, \
				exprand(4.0, 33.0).asInteger,\
				[0, 0, 0, 0, 1, 2].choose,\
				exprand(1.0, 8.0), \
				exprand(4.0, 16.0), \
				4.0\
			).play\
		);\
		exprand(12.0, 36.0).wait;\
	\});\
\});\
\
~player.start;\
)\
\
(\
\cf2 // Execute to finish.\cf3 \
~player.stop;		\
~synths.do(\{ \cf4 |synth|\cf3  ~synths.remove(synth.release) \});\
~effect.release;\
)\
\
(\
\cf2 // Execute after sound has completely died away.\cf3 \
~effectBus.free;\
)}