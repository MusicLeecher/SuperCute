{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica;\f1\fswiss\fcharset77 Helvetica-Bold;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red191\green0\blue0;\red96\green96\blue96;
\red0\green115\blue0;\red191\green0\blue0;\red0\green0\blue0;\red0\green0\blue191;\red0\green115\blue0;
}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs30 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b \cf0 Triggering functions from the Keyboard\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b0 \cf0 \
Drag Functions to keys in the window.\
Typing keys will execute the Function.\
If the Function returns another Function, the new Function will\
replace the action of a key.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs24 \cf0 \
(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 var\cf0  w; \cf3 // window object\cf0 \
\cf2 var\cf0  courier; \cf3 // font object\cf0 \
\
\cf3 // an Array of Strings representing the key layout.\cf0 \
\cf2 var\cf0  keyboard = #[\cf4 "`1234567890-="\cf0 , \cf4 "QWERTYUIOP[]\\\\"\cf0 , \
							\cf4 "ASDFGHJKL;'"\cf0 , \cf4 "ZXCVBNM,./"\cf0 ];\
\
\cf3 // horizontal offsets for keys.\cf0 \
\cf2 var\cf0  offsets = #[42, 48, 57, 117];\
\
\cf2 var\cf0  actions; \cf3 // an IdentityDictionary mapping keys to action functions.\cf0 \
\cf2 var\cf0  makeKey; \cf3 // function to create an SCDragSink for a key.\cf0 \
\
courier = \cf2 Font\cf0 (\cf4 "Courier-Bold"\cf0 , 14);\
\
\cf3 // an IdentityDictionary is used to map keys to functions so that\cf0 \
\cf3 // we can look up the action for a key\cf0 \
actions = \cf2 IdentityDictionary\cf0 .new; \cf3 // create actions dictionary\cf0 \
\
\cf3 // define a function that will create an SCDragSink for a key.\cf0 \
makeKey = \{\cf2 |char, keyname, bounds|\cf0 \
	\cf2 var\cf0  v;\
\
	keyname = keyname ? char.asString;\
	bounds = bounds ? (24 @ 24);\
\
	v = \cf2 SCDragBoth\cf0 (w, bounds);\
	v.font = courier;\
	v.string = keyname;\
	v.align = \cf5 \\center\cf0 ;\
	v.setBoth = \cf2 false\cf0 ;\
	v.acceptDrag = \{\
		\cf2 SCView\cf0 .currentDrag.isKindOf(\cf2 Function\cf0 )\
	\};\
	v.action = \{ \
		(\cf4 "added key action : "\cf0  ++ keyname).postln;\
		if (char.isAlpha) \{\
			actions[char.toUpper] = v.object;\
			actions[char.toLower] = v.object;\
		\}\{\
			actions[char] = v.object;\
		\};\
		w.front;\
	\};\
\};\
\
w = \cf2 SCWindow\cf0 (\cf4 "keyboard"\cf0 , \cf2 Rect\cf0 (128, 320, 420, 150));\
\
w.view.decorator = \cf2 FlowLayout\cf0 (w.view.bounds);\
\
\cf3 // define a function to handle key downs.\cf0 \
w.view.keyDownAction = \{\cf2 |view, char, modifiers, unicode, keycode|\cf0 \
	 \cf2 var\cf0  result;\
	 \
	\cf3 // call the function\cf0 \
	result = actions[char].value(char, modifiers);\
	\
	\cf3 // if the result is a function, that function becomes the \cf0 \
	\cf3 // new action for the key\cf0 \
	if (result.isKindOf(\cf2 Function\cf0 )) \{\
		actions[char] = result;\
	\};\
\};\
\
\cf3 // make the rows of the keyboard\cf0 \
keyboard.do \{\cf2 |row, i|\cf0  \
	row.do \{\cf2 |key|\cf0  makeKey.(key) \};\
	if (i==0) \{ makeKey.(127.asAscii, \cf4 "del"\cf0 , 38 @ 24) \};\
	if (i==2) \{ makeKey.($\\r, \cf4 "retrn"\cf0 , 46 @ 24) \};\
	w.view.decorator.nextLine;\
	w.view.decorator.shift(offsets[i]);\
\};\
\
\cf3 // make the last row\cf0 \
makeKey.($ , \cf4 "space"\cf0 , 150 @ 24);\
makeKey.(3.asAscii, \cf4 "enter"\cf0 , 48 @ 24);\
\
w.front;\
)\
\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf6 ////////////////////\cf7 \
\
\cf6 // Drag these things to the keyboard to test it.\cf7 \
\
(\
\{\
	\cf8 var\cf7  synth, original;\
	original = \cf8 thisFunction\cf7 ;\
	synth = \{ \cf8 SinOsc\cf7 .ar(exprand(500,1200),0,0.2) \}.play;\
	\{ synth.free; original \}\
\}\
)\
\
\
(\
\{\
	\{ \
		\cf8 Pan2\cf7 .ar(\
			\cf8 SinOsc\cf7 .ar(\
				\cf8 ExpRand\cf7 (300,3000), \
				0,\
				\cf8 SinOsc\cf7 .kr(\cf8 ExpRand\cf7 (1,15),0,0.05).max(0)), \
			\cf8 Rand\cf7 (-1,1)) \
	\}.play;\
\}\
)\
\
\{ s.sendMsg(\cf9 \\n_free\cf7 , \cf9 \\h\cf7 , 0); \} \cf6 // kill head\cf7 \
\
\{ s.sendMsg(\cf9 \\n_free\cf7 , \cf9 \\t\cf7 , 0); \} \cf6 // kill tail\cf7 \
\
(\
\{\{\
	\cf8 var\cf7  eg, o, freq, noise;\
	eg = \cf8 EnvGen\cf7 .kr(\cf8 Env\cf7 .linen(0.1,2,0.4,0.2), doneAction: 2);\
	freq = \cf8 Rand\cf7 (600,1200);\
	noise = \{\cf8 LFNoise2\cf7 .ar(freq*0.1, eg)\}.dup;\
	o = \cf8 SinOsc\cf7 .ar(freq,0,noise);\
	\cf8 Out\cf7 .ar(0, o);\
\}.play\})\
\
\
(\
\{\{\
	\cf8 var\cf7  in, sr;\
    in = \cf8 LFSaw\cf7 .ar([21000,21001], 0, \cf8 LFPulse\cf7 .kr(\cf8 ExpRand\cf7 (0.1,1),0,0.3,0.2,0.02));\
    sr = \cf8 ExpRand\cf7 (300,3000) + [-0.6,0.6];\
	\cf8 Out\cf7 .ar(0,  \cf8 RLPF\cf7 .ar(in * \cf8 LFPulse\cf7 .ar(sr, 0, \cf8 MouseY\cf7 .kr(0.01, 0.99)), sr * (\cf8 LFPulse\cf7 .kr(\cf8 ExpRand\cf7 (0.1,12),0,0.4,0.2,0.2) + \cf8 LFPulse\cf7 .kr(\cf8 ExpRand\cf7 (0.1,12),0,0.7,0.2)), 0.1));\
\}.play;\})\
\
(\
\{\{ \cf8 var\cf7  in;\
	in = \cf8 In\cf7 .ar(0,2);\
	\cf8 ReplaceOut\cf7 .ar(0, \cf8 CombN\cf7 .ar(in, 0.24, 0.24, 8, 1, in.reverse).distort);\
\}.play\})\
\
(\
\{\{ \cf8 var\cf7  in;\
	in = \cf8 In\cf7 .ar(0,2);\
	\cf8 ReplaceOut\cf7 .ar(0, in * \cf8 SinOsc\cf7 .ar(\cf8 MouseX\cf7 .kr(2,2000,1)));\
\}.play\})\
\
}