{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red191\green0\blue0;\red96\green96\blue96;
\red0\green115\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs32 \cf0 \
Understanding Streams, Patterns and Events - Part 1
\f1\b0\fs24 \
\
The SuperCollider Pattern library  provides a means of specifying dynamic structural \
transformations of musical processes. It  provides similar capabilities as one finds in \
Nyquist, Elody, Siren, Kyma, HMSL, DMix, and Patchwork. \
\
By using coroutines and streams rather than eager functional methods it is able to work \
in a lazy event by event method instead of the all-at-once method of Elody and Siren.\
It  provides the kind of dynamic live control found in HMSL but with the more general \
event models of the others. In Nyquist and Siren certain transformation like Stretch and \
Transpose are specially coded into the framework. In SuperCollider Patterns, any parameter \
may have transformations applied to it. The only one treated specially is time, so that parallel \
streams can be merged.\
\
In order to understand the framework, a number of concepts must be covered.\
These concepts are embodied in the classes for Streams, Patterns, and Events.\
You should learn these concepts in the order presented. The framework is built\
up in layers. If you skip ahead to get to the cool stuff first, you will have missed \
some important points.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 Streams
\f1\b0 \
\
A stream represents a lazy sequence of values. The next value in the sequence is obtained by \
sending the message next to the stream object. The sequence can be restarted from the \
beginning by sending the message reset to the stream object. A stream can be of\
finite or infinite length. When a finite length stream has reached the end, it returns nil.\
\
A stream can be any object that responds to the next and reset messages.\
Any object that responds to these messages can act as a stream. \
It happens that the class Object defines next and reset for all objects.\
In Object, both next and reset are defined to return \cf2 'this\cf0 '.\
Thus any object is by default a stream that represents an infinite sequence of itself.\
\
7.next.postln;	\cf3 // 7 responds to next by returning itself\cf0 \
\
Stream and its subclasses\
\
In addition to the default streams implemented by Object, there is a class Stream that\
provides more functionality such as math operations on streams and filtering of streams. \
\
A generally useful subclass of Stream is the class FuncStream which allows the user to \
provide functions to execute in response to next and reset. \
Here is a FuncStream that represents an infinite random sequence:\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 \
(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 var\cf0  a;\
a = \cf2 FuncStream\cf0 .new(\{ #[1, 2, 3, 4].choose \});\
5.do(\{ a.next.postln; \});		\cf3 // print 5 values from the stream\cf0 \
)
\f1 \
\
Another useful subclass of Stream is Routine which is a special kind of function that can act like a Stream.\
Routines are functions that can return a value from the middle and then be resumed  from that \
point when called again. The yield message returns a value from the Routine. The next time theRoutine\
is called it begins by returning from the yield and continues from that point.\
See the Routine help file.\
\
Here is a Routine that represents a finite sequence of values:\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 (\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 var\cf0  a;\
a = \cf2 Routine\cf0 .new(\{ \
		3.do(\{ \cf2 arg\cf0  i; i.yield; \}) \
	\});\
4.do(\{ a.next.postln; \});	\cf3 // print 4 values from stream\cf0 \
)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 \
and another:\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 \
(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 var\cf0  a;\
a = \cf2 Routine\cf0 .new(\{ \
		3.do(\{ \cf2 arg\cf0  i; \
			(i+1).do(\{ \cf2 arg\cf0  j; j.yield; \}) \
		\}) \
	\});\
8.do(\{ a.next.postln; \});	\cf3 // print 8 values from stream\cf0 \
)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 \
\
Math operations on Streams\
\
Stream is a subclass of AbstractFunction which means that\
one can do math operations on streams to produce other streams.\
\
Applying a unary operator to a stream:\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 \
(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 var\cf0  a, b;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 // a is a stream that counts from 0 to 9\cf0 \
a = \cf2 Routine\cf0 .new(\{ \
		10.do(\{ \cf2 arg\cf0  i; i.yield; \}) \
	\});\
b = a.squared;	\cf3 // stream b is a square of the stream a\cf0 \
12.do(\{ b.next.postln; \});\
)
\f1 \
\
Using a binary operator on a stream:\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 \
(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 var\cf0  a, b;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 // a is a stream that counts from 0 to 9\cf0 \
a = \cf2 Routine\cf0 .new(\{ \
		10.do(\{ \cf2 arg\cf0  i; i.yield; \}) \
	\});\
b = a + 100;	\cf3 // add a constant value to stream a\cf0 \
12.do(\{ b.next.postln; \});\
)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 \
Using a binary operator on two streams:\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 (\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 var\cf0  a, b, c;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 // a is a stream that counts from 0 to 9\cf0 \
a = \cf2 Routine\cf0 .new(\{ \
		10.do(\{ \cf2 arg\cf0  i; i.yield; \}) \
	\});\
\cf3 // b is a stream that counts from 100 to 280 by 20\cf0 \
b = \cf2 Routine\cf0 .new(\{ \
		forBy (100,280,20, \{ \cf2 arg\cf0  i; i.yield \}) \
	\});\
c = a + b;	\cf3 // add streams a and b\cf0 \
12.do(\{ c.next.postln; \});\
)
\f1 \
\
Filtering operations on streams\
\
Streams respond to the messages collect, select, and reject by returning a new Stream.\
\
The collect message returns a stream that is modified by a function in the same way \
as the collect message sent to a Collection returns a modified Collection.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 (\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 var\cf0  a, b;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 // a is a stream that counts from 0 to 9\cf0 \
a = \cf2 Routine\cf0 .new(\{ \
		10.do(\{ \cf2 arg\cf0  i; i.yield; \}) \
	\});\
\cf3 // b is a stream that adds 100 to even values\cf0 \
b = a.collect(\{ \cf2 arg\cf0  item; if (item.even, \{ item + 100 \},\{ item \}); \});\
6.do(\{ b.next.postln; \});\
)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 \
The select message creates a stream that passes only items that return true from a \
user supplied function.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 (\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 var\cf0  a, b;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 // a is a stream that counts from 0 to 9\cf0 \
a = \cf2 Routine\cf0 .new(\{ \
		10.do(\{ \cf2 arg\cf0  i; i.yield; \}) \
	\});\
\cf3 // b is a stream that only returns the odd values from stream a\cf0 \
b = a.select(\{ \cf2 arg\cf0  item; item.odd; \});\
6.do(\{ b.next.postln; \});\
)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 \
The reject message creates a stream that passes only items that return false from a \
user supplied function.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 (\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 var\cf0  a, b;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 // a is a stream that counts from 0 to 9\cf0 \
a = \cf2 Routine\cf0 .new(\{ \
		10.do(\{ \cf2 arg\cf0  i; i.yield; \}) \
	\});\
\cf3 // b is a stream that only returns the non-odd values from stream a\cf0 \
b = a.reject(\{ \cf2 arg\cf0  item; item.odd; \});\
6.do(\{ b.next.postln; \});\
)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 \
\
\
Making Music with Streams\
\
Here is a sound example to show how you might use Streams to generate musical material.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 \
(\
	s = \cf2 Server\cf0 .local;\
	\cf2 SynthDef\cf0 ( \cf4 "Help-SPE1"\cf0 , \{ \cf2 arg\cf0  i_out=0, freq;\
		\cf2 var\cf0  out;\
		out = \cf2 RLPF\cf0 .ar(\
			\cf2 LFSaw\cf0 .ar( freq, mul: \cf2 EnvGen\cf0 .kr( \cf2 Env\cf0 .perc, levelScale: 0.3, doneAction: 2 )),\
			\cf2 LFNoise1\cf0 .kr(1, 36, 110).midicps,\
			0.1\
		);\
		\cf3 // out = [out, DelayN.ar(out, 0.04, 0.04) ];\cf0 \
		4.do(\{ out = \cf2 AllpassN\cf0 .ar(out, 0.05, [0.05.rand, 0.05.rand], 4) \});\
		\cf2 Out\cf0 .ar( i_out, out );\
	\}).send(s);\
)\
(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 // streams as a sequence of pitches\cf0 \
	\cf2 var\cf0  stream, dur;\
	dur = 1/8;\
	stream = \cf2 Routine\cf0 .new(\{\
		loop(\{\
			if (0.5.coin, \{\
				\cf3 // run of fifths: \cf0 \
				24.yield; \
				31.yield; \
				36.yield; \
				43.yield; \
				48.yield; \
				55.yield; \
			\});\
			rrand(2,5).do(\{\
				\cf3 // varying arpeggio\cf0 \
				60.yield;\
				#[63,65].choose.yield;\
				67.yield;\
				#[70,72,74].choose.yield;\
			\});\
			\cf3 // random high melody\cf0 \
			rrand(3,9).do(\{  #[74,75,77,79,81].choose.yield \});\
		\});\
	\});\
	\cf2 Routine\cf0 (\{\
		loop(\{\
			\cf2 Synth\cf0 ( \cf4 "Help-SPE1"\cf0 , [ \cf5 \\freq\cf0 , stream.next.midicps ] );\
			dur.wait; \cf3 // synonym for yield, used by .play to schedule next occurence\cf0 \
		\})\
	\}).play\
)\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 \
Optional:\
More about Streams can be learned from the book A Little Smalltalk by Timothy Budd.\
He calls them Generators and shows how they can be used to solve problems like\
the "eight queens" problem etc.\
\
\
To go to the next file, double click on the ] character to select the filename and type cmd-H:\
[Streams-Patterns-Events2]\
\
\
}