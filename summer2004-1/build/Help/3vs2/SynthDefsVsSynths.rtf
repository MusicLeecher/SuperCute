{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fswiss\fcharset77 Helvetica-Oblique;
\f3\fnil\fcharset77 Monaco;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red191\green0\blue0;\red96\green96\blue96;
\red0\green115\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 SynthDefs versus Synths\

\f1\b0\fs24 \
In SC2 Synth.play was the standard way to compile a ugenGraphFunc and play it. Each time you executed Synth.play, or Spawned a new event, that function was compiled anew. SC3 on the other hand, makes use of what are called SynthDefs. A 
\f0\b SynthDef
\f1\b0  takes a ugenGraphFunc and compiles it to a kind of bytecode (sort of like Java bytecode) which can be understood by the server app. The server reads the SynthDef and creates a synth node based upon it. \
\
SynthDefs can be precompiled and saved to disk. Any def saved in the synthdefs/ directory (or in any directory set in the environment variable SC_SYNTHDEF_PATH) will be loaded into memory by a local 
\f0\b Server
\f1\b0  when it is booted. If the def being used in a new 
\f0\b Synth
\f1\b0  is already compiled and loaded, there is much less of a CPU spike when creating a new 
\f0\b Synth
\f1\b0  than there was in SC2.\
\
SynthDefs can also be compiled and loaded into the Server without writing them to disk. This can be done while performing.\
\
The downside of this is that precompiled SynthDefs lack some of the programmatic flexibility that was one of SC2's great strengths. Much of this flexibility is gained back however, through the ability to set and change arguments (which you build into your ugenGraphFunc), and through new ugens such as 
\f0\b Rand
\f1\b0  and 
\f0\b TRand
\f1\b0 .\
\
When maximum flexibility is required, it is still possible to compile and send SynthDefs 'on the fly', albeit with SC2-like CPU spikes and a small amount of messaging latency.\
\
It is important to understand that creating and sending SynthDefs is 
\f2\i asynchronous. 
\f1\i0 This means that it is impossible to determine precisely how long it will take to compile and send a 
\f0\b SynthDef
\f1\b0 , and thus when it will be available for creating new Synths. A simple way around this is to execute code in blocks, selecting them one at a time. More complicated is to use completion messages. SynthDef.play takes care of this for you, and returns a Synth object which you can then manipulate. See the example below.\
\
Another important distinction is between Synth in SC2 and 
\f0\b Synth
\f1\b0  in SC3. The latter is a client-side object which 
\f2\i represents 
\f1\i0 a synth node on the server. Although it has some of the same methods, it does not function in the same way. There is no top level Synth in SC3, within which all scheduling and creation of other Synths occurs. There are only Synth objects which represent synth nodes on the server. These can be created at any time, within any scope.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs26 \cf0 \ul \ulc0 Examples
\f1\b0\fs24 \ulnone \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs18 \cf0 (\
s = \cf2 Server\cf0 .local;\
s.boot;\
)\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 // Compile a SynthDef and write it to disk\cf0 \
	(\
	\cf2 SynthDef\cf0 (\cf4 "Help-SynthDef"\cf0 , \
		\{ \cf2 arg\cf0  out=0;\
			 \cf2 Out\cf0 .ar(out, \cf2 PinkNoise\cf0 .ar(0.1))\
		\}).writeDefFile;\
	)\
\
\cf3 // Compile, write, and load it to the server\cf0 \
	(\
	\cf2 SynthDef\cf0 (\cf4 "Help-SynthDef"\cf0 , \
		\{ \cf2 arg\cf0  out=0;\
			 \cf2 Out\cf0 .ar(out, \cf2 PinkNoise\cf0 .ar(0.1))\
		\}).load(s);\
	)\
	\
\cf3 // Load it to the server without writing to disk\cf0 \
	(\
	\cf2 SynthDef\cf0 (\cf4 "Help-SynthDef"\cf0 , \
		\{ \cf2 arg\cf0  out=0;\
			 \cf2 Out\cf0 .ar(out, \cf2 PinkNoise\cf0 .ar(0.1))\
		\}).send(s);\
	)\
	\
\cf3 // Create a Synth with it\cf0 \
	x = \cf2 Synth\cf0 .new(\cf4 "Help-SynthDef"\cf0 , s);\
	x.free;
\f1\fs24 \
	\

\f3\fs18 \cf3 // Shorthand method to compile and write a SynthDef, and then play it in a Synth when done. \
// Look familiar?\cf0 \
	(
\f1\fs24 \
	
\f3\fs18 x = \cf2 SynthDef\cf0 (\cf4 "Help-SynthDef"\cf0 , \
		\{ \cf2 arg\cf0  out=0;\
			 \cf2 Out\cf0 .ar(out, \cf2 PinkNoise\cf0 .ar(0.1))\
		\}).play(s); \
	)\
	\cf3 // The above only starts the new Synth after the def has been sent to the server.\cf0 \
	\cf3 // Note that SynthDef.play returns a Synth object\cf0 !\
		\
	x.set(\cf5 \\out\cf0 , 1); \cf3 // change one of the arguments\cf0 \
	x.free;\
	\
\cf3 // SynthDef with a parameter that will be randomly determined each time a new Synth is created\
// (try it several times to hear the differences)\cf0 \
\
	(\
	\cf2 SynthDef\cf0 (\cf4 "help-RandFreq"\cf0 , \{ \cf2 arg\cf0  out=0;\
		\cf2 Out\cf0 .ar(out, \
			\cf2 FSinOsc\cf0 .ar(\
				\cf2 Rand\cf0 (200.0, 400.0), \cf3 // frequency between 200 and 400 Hz\cf0 \
				0, \cf2 Line\cf0 .kr(0.2, 0, 1, doneAction:2))\
		)\
	\}).play(s);\
	)\
	}